
-- Author: Arkaan - "The Genetics Guy" (Github)
-- Addon Name: "Guild Roster Manager"

-- Global Tables
GRM_G = {}; 
-- Global Table to hold all global variables made by GRM.
GRM_L = {};
-- Localaztion array for all language initialization functions.
GRML = {};

-- slash commands (You can create custom one localized to your language in the localization folder)
SLASH_ROSTER1 = '/roster';
SLASH_GRM1 = '/grm';

-- Addon Details:
GRM_G.Version = "R1.9902";
GRM_G.PatchDay = 1701458138;             -- In Epoch Time
GRM_G.PatchDayString = "1701458138";     -- 2 Versions saves on conversion computational costs... just keep one stored in memory. Extremely minor gains, but very useful if syncing thousands of pieces of data in large guilds as Blizzard only allows data in string format to be sent
GRM_G.LvlCap = GetMaxPlayerLevel();
GRM_G.BuildVersion = select ( 4 , GetBuildInfo() ); -- Technically the build level or the patch version as an integer.

-- GroupInfo
GRM_G.GroupInfoV = 1.27;

-- Initialization Useful Globals 
-- ADDON
GRM_G.addonName = "Guild_Roster_Manager";
-- Player Details
GRM_G.guildName = "";
GRM_G.realmName = string.gsub ( string.gsub ( GetRealmName() , "-" , "" ) , "%s+" , "" );       -- Remove the space since server return calls don't include space on multi-name servers, also removes a hyphen if server is hyphened.Necessary for backend addon to addon comms formatting sende bvcxr.
GRM_G.addonUser = ( GetUnitName ( "PLAYER" , false ) .. "-" .. GRM_G.realmName );         -- Oddly, GetUnitName set as true will not reliably return realm name on non-merged realms without this formatting.
GRM_G.playerRankID = 0;         -- Player personal rank ID based on rank in the guild. The lowest, 0 , is the Guild Leader. This is only used for sync purposes and is configured on sync configuration.
GRM_G.clubID = 0;               -- The currently selected clubID (for community frame added in 8.0)
GRM_G.gClubID = 0;              -- The immutable guild clubID
GRM_G.faction = 0;
if UnitFactionGroup ( "PLAYER" ) == "Alliance" then
    GRM_G.faction = 1;
end

-- NoteSizes to allow dynamic flexibility if Blizz ever changes them.
GRM_G.MaxPublicNoteSize = StaticPopupDialogs["SET_GUILDPLAYERNOTE"].maxLetters;
GRM_G.MaxOfficerNoteSize = StaticPopupDialogs["SET_GUILDOFFICERNOTE"].maxLetters;
GRM_G.MaxCustomNoteSize = 150;

-- To ensure frame initialization occurse just once... what a waste in resources otherwise.
GRM_G.timeDelayValue = 0;
GRM_G.FramesInitialized = false;
GRM_G.CommunityInitialized = false;
GRM_G.ClassicRosterInitialized = false;
GRM_G.BlizzFramePinsInitialized = false;
GRM_G.OnFirstLoad = true;
GRM_G.currentlyTracking = false;
GRM_G.trackingTriggered = false;
GRM_G.InitializePreCheck = false;
GRM_G.IntegrityTackingEnabled = false;
GRM_G.tagFormatChangeNotice = false;
GRM_G.GRMfunctionDisabled = false;
GRM_G.secureHookKicks = false;

-- In Combat controls and UI frame handlers for such...
GRM_G.inCombat = false;
GRM_G.CoreFramesHidden = { false , false , false , false , false };
GRM_G.hideMessage = false;
GRM_G.minmapButtonDelay = false;
GRM_G.MacroDelay = false;

-- Guild Status holder for checkover.
GRM_G.guildStatusChecked = false;
GRM_G.GuildNamechangeProcessing = false;

-- UI Controls global for reset
GRM_G.UIIsLoaded = false;
GRM_G.playerOnlySettings = false;

-- Custom Roster Frame
GRM_G.RosterFrameInitialized = false;

-- Tempt Logs For FinalReport()
GRM_G.TempNewMember = {};
GRM_G.TempLogPromotion = {};
GRM_G.TempInactiveReturnedLog = {};
GRM_G.TempEventRecommendKickReport = {};
GRM_G.TempEventRecommendPromotionReport = {};
GRM_G.TempEventRecommendDemotionReport = {};
GRM_G.TempLogDemotion = {};
GRM_G.TempLogLeveled = {};
GRM_G.TempLogNote = {};
GRM_G.TempLogONote = {};
GRM_G.TempRankRename = {};
GRM_G.TempRejoin = {};
GRM_G.TempBannedRejoin = {};
GRM_G.TempLeftGuild = {};
GRM_G.TempLeftGuildPlaceholder = {};
GRM_G.TempNameChanged = {};
GRM_G.TempEventReport = {};
GRM_G.TempDeathReport = {};

-- Useful Globals for Quick Use
GRM_G.monthIndex = 1;
GRM_G.yearIndex = 1;
GRM_G.dayIndex = 1;

-- Alt Helpers
GRM_G.selectedName = {};
GRM_G.currentHighlightIndex = 0;
GRM_G.MaxAltAutoCompleteList = 30;      -- Max numer allowed for scrolling in the AddAlt auto-complete window.
GRM_G.NumberAltInSelection = 0;

-- Guildie info
GRM_G.autoCompleteBanList = {};
GRM_G.numAccounts = 0;
GRM_G.guildCreationDate = "";
GRM_G.DesignateMain = false;
GRM_G.numRanksHasChanged = false;
GRM_G.rankChangeShift = 0;

-- Time control gates
GRM_G.RosterClickTimer = 0;
GRM_G.ButtonRosterTimer = 0;             -- For the mouseover buttons on the CommunitiesFrame, OnEnter
GRM_G.ButtonRosterTimer2 = 0             -- For use with the older roster
GRM_G.refreshAddonUserDelay = 0;         -- For rechecking the users online with addon installed
GRM_G.SystemMsgThrottle = 0;             -- To prevent repeat scanning of the system message parsing needlessly.
GRM_G.CommunitiesUpdateTimer = 0;        -- Helps control Zone timer on mouseover window easier.

-- MISC argument resource saving globals.
GRM_G.playersStillOnServer = {};     -- keeps track of the players that have server transferred off.
GRM_G.LeftBanPlayersStillOnServer = {};     -- Keeping track of just the ban players who are no longer on the server (or possibly deleted toons too)
GRM_G.DelayedAtLeastOnce = false;
GRM_G.pause = false;                        -- Pause mouseover roster window from updating and changing on mouseover.
GRM_G.rankDateSet = false;
GRM_G.currentName = "";
GRM_G.RecursiveStop = false;
GRM_G.isChecked = false;
GRM_G.isChecked2 = false;
GRM_G.HasAccessToGuildChat = false;
GRM_G.HasAccessToOfficerChat = false;
GRM_G.tempAltName = "";
GRM_G.tempAddBanClass = "";
GRM_G.ChangesFoundOnLoad = false;
GRM_G.MsgFilterEnabled = false;
GRM_G.MsgFilterDelay = false;
GRM_G.MsgFilterDelay2 = false;
GRM_G.TooManyFriendsWarning = false;
GRM_G.TempListNamesAddedGUIDCheck = {};
GRM_G.OriginalEditBoxValue = "";             -- To hold in case player loses focus of editbox without changing anything.
GRM_G.previousNote = "-%";                   -- Gibberish not for comparison against on first load.
GRM_G.DropDownHighlightLockIndex = 1;
GRM_G.InitiatingBanEdit = false;
GRM_G.AltSideWindowFreeze = false;
GRM_G.AuditSortType = 1;
GRM_G.formatNumber = 1;
GRM_G.MainNameSystemMsgControl = false;     -- Control to prevent it checking the system message
GRM_G.NumberOfHoursTilRecommend = {}        -- number of hours til recommended to kick. This will process once settings are loaded.
GRM_G.SearchFocusControl = false;           -- For auto focusing the search box on the log

-- Scanning
GRM_G.SafeListExpirationChecking = false;
GRM_G.ScanningDelay = false;
GRM_G.CheckLog = false;
GRM_G.CheckGuild = false;
GRM_G.CurrentlyScanning = false;
GRM_G.ScanControl = 0;
GRM_G.DefaultMinScanTime = 5;
GRM_G.changeHappenedExitScan = false;

-- Export controls
GRM_G.ExportCap = 500;                      -- On exporting guild player details and exporting the guild log, max lines.
GRM_G.CounterCap = 0;                       -- Basically either the size of the log, or the size of the number of guildies, or size of number of left guildies.

-- Live Detection Controls
GRM_G.RejoinControlCheck = 0;
GRM_G.MacroMatchList = {};
GRM_G.MacroInProgress = false;
GRM_G.ClassicLeftErrorProtect = "";

-- Leadership Global Settings Controls
GRM_G.IsRadialChecked = false;

-- ALt Details Frame Controls
GRM_G.altDetailsControl = { 2 , true };

-- Ban Details Frame Controls
GRM_G.banDetailsControl = { 4 , true };

-- System message check and controls.
GRM_G.SystemMessageTest = true;
GRM_G.SystemMessageTestAnnounced = false;
GRM_G.DelayCount = 0

-- GuildLeader Controls
GRM_G.GuildInfo = "";
GRM_G.GlobalControl1 = false;               -- General sync
GRM_G.GlobalControl2 = false;               -- Ban sync
GRM_G.GlobalControl3 = false;               -- Custom note sync
GRM_G.GlobalControl4 = false;               -- Join date note location set
GRM_G.GlobalControl4_5 = false;             -- Join date headers
GRM_G.GlobalControl5 = false;               -- Timestamp Format
GRM_G.GlobalControl7 = false;               -- !note trigger for public note indicating activation of global setting

-- Calendar Globals
GRM_G.CalendarRegistered = false;
GRM_G.currentCalendarOffset = 1;
GRM_G.IsAltGrouping = false;
GRM_G.CurrentCalendarName = "";
GRM_G.CurrentCalendarHexCode = "";

-- Tooltip holdover.
GRM_G.toolTipScale = 1.0;

-- Backup Controls
GRM_G.BackupEntries = {};
GRM_G.BackupLoadedOnce = false;
GRM_G.BackupFrameSelectDetails = {};

-- Throttle controls
GRM_G.newPlayers = {};
GRM_G.leavingPlayers = {};
GRM_G.CheckingGUIDThroughFriendsList = false;
GRM_G.AutoCompleteThrottle = 0;                 -- important so it doesn't scan through entire database onTextTyping - on use only, mostly ok

-- ColorPicker Controls
GRM_G.MainTagColor = false;
GRM_G.GroupInfoIconColor = false;
GRM_G.MainTagHexCode = "";
GRM_G.mainTag = "";
GRM_G.altTag = "";
GRM_G.CurrentTagColorBox = 0;

-- Current Addon users
GRM_G.currentAddonUsers = {};
GRM_G.ReportedNoOfficerOnly = false;

-- Log Options Controls
GRM_G.LogNumbersColorUpdate = false;
GRM_G.FirstTimeViewed = true;
GRM_G.OldLogHeaderIsOn = false;
GRM_G.IndexOfLastLogEntry = 0;
GRM_G.fullLogMatch = {};
GRM_G.CurrentTotalCount = 0;
GRM_G.logSearch = false;

-- Version Control
GRM_G.VersionChecked = false;
GRM_G.VersionCheckRegistered = false;
GRM_G.VersionCheckedNames = {};
GRM_G.ActiveStatusQue = {};

-- For Temporary Slash Command Actions
GRM_G.ManualScanEnabled = false;
GRM_G.slashCommandSyncTimer = 0;

-- Banning players
GRM_G.TempBanTarget = {};
GRM_G.numberInGuildBans = 0;
GRM_G.CurrentBanSelectedName = {};
GRM_G.KickAllAltsTable = {};
GRM_G.KickAltControl = false;
GRM_G.kickBannedControl = false;
GRM_G.KickAllBannedTable = {};
GRM_G.customKickList = {};
GRM_G.customKickGroup = false;

-- FOR LOCALIZATION
GRM_G.Region = GetLocale();
GRM_G.Localized = false;
GRM_G.LocalizedIndex = 1;
GRM_G.FontChoice = "";
GRM_G.FontModifier = 0;
GRM_G.Status = {};

-- Debugging
GRM_G.DebugLog = {};
GRM_G.DebugEnabled = false;
GRM_G.DebugMsgEnabled = false;

-- AUDIT TOOLS
GRM_G.AuditToolGuildies = {};
GRM_G.JDAuditToolLastSelection = "";
GRM_G.customHeaderJoin = "";
GRM_G.customHeaderRejoin = "";
GRM_G.AuditEntries = {};
GRM_G.AuditEntryTotals = {};
GRM_G.AuditWindowRefresh = false;           -- Macro tool check

-- GameToolTip Helper
GRM_G.ToolTipTextLeft = {};
GRM_G.ToolTipTextRight = {};

-- Reference for reusable pattern default build to match.
GRM_G.CreationDatePattern = nil;

-- GRM Management Promo/Demote/kick too
GRM_G.HK = false;
GRM_G.MacroHotKey = "";

-- Configuration
GRM_G.AddonIsFullyConfigured = false;
GRM_G.SettingsPages = 16;
GRM_G.ForceAuto = false;    -- Force auto backup this session? For patching purposes

-- MouseOver
GRM_G.RosterSelection = 0;

-- Which frame to send AddMessage
GRM_G.Chat = {};
GRM_G.UnconfirmedChatTabs = {};
GRM_G.MainHookConfigured = false;

-- Unique Classic frame loads
GRM_G.rankShiftLoaded = false;

-- Misc Offset
GRM_G.OStimeOffset = 0;

-- Taint Protection
GRM_G.OpenRosterName = "";
GRM_G.ClassicTaintWarning = false;
GRM_G.RosterHotKey = "";
GRM_G.ClassicTaintProtection = false;

-- GRM Modules.
GRM_G.Module = {};

-- Group Tracking
GRM_G.InGroup = false;

-- Hardcore Mode Classic
GRM_G.HardcoreActive = false;
GRM_G.HardcoreHexCode = "|CFFBF0000"; -- Default RGB = .76 , 0 , 0 (r,g,b)


-- Useful Lookup Tables for date indexing.

GRM_G.classFileIDEnum = { ["WARRIOR"]=1 , ["PALADIN"]=2 , ["HUNTER"]=3 , ["ROGUE"]=4 , ["PRIEST"]=5 , ["DEATHKNIGHT"]=6 , ["SHAMAN"]=7 , ["MAGE"]=8 , ["WARLOCK"]=9 , ["MONK"]=10 , ["DRUID"]=11 , ["DEMONHUNTER"]=12 , ["EVOKER"] = 13 };
local monthEnum = { Jan = 1 , Feb = 2 , Mar = 3 , Apr = 4 , May = 5 , Jun = 6 , Jul = 7 , Aug = 8 , Sep = 9 , Oct = 10 , Nov = 11 , Dec = 12 };
local monthEnum2 = { ['1'] = "Jan" , ['2'] = "Feb" , ['3'] = "Mar", ['4'] = "Apr" , ['5'] = "May" , ['6'] = "Jun" , ['7'] = "Jul" , ['8'] = "Aug" , ['9'] = "Sep" , ['10'] = "Oct" , ['11'] = "Nov" , ['12'] = "Dec" };
local monthsFullnameEnum = { January = 1 , February = 2 , March = 3 , April = 4 , May = 5 , June = 6 , July = 7 , August = 8 , September = 9 , October = 10 , November = 11 , December = 12 };
local monthAbbrev = { "Jan" , "Feb" , "Mar" , "Apr" , "May" , "Jun" , "Jul" , "Aug" , "Sep" , "Oct" , "Nov" , "Dec" };
local daysBeforeMonthEnum = { ['1']=0 , ['2']=31 , ['3']=59 , ['4']=90 , ['5']=120 , ['6']=151 , ['7']=181 , ['8']=212 , ['9']=243 , ['10']=273 , ['11']=304 , ['12']=334 };
local daysInMonth = { ['1']=31 , ['2']=28 , ['3']=31 , ['4']=30 , ['5']=31 , ['6']=30 , ['7']=31 , ['8']=31 , ['9']=30 , ['10']=31 , ['11']=30 , ['12']=31 };
local AllClasses = { "Deathknight" , "Demonhunter" , "Druid" , "Evoker" , "Hunter" , "Mage" , "Monk" , "Paladin" , "Priest" , "Rogue" , "Shaman" , "Warlock" , "Warrior" }; -- This is only here as an alphabetized list
local raceIDEnum = { ["Human"]=1 , ["Orc"]=2 , ["Dwarf"]=3 , ["NightElf"]=4 , ["Scourge"]=5 , ["Tauren"]=6 , ["Gnome"]=7 , ["Troll"]=8 , ["Goblin"]=9 , ["BloodElf"]=10 , ["Draenei"]=11 , ["Worgen"]=22 , ["Pandaren"]=24 , ["Nightborne"]=27 , ["HighmountainTauren"]=28 , ["VoidElf"]=29 , ["LightforgedDraenei"]=30 , ["ZandalariTroll"]=31 , ["KulTiran"]=32 , ["DarkIronDwarf"]=34 , ["Vulpera"]=35 , ["MagharOrc"]=36 , ["Mechagnome"]=37 , ["Dracthyr"] = 52 };

local GuildRanks = {};  -- Necessary to have the current ranks in a global table for when changed and so they can be carried over each session

------------------------
------ FRAMES ----------
------------------------

-- Live Frames - Keep them separate for easier to read code...
local Initialization = CreateFrame ( "Frame" );
local GeneralEventTracking = CreateFrame ( "Frame" );
local UI_Events = CreateFrame ( "Frame" );
local VersionCheck = CreateFrame ( "Frame" );
local SystemMessageChecking = CreateFrame ( "Frame" );
local AddonUsersCheck = CreateFrame ( "Frame" );
local AchievementsChecking = CreateFrame ( "Frame" );
GRM_G.StatusChecking = CreateFrame ( "Frame" );
GRM_G.StatusChecking.Timer = 0;

--------------------------------------------
----- COMPATIBILITY WITH CLASSIC BUILDS ----
-------- NEEDED DUE TO 10.0 DF CHANGES -----
--------------------------------------------


-- Method           GRM.CreateTexture ( frame , string , string )
-- What it Does:    Wraps 2 ways to implement the texture, for version compatibility
-- Purpose:         Version Compatibility
GRM.CreateTexture = function ( frame , name , layer , useFrame )
    local heritableFrame = nil;

    if GRM_G.BuildVersion >= 11404 then
        frame[name] = frame:CreateTexture ( nil , layer , nil , 0 );
    else

        if useFrame then
            heritableFrame = frame;
        end
        frame[name] = frame:CreateTexture ( name , layer , heritableFrame , nil );

    end
end

-- Method:          GRM.TabResize ( frameObject, int , int )
-- What it Does:    Reframes a tab for all classic builds prior 10.0
-- Purpose:         The UI changes in 10.0 negate the need of this.
GRM.TabResize = function ( tabFrame , Width , Height )
    if GRM_G.BuildVersion < 100000 then
        PanelTemplates_TabResize ( tabFrame , nil , 76 , 25 );
    else
        tabFrame:SetHighlightTexture ( "Interface\\Buttons\\ButtonHilight-Square" );
    end
end

-- Due to deprecated templates, these need to be used for duel compatibility
if GRM_G.BuildVersion >= 100000 then
    GRM_G.CheckButtonTemplate = "InterfaceOptionsCheckButtonTemplate";
    GRM_G.TabTemplate = "MinimalTabTemplate";

else
    GRM_G.CheckButtonTemplate = "OptionsSmallCheckButtonTemplate";
    GRM_G.TabTemplate = "TabButtonTemplate";
end
-------------------------------
--- END COMPATIBILITY CHECK ---
-------------------------------

--------------------------
--- STATUS FUNCTIONS -----
--------------------------

GRM.InGroupLogic = function()

    if IsInGroup() and not GRM_G.InGroup then
        GRM_G.RegisterMessage();
        GRMsyncGlobals.IsElectedLeader = false;
        GRMsyncGlobals.DesignatedLeader = "";
        GRM_G.GroupSyncRestrictionControl = true;
        GRM_G.GroupSyncRestrictionTimerDelay = time();

    elseif not IsInGroup() and GRM_G.InGroup then
        GRM_G.GroupSyncRestrictionControl = false;
        GRM_G.GroupSyncRestrictionTimerDelay = time();
        GRM_G.RegisterMessage();
    end

end

-- PLAYER STATUS MAINTENANCE FOR INCOMBAT/OUTOFCOMBAT STATUS as well as InGroup and Out of group checks
GRM_G.StatusChecking:RegisterEvent ( "PLAYER_REGEN_ENABLED" );
GRM_G.StatusChecking:RegisterEvent ( "PLAYER_REGEN_DISABLED" );
GRM_G.StatusChecking:RegisterEvent ( "GROUP_ROSTER_UPDATE" );
GRM_G.StatusChecking:RegisterEvent ( "GROUP_FORMED" );
GRM_G.StatusChecking:RegisterEvent ( "GROUP_LEFT" );
GRM_G.StatusChecking:RegisterEvent ( "PLAYER_ROLES_ASSIGNED" );
GRM_G.StatusChecking:SetScript ( "OnEvent" , function ( _ , event )

    if IsInGuild() then
        local eventList = { ["GROUP_ROSTER_UPDATE"] = true , ["PLAYER_ROLES_ASSIGNED"] = true , }

        if event == "PLAYER_REGEN_ENABLED" then
            GRM_G.inCombat = false;
            GRM.FrameCombatRestore()

        elseif event == "PLAYER_REGEN_DISABLED" then
            GRM_G.inCombat = true;
            GRM.FrameCombatHide();

        elseif eventList[event] then

            if GRM_G.Module.GroupInfo ~= nil then
                GRM_GI.EventListener();
            end

        elseif event == "GROUP_FORMED" then
            GRM.InGroupLogic();
            GRM_G.InGroup = true;
        elseif event == "GROUP_LEFT" then
            GRM.InGroupLogic();
            GRM_G.InGroup = false;
        end
    end
end);

-- Method:          GRM.FrameCombatHide()
-- What it Does:    Hides all GRM windows that are visible
-- Purpose:         GRM windows should auto-close when combat starts, but should auto re-open shortly after
GRM.FrameCombatHide = function()

    if GRM.S().hideFramesInCombat then
        -- Mouseover Frame
        if GRM_UI.GRM_MemberDetailMetaData and GRM_UI.GRM_MemberDetailMetaData:IsVisible() then
            GRM_UI.GRM_MemberDetailMetaData:Hide();
            GRM_G.CoreFramesHidden[1] = true;
            GRM_G.CoreFramesHidden.hidden = true
        end

        -- Core GRM window
        if GRM_UI.GRM_RosterChangeLogFrame and GRM_UI.GRM_RosterChangeLogFrame:IsVisible() then
            GRM_UI.GRM_RosterChangeLogFrame:Hide();
            GRM_G.CoreFramesHidden[2] = true;
            atLeastOneHidden = true;
            GRM_G.CoreFramesHidden.hidden = true
        end

        -- Export Tool
        if GRM_UI.GRM_ExportLogBorderFrame and GRM_UI.GRM_ExportLogBorderFrame:IsVisible() then
            GRM_UI.GRM_ExportLogBorderFrame:Hide();
            GRM_G.CoreFramesHidden[3] = true;
            atLeastOneHidden = true;
            GRM_G.CoreFramesHidden.hidden = true
        end

        -- Macro Tool
        if GRM_UI.GRM_ToolCoreFrame and GRM_UI.GRM_ToolCoreFrame:IsVisible() then
            GRM_UI.GRM_ToolCoreFrame:Hide();
            GRM_G.CoreFramesHidden[4] = true;
            GRM_G.CoreFramesHidden.hidden = true
        end

        -- Roster Frame
        if GRM_UI.GRM_RosterFrame and GRM_UI.GRM_RosterFrame:IsVisible() then
            GRM_UI.GRM_RosterFrame:Hide();
            GRM_G.CoreFramesHidden[5] = true;
            GRM_G.CoreFramesHidden.hidden = true
        end

        -- Audit Tool
        if GRM_UI.GRM_AuditJDTool and GRM_UI.GRM_AuditJDTool:IsVisible() then
            GRM_UI.GRM_AuditJDTool:Hide();
            GRM_G.CoreFramesHidden[6] = true;
            GRM_G.CoreFramesHidden.hidden = true
        end

        if not GRM_G.hideMessage and GRM_G.CoreFramesHidden.hidden then
            GRM.Report ( GRM.L ( "In-combat. Hiding all GRM windows" ) );
            GRM_G.hideMessage = true;   -- Will only message once per session
        end
    end

end

-- Method:          GRM.FrameCombatRestore()
-- What it Does:    If any frames were hidden during combat, this restores them
-- Purpose:         Control GRM frames
GRM.FrameCombatRestore = function()

    if GRM_G.CoreFramesHidden.hidden then
        if GRM_G.CoreFramesHidden[1] then
            if ( GRM_G.BuildVersion >= 80000 and CommunitiesFrame and CommunitiesFrame:IsVisible() ) or ( GRM_G.BuildVersion < 80000 and FriendsFrame and FriendsFrame:IsVisible() ) then
                GRM_UI.GRM_MemberDetailMetaData:Show();
            end
            GRM_G.CoreFramesHidden[1] = false;
        end
        if GRM_G.CoreFramesHidden[2] then
            GRM_UI.GRM_RosterChangeLogFrame:Show();
            GRM_G.CoreFramesHidden[2] = false;
        end
        if GRM_G.CoreFramesHidden[3] then
            GRM_UI.GRM_ExportLogBorderFrame:Show();
            GRM_G.CoreFramesHidden[3] = false;
        end
        if GRM_G.CoreFramesHidden[4] then
            GRM_UI.GRM_ToolCoreFrame:Show();
            GRM_G.CoreFramesHidden[4] = false;
        end
        if GRM_G.CoreFramesHidden[5] then
            GRM_UI.GRM_RosterFrame:Show();
            GRM_G.CoreFramesHidden[5] = false;
        end
        if GRM_G.CoreFramesHidden[6] then
            GRM_UI.GRM_AuditJDTool:Show();
            GRM_G.CoreFramesHidden[6] = false;
        end
    end

    GRM_G.CoreFramesHidden.hidden = false
end

------------------------------
--- EXTERNAL COMPATIBILITY ---
------------------------------

-- Method:          GRM.GetWowProgressLink ( string )
-- What it Does:    Generates an HTML link to the player's WOWPROGRESS page
-- Purpose:         Easy access to player's wowprogress link
GRM.GetWowProgressLink = function ( name )

    local charList = { "'" , "%s" };
    local region = string.lower ( GetCurrentRegionName() );
    local server = string.lower ( string.match ( name , "-(.+)" ) );
    name = string.lower ( GRM.SlimName ( name ) );

    for i = 1 , #charList do
        server = string.gsub ( server , charList[i] , "-" );
    end

    return "https://www.wowprogress.com/character/" .. region .. "/" .. server .. "/" .. name;
end

-- Method:          GRM.GetRaiderIOLink ( string )
-- What it Does:    Returns HTML link for Raider.IO
-- Purpose:         Easy access to player's raider.io link
GRM.GetRaiderIOLink = function ( name )

    local region = string.lower ( GetCurrentRegionName() );
    local server = string.lower ( string.match ( name , "-(.+)" ) );
    name = string.lower ( GRM.SlimName ( name ) );

    server = string.gsub ( server , "%s" , "-" );
    server = string.gsub ( server , "'" , "" );

    return "https://raider.io/characters/" .. region .. "/" .. server .. "/" .. name;
end

--------------------------
------- SETTINGS ---------
--------------------------

-- Method:          GRM.ClearPermData()
-- What it Does:    Resets all the saved data back to nothing... and does not rebuid it.
-- Purpose:         Mainly for use if ever there is a need to purge the data
GRM.ClearPermData = function()

    GRM_GuildMemberHistory_Save = nil;
    GRM_GuildMemberHistory_Save = {};
    
    GRM_PlayersThatLeftHistory_Save = nil;
    GRM_PlayersThatLeftHistory_Save = {};

    GRM_AddonSettings_Save = nil;
    GRM_AddonSettings_Save = {};
    
    GRM_LogReport_Save = nil;
    GRM_LogReport_Save = {};

    GRM_CalendarAddQue_Save = nil;
    GRM_CalendarAddQue_Save = {};

    GRM_GuildDataBackup_Save = nil;
    GRM_GuildDataBackup_Save = {};

    GRM_PlayerListOfAlts_Save = nil;
    GRM_PlayerListOfAlts_Save = {};

    -- Player speicif save tables
    GRM_DebugLog_Save = nil;
    GRM_DebugLog_Save = {};
    GRM_Misc = nil;
    GRM_Misc = {};
    GRM.ConfigureAnnounceOnLogin ( true );

    return GRM_GuildMemberHistory_Save , GRM_PlayersThatLeftHistory_Save , GRM_AddonSettings_Save , GRM_LogReport_Save , GRM_CalendarAddQue_Save , GRM_GuildDataBackup_Save , GRM_PlayerListOfAlts_Save;
end

-- Method:          GRM.ConfigureMiscForPlayer( string );
-- What it Does:    Builds a file for tracking active data that can be reference back to on a relog... so as to mark where to carry on from
-- Purpose:         In case a player logs out in the middle of critical things, both front and backend, it has a marker stored on where to restart from.
GRM.ConfigureMiscForPlayer = function( playerFullName )
    GRM_Misc[playerFullName] = {
        { false , {} },                 -- 1) To hold the details on Added Friends that might need to be removed from logging off
    };

end

-- Method:          GRM.GetRankRestrictedDefaultRankIndex();
-- What it Does:    Returns the index based on the rank restricted default of a guild, which is a number based on total number of ranks in the guild.
-- Purpose:         For establishing default settings, it is important to know what the default rank is in the guild.
GRM.GetRankRestrictedDefaultRankIndex = function()
    local rankRestrictedDefault;
    if IsInGuild() then
        rankRestrictedDefault = GuildControlGetNumRanks() - 1;
    else
        rankRestrictedDefault = 2;
    end
    return rankRestrictedDefault;
end

-- Method:          GRM.GetFirstOfficerRank()
-- What it Does:    Gets the first rank that can view officer notes, thus IS an officer
-- Purpose:         So it can have a default Ban Sync Rank.
GRM.GetFirstOfficerRank = function()
    local rank = 1;

    for i = 2 , GuildControlGetNumRanks() do
        if not C_GuildInfo.GuildControlGetRankFlags( i )[12] then
            rank = i - 1;
            break;
        end
    end

    return rank - 1; -- Because it starts at Index 0 whilst these control Ranks start at 1
end

-- Method:          GRM.SetDefaultAddonSettings( object , int )
-- What it Does:    Establishes the default addon setttings for all of the options and some other misc. stored variables, like minimap position
-- Purpose:         Easy access to settings on a default reset.
GRM.SetDefaultAddonSettings = function ( player , page )

    -- Misc needs a tab home
        player.useFullName = false;
        if not player.removedMacroRules then
            player.removedMacroRules = {};
        end

    -- Page 0 = misc stuff unrelated to specific settings
    if page == 0 then
        player.showMouseoverRetail = true;
        player.showMouseoverOld = true;
        player.minimapPos = 345;
        player.minimapRad = 78;
        player.customPos = false;
        player.macroToolCoordinates = { "" , "" , 0 , 0 };
        player.minimapCustomPos = { "" , "" };
        player.CoreWindowPos = { "" , "" , 0 , 0 };
        player.SyncTrackerPOS = { "" , "" , 0 , 0 };
        player.RosterFramePOS = { "" , "" , 0 , 0 };
        player.disableMacroToolLogSpam = false;
        player.ignoreDeadNames = false;
        player.JDAuditToolFilter = false;
        
        -- GRM Roster
        player.showMains = true;
        player.showAlts = true;
        player.showMainTags = false;
        player.showAltTags = false;
        player.showRosterOffline = true;
        player.showRosterOptions = true;
        player.groupByMain = false;
        player.numRosterRows = 18;

        local rosterFrameDefault = 885;
        if GRM_G.BuildVersion >= 80000 then
            rosterFrameDefault = rosterFrameDefault + 90;
        end
        
        player.UIScaling = { { 600 , 535 , 1.0 } , { 400 , 439 , 1.0 } , { 1200 , 515 , 1.0 } , { 1075 , 540 , 1.0 } , { 875 , 400 , 1.0 } , { rosterFrameDefault , 525 , 1.0 } };
        
    -- General Options Tab
    elseif page == 1 then
        player.viewOnLoad = true;
        player.onlyViewIfChanges = true;
        player.showMainName = true;
        player.syncSettings = true;
        player.minimapEnabled = true;
        player.twentyFourHrScale = GRM.Use24HrBasedOnDefaultLanguage();
        player.mainTagIndex = 2;
        player.selectedLang = GRM_G.LocalizedIndex;
        player.selectedFont = 1;
        player.fontModifier = 0;
        player.mainTagColor = {};
        player.mainTagColor.r = 1;
        player.mainTagColor.g = 0;
        player.mainTagColor.b = 0;
        player.tooltipSize = 0.9;
        player.dateFormat = 1;
        player.useMainTag = true;
        player.reportChannel = {};
        player.defaultTabSelection = { false , 1 };
        player.syncCompatibilityMsg = false;
        
    -- Scan Options Tab
    elseif page == 2 then
        player.inactiveHours = 336;
        player.eventAdvanceDays = 14;
        player.scanDelay = 30;
        player.calendarAnnouncements = true;
        player.reportInactiveReturn = true;
        player.onlyAnnounceForMain = false;
        player.scanEnabled = true;
        player.levelReportMin = 10;
        player.levelFilters = {true,true,true,true,true,true,true,true,true};
        player.allAltRequirement = true;
        player.recordLevelUp = true;
        player.AnnounceBdayOnLogin = true;
        player.bdayAnnounce = true;
        player.annivAnnounce = true;
        
    -- Sync Options Tab
    elseif page == 3 then
        player.syncEnabled = true;
        player.syncRank = GRM.GetRankRestrictedDefaultRankIndex();
        player.syncChatEnabled = true;
        player.syncBanList = true;
        player.syncRankBanList = GRM.GetFirstOfficerRank();
        player.exportAllRanks = true;
        player.syncCustomNote = true;
        player.syncRankCustom = GRM.GetRankRestrictedDefaultRankIndex();
        player.syncBDays = true;
        player.autoTriggerSync = true;
        player.syncDelay = 60;
        
    -- Officer Options Tab
    elseif page == 4 then
        player.addTimestampToNote = false;
        player.allowEventsToCalendar = true;
        player.joinDateDestination = 1;
        player.customTags = { "" , "" };
        player.includeTag = true;
        player.addNotesToLeft = true;
        player.noteSetEnabled = true;
        player.globalDateFormat = 1;
        
    -- Backup Options Tab
    elseif page == 5 then


    -- Help Options Tab
    elseif page == 6 then


    -- UI Options Tab
    elseif page == 7 then

        player.showLevel = true;
        player.showLevelMaxOnly = false;
        player.showMythicRating = true;
        player.showFaction = true;

        -- No cross-faction guilds prior to Dragonflight expansion
        if GRM_G.BuildVersion < 100000 then
            player.showFaction = false;
        end
        player.useFade = false;

        -- No guild rep pre-Cataclysm expansion.
        if GRM_G.BuildVersion < 40000 then
            player.viewGuildRep = false;
        else
            player.viewGuildRep = true;
        end

        player.showBorders = false; -- Off by default
        player.showBDay = true;
        player.colorizeNames = true;
        player.colorizeClassicRosterNames = true;
        player.hideFramesInCombat = true;
        
    -- Log Options and Side Window
    elseif page == 8 then
        player.toLog = {};
        player.toChat = {};

        local s = "toLog";
        for i = 1 , 2 do

            if i == 2 then
                s = "toChat";
            end
            
            player[s].joined = true;
            player[s].leveled = true;
            player[s].inactiveReturn = true;
            player[s].promotion = true;
            player[s].demotion = true;
            player[s].note = true;
            player[s].officerNote = true;
            player[s].customNote = true;
            player[s].nameChange = true;
            player[s].rankRename = true;
            player[s].eventAnnounce = true;
            player[s].left = true;
            player[s].recommend = true;
            player[s].banned = true;

            if GRM_G.HardcoreActive then
                if i == 1 then
                    player[s].death = true;
                else
                    player[s].death = false;
                end
            end
            
        end

        player.showLineNumbers = true;
        player.shiftClickRemove = true;
        player.autoFocusSearch = false;
        player.showTooltip = true;
        player.logFontSize = 0;
        player.logColor = {             -- 15 total
            { 0.5 , 1.0 , 0.0 },        -- Joined 
            { 0.0 , 0.44 , 0.87 },      -- Leveled
            { 0.0 , 1.0 , 0.87 },       -- Inactive Return
            { 1.0 , 0.914 , 0.0 },      -- Promotions
            { 0.91 , 0.388 , 0.047 },   -- Demotions
            { 1.0 , 0.6 , 1.0 },        -- Note
            { 1.0 , 0.094 , 0.93 },     -- Officer Note
            { 0.24 , 0.69 , 0.49 },     -- Custom Note
            { 0.90 , 0.82 , 0.62 },     -- Name Change
            { 1 , 1 , 1 },   -- Rank Rename
            { 0.0 , 0.8 , 1.0 },        -- Event Announce
            { 0.5 , 0.5 , 0.5 },        -- Left Guild
            { 0.65 , 0.19 , 1.0 },      -- Recommendations
            { 1.0 , 0.0 , 0.0 },        -- Banned Coloring
            { 0.76 , 0.0 , 0.0 }         -- Death

        };
        
    -- Export Options
    elseif page == 9 then
        player.exportDelimiter = { true , ";" };
        player.specialCharRemoval = false;
        player.columnHeaders = false;
        player.ExportLevelRange = {1,999};  -- 999 represents MaxLevel
        player.exportFilters = {};
        player.exportFilters.name = true;
        player.exportFilters.rank = true;
        player.exportFilters.level = true;
        player.exportFilters.class = true;
        player.exportFilters.race = true;
        player.exportFilters.sex = true;
        player.exportFilters.lastOnline = true;
        player.exportFilters.mainAlt = true;
        player.exportFilters.alts = true;
        player.exportFilters.joinDate = true;
        player.exportFilters.promoteDate = true;
        player.exportFilters.rankHist = true;
        player.exportFilters.bday = true;
        player.exportFilters.rep = true;
        player.exportFilters.note = true;
        player.exportFilters.oNote = true;
        player.exportFilters.cNote = true;
        player.exportFilters.mythicScore = true;
        player.exportFilters.faction = true;
        player.exportFilters.GUID = false;
        player.exportFilters.MainOrAlt = false;
        player.exportFilters.mainOnly = true;

        if GRM_G.HardcoreActive then
            player.exportHardcoreSort = 1;
        end

        if GRM_G.BuildVersion < 40000 then
            player.exportFilters.rep = false;
        end

        if GRM_G.BuildVersion < 80000 then
            player.exportFilters.mythicScore = false;
        end
        
    -- Macro Tool Kick Options
    elseif page == 10 then
        player.kickRules = {};
        player.macroSyncKickEnabled = true;
        player.ignoreFilter = false;
        player.removedMacroRules.kickRules = {};
        player.macroHotKey = "CTRL-SHIFT-K";

    -- Macro Tool Promote Options
    elseif page == 11 then
        player.promoteRules= {};
        player.macroSyncPromoteEnabled = true;
        player.ignoreFilter = false;
        player.removedMacroRules.promoteRules = {};
        player.promoteOnlineOnly = false;
        player.macroHotKey = "CTRL-SHIFT-K";

    -- Macro Tool Demote Options
    elseif page == 12 then
        player.demoteRules = {};
        player.macroSyncDemoteEnabled = true;
        player.ignoreFilter = false;
        player.removedMacroRules.demoteRules = {};
        player.demoteOnlineOnly = false;
        player.macroHotKey = "CTRL-SHIFT-K";
    
    -- Audit
    elseif page == 13 then
        player.onlyShowIncomplete = false;
        player.unknownIsComplete = true;
        player.includeBirthdaysInAudit = false;
        
    -- Macro Tool Special Options
    elseif page == 14 then
        player.specialRules = {};
        player.macroSyncSpecialEnabled = true;
        player.ignoreFilter = false;
        player.removedMacroRules.specialRules = {};
        player.macroHotKey = "CTRL-SHIFT-K";

    -- Modules
    elseif page == 15 then

        -- GroupInfoModule
        player.GIModule = {};
        player.GIModule.enabled = true;
        player.GIModule.InteractDistanceIndicator = true;
        player.GIModule.tradeIndicatorColorAny = { 0 , 0.97 , 0.97 };
        player.GIModule.tradeIndicatorColorConnectedRealm = { 0 , 0.97 , 0.97 };
        player.GIModule.DisableGroupInfoTooltip = false;

    -- Hardcore Mode
    elseif page == 16 then
        player.includeDeathTime = true;
        player.addDeathTag = true

    end

end

-- Method:          GRM.IsSettingsConfigured()
-- What it Does:    Returns true if the settings are an old format
-- Purpose:         Cleanup the settings check on login.
GRM.IsSettingsConfigured = function()
    local result = true;

    if ( GRM.TableLength ( GRM_AddonSettings_Save ) == 0 and #GRM_AddonSettings_Save == 0 and GRM_AddonSettings_Save[1] == nil ) then
        result = false;
    end

    return result;
end

-- Method:          GRM.RefreshAllSettings()
-- What it Does:    Resets the whole addon due to missing save settings data.
-- Purpose:         Adapt the new DB.
GRM.RefreshAllSettings = function()
    GRM_GuildMemberHistory_Save , GRM_PlayersThatLeftHistory_Save , GRM_AddonSettings_Save , GRM_LogReport_Save , GRM_CalendarAddQue_Save , GRM_GuildDataBackup_Save , GRM_PlayerListOfAlts_Save = GRM.ClearPermData();
    GRM_AddonSettings_Save.VERSION = GRM_G.Version;
end

-- Method:          GRM.IsOldSettingsFormat()
-- What it Does:    Clears the old settings and rebuilds the database to new format.
-- Purpose:         Necessary for changes and backwards compatibility
GRM.IsOldSettingsFormat = function()
    local result = false;

    if ( IsInGuild() and GRM_AddonSettings_Save[GRM_G.guildName] ) then
        if not GRM_AddonSettings_Save.VERSION then
            GRM_AddonSettings_Save.VERSION = GRM_G.Version;
        end
        result = false;
    elseif not GRM_AddonSettings_Save.VERSION then
        return true;
    end

    return result;
end

-- Method:          GRM.UpdateOldSettingsFormat()
-- What it Does:    Updates the addon from the old settings style
-- Purpose:         The database has shifted over time and this allows backwards compatibility.
GRM.UpdateOldSettingsFormat = function()

    local playerV = "";
    local isFound = false;

    if GRM_AddonSettings_Save[1] or GRM_AddonSettings_Save["H"] then

        if GRM_AddonSettings_Save["H"] then
            if GRM_AddonSettings_Save["H"].version ~= nil then
                GRM_AddonSettings_Save["H"].version = nil;
            end
        end
        if GRM_AddonSettings_Save["A"] then
            if GRM_AddonSettings_Save["A"].version ~= nil then
                GRM_AddonSettings_Save["A"].version = nil;
            end
        end
        playerV = GRM_Patch.ManageOldSettingsDB();
        
    else

        -- 1.84 and on
        if GRM_AddonSettings_Save[GRM_G.addonUser] ~= nil and GRM_AddonSettings_Save[GRM_G.addonUser].version ~= nil then
            isFound = true;
            playerV = GRM_AddonSettings_Save[GRM_G.addonUser].version;
        end

        -- Build settings for first time.
        if not isFound then

            -- Need to check version of any player.
            for name in pairs ( GRM_AddonSettings_Save ) do
                if GRM_AddonSettings_Save[name].version ~= nil and GRM_AddonSettings_Save[name].version ~= GRM_G.Version then
                    playerV = GRM_AddonSettings_Save[name].version;
                    break;
                end
            end

            if ( playerV == "" or playerV == nil ) and IsInGuild() then

                if not GRM_AddonSettings_Save[GRM_G.guildName] then
       
                    -- Add new guild
                    GRM_AddonSettings_Save[GRM_G.guildName] = {};
    
                    -- Load the Default Settings
                    for i = 0 , GRM_G.SettingsPages do
                        GRM.SetDefaultAddonSettings ( GRM_AddonSettings_Save[GRM_G.guildName] , i );
                    end
    
                    -- Forcing core log window/options frame to load on the first load ever as well
                    GRM_G.ChangesFoundOnLoad = true;
    
                end
    
                if GRM_AddonSettings_Save[GRM_G.addonUser] then
                    GRM_G.playerOnlySettings = true;
                    GRM_AddonSettings_Save[GRM_G.guildName].syncSettings = false;
                    GRM_AddonSettings_Save[GRM_G.addonUser].syncSettings = false;
                end
            end
        end
    end

    -- Some error protection for some edge cases pre 1.978
    if not playerV or playerV == "" then
        playerV = GRM_G.Version;
    end

    return playerV;
end

-- Method:          GRM.LoadSettings()
-- What it Does:    On first time loading addon, it builds default addon settings. It checks for addon version change
--                  And, if there are any changes, they will be added into that logic block. 
--                  And new setting can be tagged on.
-- Purpose:         Saving settings between gaming sessions. Also, this is built to provide backwards compatibility for future flexibility on feature adding, if necessary.
GRM.LoadSettings = function()
    
    local playerV = "";
    
    if not GRM.IsSettingsConfigured() then
        GRM.RefreshAllSettings();
    end
    -- This means we are in the old database that needs to be updated.
    -- Pre 1.84
    if GRM.IsOldSettingsFormat() then
        playerV = GRM.UpdateOldSettingsFormat();
    else
        playerV =  GRM_AddonSettings_Save.VERSION;
        if IsInGuild() then

            if not GRM_AddonSettings_Save[GRM_G.guildName] then

                -- No settings established yet.
                GRM.Report ( "\n" .. GRM.L ( "Configuring Guild Roster Manager for {name} for the first time." , GRM.SlimName(GRM_G.guildName) ) );

                -- Add new guild
                GRM_AddonSettings_Save[GRM_G.guildName] = {};

                -- Load the Default Settings
                for i = 0 , GRM_G.SettingsPages do
                    GRM.SetDefaultAddonSettings ( GRM_AddonSettings_Save[GRM_G.guildName] , i );
                end

                -- Forcing core log window/options frame to load on the first load ever as well
                GRM_G.ChangesFoundOnLoad = true;

            end

            if GRM_AddonSettings_Save[GRM_G.addonUser] then
                GRM_G.playerOnlySettings = true;
                GRM_AddonSettings_Save[GRM_G.guildName].syncSettings = false;
                GRM_AddonSettings_Save[GRM_G.addonUser].syncSettings = false;
            end

        end

    end

    if playerV ~= nil and playerV ~= "" then
        -- PATCH FIXES
        if string.find ( playerV , "R" ) == nil then
            playerV = "R" .. playerV;
        end

        GRM_Patch.SettingsCheck ( tonumber ( string.match ( playerV , "R(.+)" ) ) );
        
    else
        -- No need to delay
        GRM.FinalSettingsConfigurations();
        GRM_G.currentlyPatching = false;
    end

end

-- Method:          GRM.GuildSpecificConfigurations()
-- What it Does:    Triggers configurations in a guild based on settings preferences.
-- Purpose:         Need to trigger if player joins a guild.
GRM.GuildSpecificConfigurations = function()
    if IsInGuild() then
        GRM_UI.CorePositionInit();
        GRM_UI.CoreToolPositionInit();
        -- GRM_UI.CoreSyncTrackerInit();
        -- Register window to save data to.
        GRM.SetReportWindow();
        GRM.RefreshMainTagHexCode();
        GRM.SetGuildInfoDetails(); -- an early systems check too
        -- The Tag Headers
        GRM.SetJoinAndRejoinTags();
        -- General one-time configurations
        GRM.RefreshNumberOfHoursTilRecommend();
    end
end

-- Method:          GRM.FinalSettingsConfigurations()
-- What it Does:    Calculates the final settings configurations
-- Purpose:         Compartmentalizes this so it can only be on call as needed.
GRM.FinalSettingsConfigurations = function()

    -- Verify Settings DB is good
    GRM.VerifyAddonSettings();

    -- In case of disconnect during some events that you may need to continue from.
    GRM.MiscCleanupOnLogin();
    -- Let's load that minimap button now too...
    GRM_UI.GRM_MinimapButtonInit();
    -- One time processing, saves a bit of resources for an oft used string manipulation feature.
    
    if IsInGuild() then
        GRM.GuildSpecificConfigurations()
    else
        GRM.SetReportWindow();
    end

    -- Re-setup macro
    if GRM_G.BuildVersion < 40000 then
        GRM.BuildGuildRosterHotkeyAndMacroCLASSIC();
    else
        GRM.BuildGuildRosterHotkeyAndMacro();
    end

    -- For sync...
    GRMsyncGlobals.timeAtLogin = time();    -- Important for Sync Leader backend election algorithm.

    -- Classic Chat coloring
    GRM.SetClassChatColoring()
    GRM.SetChatColoring();

    GRM_G.AddonIsFullyConfigured = true;
    GRM_API.Initialized = true;

    -- Settings loaded... carry on.
    GRM.SettingsLoadedFinishDataLoad();

end

-- Method:          GRM.VerifyAddonSettings()
-- What it Does:    Validates the settings by adding missing or removing redundant.
-- Purpose:         Cleanup the Save DB
GRM.VerifyAddonSettings = function()

    -- Build the template
    local player = {};
    for i = 0 , GRM_G.SettingsPages do
        GRM.SetDefaultAddonSettings ( player , i );
    end

    local Validate = function ( saveSettings )

        for settingName in pairs ( player ) do
            if saveSettings[settingName] == nil then
                saveSettings[settingName] = player[settingName];
            end
            
        end

        for settingName in pairs ( saveSettings ) do

            if player[settingName] == nil then
                saveSettings[settingName] = nil
            end
            
        end

        return saveSettings
    end

    
    if GRM_G.guildName ~= "" and GRM_G.guildName ~= nil and GRM_AddonSettings_Save[GRM_G.guildName] then
        GRM_AddonSettings_Save[GRM_G.guildName] = Validate ( GRM_AddonSettings_Save[GRM_G.guildName] );
    end

    if GRM_AddonSettings_Save[GRM_G.addonUser] ~= nil then
        GRM_AddonSettings_Save[GRM_G.addonUser] = Validate ( GRM_AddonSettings_Save[GRM_G.addonUser] );
    end

end

-------------------------------------
-------- BUILD COMPATIBILITY --------
-------------------------------------

-- ALL these functions are to deal with possibility of Retail and Classic backend APIs no longer being sync'd the same. When 9.0 launched October 2020 the underlying API was changed for many things, but Classic did not receive those updates. It is assumed those will eventually be made the same again in future updates for Classic. By Wrapping them in a GRM function it can be easy to control by just needing to update them here rather than addon-wide.

GRM.CanViewOfficerNote = function()
    if C_GuildInfo.CanViewOfficerNote then
        return C_GuildInfo.CanViewOfficerNote();
    else
        return CanViewOfficerNote();
    end
end

GRM.CanEditOfficerNote = function()
    if C_GuildInfo.CanEditOfficerNote then
        return C_GuildInfo.CanEditOfficerNote();
    else
        return CanEditOfficerNote();
    end
end

-- An assumption they will update this API to the namespace C_GuildInfo
GRM.CanEditPublicNote = function()
    if C_GuildInfo.CanEditPublicNote then
        return C_GuildInfo.CanEditPublicNote();
    else
        return CanEditPublicNote();
    end
end

GRM.GuildRoster = function()
    if C_GuildInfo.GuildRoster then
        if GRM_G.BuildVersion >= 100100 or GRM_G.BuildVersion < 100000 then -- Launch error for 10.0 caused frame to refresh and mess up sorting
            C_GuildInfo.GuildRoster();
            
        end
    else
        GuildRoster();
    end
end

GRM.GetTodaysDate = function()
    local calendarTime;

    if C_DateAndTime.GetCurrentCalendarTime then
        -- RETAIL
        calendarTime = C_DateAndTime.GetCurrentCalendarTime();
        return calendarTime.weekday, calendarTime.month, calendarTime.monthDay, calendarTime.year , calendarTime.hour , calendarTime.minute;
    else
        -- CLASSIC
        calendarTime = C_DateAndTime.GetTodaysDate();
        return calendarTime.weekDay, calendarTime.month, calendarTime.day, calendarTime.year;
    end
end

GRM.GetCurrentCalendarTime = function()
    if C_DateAndTime.GetCurrentCalendarTime then
        return C_DateAndTime.GetCurrentCalendarTime();
    else
        return C_DateAndTime.GetTodaysDate();
    end
end

---------------------------------------
--- REPURPOSED API --------------------
---------------------------------------

-- Method:          GRM.GetClassName ( string )
-- What it Does:    Returns the localized class name using the NON-localized classname -- "DEATHKNIGHT" input: "Death Knight" output - if in English
-- Purpose:         Single function to get localized class names
GRM.GetClassName = function ( className )
    return C_CreatureInfo.GetClassInfo ( GRM_G.classFileIDEnum[ className ] ).className
end

---------------------------------------
----- END OF BUILD COMPAT... ----------
---------------------------------------

-- Method:          SetClassChatColoring()
-- What it Does:    Initializes chat coloring controls for classic
-- Purpose:         Quality of life control
GRM.SetClassChatColoring = function()
    if GRM_G.BuildVersion < 40000 then
        local num = "1";
        
        if GRM.S() and not GRM.S().colorizeClassicRosterNames then
            num = "1";
            if GetCVar ( "chatClassColorOverride" ) == "2" then -- Integers are in string format from server for some reason.
                num = "2";
            end
        end

        SetCVar("chatClassColorOverride" , num );

        hooksecurefunc ( "GuildStatus_Update" , function()
            local button;
            if IsInGuild() and GuildFrame and GuildFrame:IsVisible() then
                for i = 1 , 13 do

                    if GuildStatusFrame and GuildStatusFrame:IsVisible() then
                        button = _G["GuildFrameGuildStatusButton" .. i];
                        if button and button:IsVisible() then
                            GRM.RecolorText( button );
                        end
                    elseif GuildPlayerStatusFrame and GuildPlayerStatusFrame:IsVisible() then
                        button = _G["GuildFrameButton" .. i];
                        if button and button:IsVisible() then
                            GRM.RecolorText( button );
                        end
                    end
                end
            end
        end);

    end
end

-- Method:          GRM.SetChatClassColoringInWrath ( bool )
-- What it Does:    Enables or Disables chat class coloring
-- Purpose:         Enable chat coloring controls in wrath
GRM.SetChatClassColoringInWrath = function ( enable )
    local list = { "SAY" , "EMOTE" , "YELL" , "GUILD" , "GUILD_OFFICER" , "OFFICER" , "GUILD_ACHIEVEMENT" , "ACHIEVEMENT" , "WHISPER" , "PARTY" , "PARTY_LEADER" , "RAID" , "RAID_LEADER" , "RAID_WARNING" , "INSTANCE_CHAT" , "INSTANCE_CHAT_LEADER" , "CHANNEL1" , "CHANNEL2" , "CHANNEL3" , "CHANNEL4" , "CHANNEL5"};

    for i = 1 , #list do
        ToggleChatColorNamesByClassGroup ( enable, list[i] );
    end

end

-- Method:          GRM.SetChatClassColoringNew ( bool )
-- What it Does:    Enables or Disables class coloring in chat channels
-- Purpose:         Allows classic players to see class coloring in chat
GRM.SetChatClassColoringNew = function ( enable )
    local channelList = {GetChannelList()};

    for channel in pairs ( ChatTypeGroup ) do
        SetChatColorNameByClass ( channel , enable );
    end

    for i = 1 , #channelList , 3 do
        SetChatColorNameByClass ( "CHANNEL" .. channelList[i] , enable );
    end

end

-- Method:          GRM.SetChatColoring()
-- What it Does:    Initializes the chat coloring of names
-- Purpose:         To give the ability to colorize the names in chat and the roster on control - as the default interface in Classic did not have that.
GRM.SetChatColoring = function()
    if GRM.S() and GRM.S().colorizeClassicRosterNames then
        GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_UXOptionsFrame.GRM_ColorizePlayerNamesButton:SetChecked ( true );
        if GRM_G.BuildVersion < 40000 then
            SetCVar("chatClassColorOverride" , 0 );
            if GRM_G.BuildVersion >= 30000 then
                GRM.SetChatClassColoringInWrath ( true );
            else
                GRM.SetChatClassColoringNew ( true );
            end
        end
    else
        if GRM_G.BuildVersion < 40000 then
            SetCVar("chatClassColorOverride" , 1 );
            if GRM_G.BuildVersion >= 30000 then
                GRM.SetChatClassColoringInWrath ( false );
            else
                GRM.SetChatClassColoringNew ( false );
            end
        end
    end
end


-- method:          GRM.RefreshNumberOfHoursTilRecommend()
-- What it Does:    Rebuilds the time on the recommends for the macro tool and the log.
-- Purpose:         Resource saving. No need to process over and over everytime it is looked at unless a change is made.
GRM.RefreshNumberOfHoursTilRecommend = function()
    if GRM.S() then
        GRM_G.NumberOfHoursTilRecommend["kick"] = {};
        GRM_G.NumberOfHoursTilRecommend["kickActive"] = {};

        GRM_G.NumberOfHoursTilRecommend["promote"] = {};
        GRM_G.NumberOfHoursTilRecommend["demote"] = {};

        local validateFormat = function ( exactRule , defaultMonths )
            
            if type ( exactRule.numDaysOrMonths ) ~= "number" then
                exactRule.numDaysOrMonths = 12;
                exactRule.isMonths = true;
            end

            if not exactRule.rankSpecialNumDaysOrMonths then
                exactRule.rankSpecialNumDaysOrMonths = defaultMonths;
            end

            return exactRule;
        end

        for ruleName , rule in pairs ( GRM.S().kickRules ) do
            
            if rule.activityFilter then                                               -- Only need to add if this part is enabled.
                GRM_G.NumberOfHoursTilRecommend["kick"][ruleName] = 0;

                rule = validateFormat ( rule , 12 );

                if rule.isMonths then
                    GRM_G.NumberOfHoursTilRecommend["kick"][ruleName] = GRM.GetNumHoursTilRecommend ( rule.numDaysOrMonths );
                else
                    GRM_G.NumberOfHoursTilRecommend["kick"][ruleName] = ( rule.numDaysOrMonths * 24 );
                end
            end
            if rule.applyEvenIfActiive then
                GRM_G.NumberOfHoursTilRecommend["kickActive"][ruleName] = 0;
                if rule.rankSpecialIsMonths then
                    GRM_G.NumberOfHoursTilRecommend["kickActive"][ruleName] = GRM.GetNumHoursTilRecommend ( rule.rankSpecialNumDaysOrMonths );
                else
                    GRM_G.NumberOfHoursTilRecommend["kickActive"][ruleName] = ( rule.rankSpecialNumDaysOrMonths * 24 );
                end
            end
        end

        for ruleName , rule in pairs ( GRM.S().promoteRules ) do
            if rule.activityFilter then                                               -- Only need to add if this part is enabled.
                GRM_G.NumberOfHoursTilRecommend["promote"][ruleName] = {};
                GRM_G.NumberOfHoursTilRecommend["promote"][ruleName].hours = 0;

                rule = validateFormat ( rule , 3 );

                if rule.isMonths then
                    GRM_G.NumberOfHoursTilRecommend["promote"][ruleName].hours = GRM.GetNumHoursTilRecommend ( rule.numDaysOrMonths );
                else
                    GRM_G.NumberOfHoursTilRecommend["promote"][ruleName].hours = ( rule.numDaysOrMonths * 24 );
                end

                if not rule.regardlessOfActivity then
                    GRM_G.NumberOfHoursTilRecommend["promote"][ruleName].inactive = 0;
                    if rule.rankSpecialIsMonths then
                        GRM_G.NumberOfHoursTilRecommend["promote"][ruleName].inactive = GRM.GetNumHoursTilRecommend ( rule.rankSpecialNumDaysOrMonths );
                    else
                        GRM_G.NumberOfHoursTilRecommend["promote"][ruleName].inactive = ( rule.rankSpecialNumDaysOrMonths * 24 );
                    end
                end

            end
        end

        for ruleName , rule in pairs ( GRM.S().demoteRules ) do
            if rule.activityFilter then                                               -- Only need to add if this part is enabled.
                GRM_G.NumberOfHoursTilRecommend["demote"][ruleName] = {};
                GRM_G.NumberOfHoursTilRecommend["demote"][ruleName].hours = 0;

                rule = validateFormat ( rule );

                if rule.isMonths then
                    GRM_G.NumberOfHoursTilRecommend["demote"][ruleName].hours = GRM.GetNumHoursTilRecommend ( rule.numDaysOrMonths );
                else
                    GRM_G.NumberOfHoursTilRecommend["demote"][ruleName].hours = ( rule.numDaysOrMonths * 24 );
                end

                if not rule.regardlessOfActivity then
                    GRM_G.NumberOfHoursTilRecommend["demote"][ruleName].evenIfActiveHours = 0;
                    if rule.rankSpecialIsMonths then
                        GRM_G.NumberOfHoursTilRecommend["demote"][ruleName].evenIfActiveHours = GRM.GetNumHoursTilRecommend ( rule.rankSpecialNumDaysOrMonths );
                    else
                        GRM_G.NumberOfHoursTilRecommend["demote"][ruleName].evenIfActiveHours = ( rule.rankSpecialNumDaysOrMonths * 24 );
                    end
                end

            end
        end
    end
end

-- Method:          GRM.GetPageIndex()
-- What it Does:    Returns the index number to the corresponding frame
-- Purpose:         To coordinate in resetting default settings based on the specific frame the player is on.
GRM.GetPageIndex = function()
    local allFrames = { [ GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame ] = 1  , [ GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_ScanningOptionsFrame ] = 2  , [ GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_SyncOptionsFrame ] = 3  , [ GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_OfficerOptionsFrame ] = 4  , [ GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_UXOptionsFrame ] = 7 , [ GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_LogExtraOptionsFrame ] = 8  , [GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_ModulesFrame] = 15  , [GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_HardcoreFrame] = 16 };
    local result;

    for x , y in pairs ( allFrames ) do
        if x:IsVisible() then
            result = y;
        end
    end
    return result;
end

-- Method:          GRM.ResetDefaultSettings( int )
-- What it Does:    Resets the OPTIONS to the default one for only the currently logged in player
-- Purpose:         Easy, quality of life for user in the options, for simple reset.
GRM.ResetDefaultSettings = function( pageIndex )
    local page = pageIndex or GRM.GetPageIndex();
    local needsRefresh = false;
    local resetAll = false;

    if IsShiftKeyDown() and IsControlKeyDown() then
        needsRefresh = true;
        resetAll = true;

        -- resetting ALL player data.
        local settings = GRM.S();
        for i = 0 , GRM_G.SettingsPages do
            GRM.SetDefaultAddonSettings ( settings , i );
        end

    elseif page then

        needsRefresh = true;
        -- Reset only specific settings
        local settings = GRM.S();
        GRM.SetDefaultAddonSettings ( settings , page );

        if page == 10 then
            GRM.RefreshNumberOfHoursTilRecommend();
        end

    end

    if needsRefresh then
        if ( resetAll or page == 1 ) and GRM_UI.GRM_RosterChangeLogFrame:IsVisible() then
            GRML.SetNewLanguage( GRM_G.LocalizedIndex , false , true );
        end

        -- Check Permissions
        GRM.UpdateGuildLeaderPermissions ( false , true );

        -- Reset frames as needed
        if ( resetAll or page < 9 ) and GRM_UI.GRM_RosterChangeLogFrame:IsVisible() then     -- General options
            GRM_UI.BuildLogFrames();
        end

        if page == 15 then
            GRM_UI.ConfigureGroupInfoRules();
        end

        -- refresh the log as settings might be changed.
        if ( resetAll or page == 8 ) and GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame:IsVisible() then
            GRM_UI.RefreshLogExtraOptions();
            GRM_UI.RefreshLogColorOptions();
            GRM.ResetLogStringPoints ( true );
            GRM.BuildLogComplete( true , false );
        end

        if ( resetAll or page == 9 ) and GRM_UI.GRM_ExportLogBorderFrame:IsVisible() then
            GRM_UI.SetExportTabHighlights();
        end

        if ( resetAll or ( ( page > 9 and page < 13 ) ) or page == 14 ) and GRM_UI.GRM_ToolCoreFrame:IsVisible() then
            GRM_UI.RefreshManagementTool( GRM_G.KickAltControl );
        end

        if resetAll then
            GRM_UI.ResetScalingForAll();
        end

        if not ( LibStub and LibStub("LibDataBroker-1.1", true ) and LibStub("LibDBIcon-1.0", true) ) then
            GRM_UI.GRM_MinimapButtonInit();
        end

        GRM_UI.CorePositionInit();
        GRM_UI.CoreToolPositionInit();
        GRM.RefreshMainTagHexCode();
        GRM.SetReportWindow();
        GRM.RefreshNumberOfHoursTilRecommend();
    end

end

-----------------------------
--- Addon to Addon Comms ----
---- pattern matching -------
-----------------------------

-- Method:          GRM.BuildComPattern ( int , string , int )
-- What it Does:    Returns a string pattern to match for addon to addon comm parsing
-- Purpose:         to easily build and create patterns as needed for comms.
GRM.BuildComPattern = function( numItems , delimiter , delimiterIsOnEnd )
    local result = "";

    for i = 1 , numItems do
        if i < numItems then
            result = result .. "(.+)" .. delimiter;
        else
            if delimiterIsOnEnd then
                result = result .. "(.+)" .. delimiter;
            else
                result = result .. "(.+)";
            end
        end
    end

    return result;
end

-- Method:          GRM.ParseComMsg ( msg )
-- What it Does:    Returns the matches to the given pattern
-- Purpose:         More easily manage comm messages cleaner.
GRM.ParseComMsg = function ( msg , pattern )
    return string.match ( msg , pattern );
end

-----------------------------------
--- All the rest of the methods ---
-----------------------------------

-- Method:          GRM.TableLength ( table )
-- What it Does:    Returns the integer count of how many items in the given list
-- Purpose:         Since Lua does not provide a simple count on tables, this is a reusable tool
GRM.TableLength = function ( list )
    local count = 0;

    for _ in pairs ( list ) do
        count = count + 1;
    end

    return count;
end

-- Method:          GRM.IsMouseOverAnyChatWindowIncludingCommunities()
-- What it Does:    Reports back if player has the cursor over a given guild window
-- Purpose:         Since there is no right-click trigger, this detects the popup window use, and it will only pin the window properly *IF* it is the appropriate time due to the reusability of this window by Warcraft
GRM.IsMouseOverAnyChatWindowIncludingCommunities = function()
    local result = false;
    local name = "";
    local server = "";

    for i = 1 , #CHAT_FRAMES do
        if GetClickFrame ( CHAT_FRAMES[i] ):IsMouseOver() then
            result = true;
            name = GRM.AppendServerName ( DropDownList1.dropdown.chatTarget );
            break;
        end
    end

    if not result then
        GetPlayerInfoByGUID(UnitGUID("PLAYER"))
        if ( GRM_G.BuildVersion >= 80000 and CommunitiesFrame and CommunitiesFrame:IsVisible() and CommunitiesFrame:IsMouseOver() and GRM_G.gClubID == C_Club.GetGuildClubId() ) then
        
            if DropDownList1.dropdown.guid ~= nil then
                name , server = select ( 6 , GetPlayerInfoByGUID ( DropDownList1.dropdown.guid ) );
                if name == nil or name == "" then
                    name , server = select ( 6 , GetPlayerInfoByGUID ( DropDownList1.dropdown.guid ) ); -- Try again. Sometimes GUID takes 2 tries as the first just initializes the server to provide info on next call
                end

                if name ~= nil and name ~= "" then
                    if server == "" then
                        name = name .. "-" .. GRM_G.realmName;
                    else
                        name = name .. "-" .. server;
                    end
                end
                result = true;
            end
            
        elseif GRM_UI.GuildRosterFrame and GRM_UI.GuildRosterFrame:IsVisible() and GRM_UI.GuildRosterFrame:IsMouseOver() then
            if DropDownList1.dropdown.guid ~= nil then
                name = DropDownList1.dropdown.name .. "-" .. DropDownList1.dropdown.server;
                result = true;
            end
        end
        
    end
    
    return result , name;
end

-- Method:          GRM.SetReportWindow ()
-- What it Does:    Sets the addon reporting to a specified custom channel
-- Purpose:         Allow flexibility to send GRM reports to a custom channel so you don't miss anything.
GRM.SetReportWindow = function( count )
    local isEstablished = false;
    local chatFrame;
    count = count or 1;

    if GRM.S() == nil then
        GRM_G.Chat = { DEFAULT_CHAT_FRAME };
        return;
    end

    for i = #GRM.S().reportChannel , 1 , -1 do
        isEstablished = false;

        for j = 1 , #CHAT_FRAMES do
            chatFrame = _G[ CHAT_FRAMES[j] ];

            if chatFrame ~= nil and chatFrame.name == GRM.S().reportChannel[i] then
                -- Custom frame writte, custom frame found! Now, let's see if there is a tab

                if _G[ CHAT_FRAMES[j] .."Tab" ]:IsVisible() then
                    isEstablished = true;
                    
                    GRM.AddReportChannel ( nil , chatFrame , true );        -- Just adds it to the GRM_G.Chat
                    break;
                end

            end
        end

        if not isEstablished then
            if count < 5 then
                C_Timer.After ( 2 , function()
                    count = count + 1;
                    GRM.SetReportWindow ( count );      -- Some redundancy before I go and start removing channels.
                    return;
                end);
            else
                table.remove ( GRM.S().reportChannel , i );
            end
        end
    end

    if #GRM.S().reportChannel == 0 then
        GRM_G.Chat = { DEFAULT_CHAT_FRAME };
    end
end

-- Method:          GRM.SetJoinAndRejoinTags()
-- What it Does:    Configures the join and rejoin tag to be either the default tag, or to be the custom.
-- Purpose:         Increased flexibility for the player in terms of visual controls.
GRM.SetJoinAndRejoinTags = function()
    -- Eventually to be modified to allow a custom header configuration. For now just these defaults
    if GRM.S().customTags[1] == "" then
        GRM_G.customHeaderJoin = GRM.L ( "Joined:" );
    else
        GRM_G.customHeaderJoin = GRM.S().customTags[1];
    end

    if GRM.S().customTags[2] == "" then
        GRM_G.customHeaderRejoin = GRM.L ( "Rejoined:" );
    else
        GRM_G.customHeaderRejoin = GRM.S().customTags[2];
    end
end

-- Method:          GRM.AddReportChannel ( string , object , bool )
-- What it Does:    Adds the custom channel to the saved data so it can be stored on each subsequent session
-- Purpose:         Quality of Life control to user to report info to more than 1 window.
GRM.AddReportChannel = function ( name , newFrame , onlyFrame )
    local isFound = false;

    if not onlyFrame then
        for i = 1 , #GRM.S().reportChannel do
            if GRM.S().reportChannel[i] == name then
                isFound = true;
                break;
            end
        end

        if not isFound then
            table.insert ( GRM.S().reportChannel , name );
        end

        isFound = false;
    end

    for i = 1 , #GRM_G.Chat do
        if GRM_G.Chat[i] == newFrame then
            isFound = true;
            break;
        end
    end

    if not isFound then
        table.insert ( GRM_G.Chat , newFrame );
    end
end

-- Method:          GRM.CreateChatTabs()
-- What it Does:    Using the created listed of channels in the General Options, it creates the tabs if they do not exist in a Que, with a confirmation box
-- Purpose:         UX quality control
GRM.CreateChatTabs = function()
    local customName = GRM_G.UnconfirmedChatTabs[1];
    -- Core Blizzard logic to create a new window
    local frame = FCF_OpenNewWindow ( customName );

    -- Now we configure them
    FCF_CopyChatSettings ( frame , DEFAULT_CHAT_FRAME );
    FCF_DockUpdate();

    -- GRM actions - Add the names and set the reporting logic to GRM database
    GRM.AddReportChannel ( customName , frame , false );

    -- Update the options editbox
    GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_ReportDestinationEditBox:SetText( GRM.BuildMultiChannelString() );
    
    -- Helpful message to players
    if #GRM.S().reportChannel == 1 and #GRM_G.UnconfirmedChatTabs == 1 then
        GRM.Report ( GRM.L ( "GRM will automatically send messages to the \"{name}\" window if you close this one." , DEFAULT_CHAT_FRAME.name ) );
    elseif #GRM.S().reportChannel > 1 then
        GRM.Report ( GRM.L ( "GRM will automatically send messages to the \"{name}\" window if you remove all custom channels." , DEFAULT_CHAT_FRAME.name ) );
    end

    -- Close the window...
    GRM_UI.GRM_RosterConfirmFrame:Hide();

    table.remove ( GRM_G.UnconfirmedChatTabs , 1 );

    -- recursively repeat this as needed
    if #GRM_G.UnconfirmedChatTabs > 0 then
        GRM.InitiateConfirmFrame ( GRM.L ( "\"{name}\" Chat Window\nDo you wish to create it?" , GRM_G.UnconfirmedChatTabs[1] ) , GRM.CreateChatTabs , nil , nil , GRM.CancelChatTabCreation , true );
    end
end

-- Method:          GRM.CancelChatTabCreation()
-- What it Does:    Cancels this action, and removes the channel tab name
-- Purpose:         UX quality control
GRM.CancelChatTabCreation = function()
    if #GRM.S().reportChannel == 0 then
        GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_ReportDestinationEditBox:SetText ( DEFAULT_CHAT_FRAME.name );
    else
        GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_ReportDestinationEditBox:SetText ( GRM.BuildMultiChannelString() );
    end
    table.remove ( GRM_G.UnconfirmedChatTabs , 1 );
    if #GRM_G.UnconfirmedChatTabs > 0 then
        GRM.InitiateConfirmFrame ( GRM.L ( "\"{name}\" Chat Window\nDo you wish to create it?" , GRM_G.UnconfirmedChatTabs[1] ) , GRM.CreateChatTabs , nil , nil , GRM.CancelChatTabCreation , true );
    end
end

-- Method:          GRM.EstablishNewCustomReportWindow();
-- What it Does:    Takes a new custom one and determines if there is a window, and if there is no window asks the player if they wish to create a GRM channel\
-- Purpose:         Quality of Life feature for creating custom Window to send reports to.
GRM.EstablishNewCustomReportWindow = function( channelNames )
    local isEstablished = false;
    local chatFrame;
    local channels = GRM.ParseMultiChannelString ( channelNames );
    GRM_G.UnconfirmedChatTabs = {};

    -- No need to do the work if it is already set to default
    if #channels > 0 then
        -- Let's Confirm the frames

        for i = 1 , #channels do
            isEstablished = false;
            for j = 1 , #CHAT_FRAMES do
                chatFrame = GetClickFrame ( CHAT_FRAMES[j] );

                if chatFrame and chatFrame.name == channels[i] then
                    -- Custom frame writte, custom frame found! Now, let's see if there is a tab

                    if GetClickFrame ( chatFrame:GetName() .. "Tab" ):IsVisible() then
                        isEstablished = true;
                        GRM.AddReportChannel ( channels[i] , chatFrame , false );
                        break;
                    end

                end
            end

            if not isEstablished then
                table.insert ( GRM_G.UnconfirmedChatTabs , channels[i] );   -- These are custom chat tabs that don't exist yet and need to be built. Storing them so they can be qued up.
            end
        end

        if #GRM_G.UnconfirmedChatTabs > 0 then
            -- Popup window logic...
            GRM.InitiateConfirmFrame ( GRM.L ( "\"{name}\" Chat Window\nDo you wish to create it?" , GRM_G.UnconfirmedChatTabs[1]  ) , GRM.CreateChatTabs , nil , nil , GRM.CancelChatTabCreation , true );
        end
    else
        GRM.S().reportChannel = {};
        GRM_G.Chat = { DEFAULT_CHAT_FRAME };
    end

    GRM.CleanupUnusedChannels( channels );
end

-- Method:          GRM.CleanupUnusedChannels()
-- What it Does:    Checks if the channel is still one listed. If not, removes it
-- Purpose:         Quality control for the use of custom channels. Ensures cleanup when channels removed.
GRM.CleanupUnusedChannels = function( channels )
    local isEstablished;

    -- Remove ones not in the Channel List
    for i = #GRM.S().reportChannel , 1 , -1 do
        isEstablished = false;

        for j = 1 , #channels do
            if channels[j] == GRM.S().reportChannel[i] then
                isEstablished = true;
                break;
            end            
        end

        if not isEstablished then
            table.remove ( GRM.S().reportChannel , i );
        end
    end

    for i = #GRM_G.Chat , 1 , -1 do
        isEstablished = false;

        for j = 1 , #GRM.S().reportChannel do
            if GRM_G.Chat[i].name == GRM.S().reportChannel[j] then
                isEstablished = true;
                break;
            end
        end
    
        if not isEstablished then
            table.remove ( GRM_G.Chat , i );
        end
    end
end

-- Method:          GRM.IsValidChannelName ( string )
-- What it Does:    Determines the number of characters, not byte string lenght, as that is not accurate, and returns true if it is 31 characters or less. Numbers within channel names IS compatible.
-- Purpose:         So the player who is inputing channel names can determine if his are valid.
GRM.IsValidChannelName = function ( name )
    local result = true;

    if GRM.UTF8Len ( name ) > 31 then       -- Length of Max Characters is 31
        result = false;
    end

    return result
end

-- Method:          GRM.ParseMultiChannelString ( string )
-- What it Does:    Takes the string delimited by commas and parsed all the words into a table
-- Purpose:         Particularly for managing multiple channels to send info to
GRM.ParseMultiChannelString = function ( channels )

    channels = GRM.Trim ( channels );
    local result = {};
    local ind = string.find ( channels , "," , 1 , true );
    local tableName = "";
    
    if #channels > 0 then

        while ind ~= nil and #channels > 0 do

            tableName = GRM.Trim ( string.sub ( channels , 1 , ind - 1 ) );

            -- Is Valid Name?
            if GRM.IsValidChannelName ( tableName ) then
                table.insert ( result , tableName );
            end

            channels = string.sub ( channels , ind + 1 );
            ind = string.find ( channels , "," , 1 , true );

            -- No comma on the end
            if ind == nil and #channels > 0 then
               tableName = GRM.Trim ( channels );

               -- Is Valid Name?
               if GRM.IsValidChannelName ( tableName ) then
                    table.insert ( result , tableName );
                end

            end

        end

        if #result == 0 and ind == nil then
            table.insert ( result , GRM.Trim ( channels ) );
        end

    end

    return result;
end

-- Method:          GRM.BuildMultiChannelString()
-- What it Does:    Builds a string with comma delimiters of all the channel names
-- Purpose:         Give the player the option to send messages to multiple channels
GRM.BuildMultiChannelString = function()
    local result = "";

    if #GRM.S().reportChannel == 0 then
        result = DEFAULT_CHAT_FRAME.name
    else
        
        for i = 1 , #GRM.S().reportChannel do
            if i == 1 then
                result = GRM.S().reportChannel[i];
            else
                result = result .. "," .. GRM.S().reportChannel[i];
            end
        end
    end

    return result;
end

-- Method:          GRM.SlimName(string)
-- What it Does:    Removes the server name after character name.
-- Purpose:         Server name is not important in a guild of the same server since all will be server name.
GRM.SlimName = function( name )
    if name ~= nil then
        if string.find ( name , "-" ) then
            return string.gsub ( name ,"%-.+" , "" );
        else
            return name;
        end
    else
        return "";
    end
end

-- Method:          GRM.FormatName ( string )
-- What it Does:    For purposes of standardizing the name formatting, this removes the server appending ONLY if same realm and the player does not have them permanently enabled.
-- Purpose:         Customizing how the name appears in log and elsewhere.
GRM.FormatName = function ( name )

    if name then
        if not GRM.S().useFullName then
            if string.find ( name , "-" ) then
                name = string.gsub ( name ,"%-.+" , "" );
            end
        end
    else
        name = "";
    end

    return name;
end

-- Method:          GRM.Use24HrBasedOnDefaultLanguage()
-- What it Does:    Establishes if the language uses the 24hr timestamp
-- Purpose:         On configuring a new toon, it is useful to know what timestamp format is commonly used 24hr or 12hr
GRM.Use24HrBasedOnDefaultLanguage = function()
    local result = true;
    if GRM_G.LocalizedIndex == 1 or GRM_G.LocalizedIndex == 6 then
        result = false;
    end
    return result;
end

-- Method:          GRM.GetMatureFilterNormalizedString ( int )
-- What it Does:    Returns a string with the number of special characters for mature language filter normalization
-- Purpose:         Blizz seems to have a rolling string of special characters that can be inconsistent on how it censors the curse/mature words, and so string compare 
--                  can be inconsistently comparing to different variations of special characters on server calls. This resolves that by normalizing curse word representation to the 
--                  addon and all 5 letter words will be same string, and all 4 letter words will be same string and so on.
GRM.GetMatureFilterNormalizedString = function ( numChars )
    local matureFilterTable = { "$" , "%" , "^" , "&" , "*" , "!" , "@" , "#" };
    local result = "";

    while #result < numChars do
        for i = 1 , #matureFilterTable do
            result = result .. matureFilterTable[i]; -- Add the chair and build the string...
            if #result >= numChars then              -- It is the correct size now, let's break it.
                break;
            end
        end
    end

    return result;
end

-- Method:          GRM.NormalizeMatureWords ( string )
-- What it Does:    Searches a string for Blizz's implementation of various curse word censoring and then overwrites it with a normalized curseword string
-- Purpose:         For comparing strings properly as the curse word censoring with the "Mature Langue Filter" is inconsistent from the server...
GRM.NormalizeMatureWords = function ( text )
    local matureFilterTable = { "$" , "%" , "^" , "&" , "*" , "!" , "@" , "#" };
    local index = 1;
    local count = 1;            -- Count must make it to 3 or else we break
        
    while index <= #text do
        local restart = false;
        for i = index , #text do                        -- No need to parse the final 2 as curse word must be 3 letters +
            local char = string.sub ( text , i , i );       -- Parse out the char to compare to match...
            for j = 1 , #matureFilterTable do
                if char == matureFilterTable[j] then
                    -- POTENTIAL MATCH
                    -- So far, one letter is matching! Let us determine where the next matching letter as well (word must be at least 3 letters, up to 8)
                    count = 1;
                    for r = i + 1 , #text do
                        local isMatch = false;      -- There MUST be a match or we break this and then compare to count... if it is greater than or equal to 3, then we have a curse word
                        local char2 = string.sub ( text , r , r );       -- Parse out the char to compare to match...
                        for s = 1 , #matureFilterTable do
                            if char2 == matureFilterTable[s] then
                                isMatch = true;
                                count = count + 1;
                                break;
                            end
                        end
                        if not isMatch or r == #text then
                            restart = true;
                            if count >= 3 then
                                -- MATCH FOUND!!! CURSE WORD IDENTIFIED!!!
                                text = ( string.sub ( text , 1 , i - 1 ) .. GRM.GetMatureFilterNormalizedString ( count ) .. string.sub ( text , i + count ) );
                            end
                            break;
                        end
                    end
                    break;
                end
            end
            index = index + 1;
            -- Let's break the loop and pickup where we leftoff...
            if restart then
                index = i + count;      -- We might jump a few characters here...
                break;
            end
        end
    end
    return text;
end

--------------------------------------
------ LOCALIZATION LOGIC ------------
--------------------------------------

-- Method:          GRM.L ( string , string , int (or casted int to string) , string , string )
-- What it Does:    Returns the localized string based on the hash table using the key, or the key itself if the value is set to true (meaning no localization necessary or does not exist yet)
-- Purpose:         For ease of localization so people from any region can enjoy the addon in their native tongue!!!
GRM.L = function ( key , playerName , playerName2 , num , custom1 , custom2 )
    if key ~= nil and GRM_L[key] ~= nil then
        if GRM_L[key] == true then      -- If true it has not been localized, or it is English client
            if playerName then          -- It is not nil
                key = string.gsub ( key , "{name}" , playerName );    -- insert playerName where needed - this is because in localization, for example "Arkaan's bday" in Spanish would have name at end of statement
            end
            if playerName2 then          -- It is not nil
                key = string.gsub ( key , "{name2}" , playerName2 );    -- insert playerName where needed - this is because in localization, for example "Arkaan's bday" in Spanish would have name at end of statement
            end
            if num then
                key = string.gsub ( key , "{num}" , num );
            end
            if custom1 then
                key = string.gsub ( key , "{custom1}" , custom1 );
            end
            if custom2 then
                key = string.gsub ( key , "{custom2}" , custom2 );
            end
            return key;
        else
            local result = GRM_L[key];
            if playerName then          -- It is not nil
                result = string.gsub ( result , "{name}" , playerName );    -- insert playerName where needed - this is because in localization, for example "Arkaan's bday" in Spanish would have name at end of statement
            end
            if playerName2 then          -- It is not nil
                result = string.gsub ( result , "{name2}" , playerName2 );    -- insert playerName where needed - this is because in localization, for example "Arkaan's bday" in Spanish would have name at end of statement
            end
            if num then
                result = string.gsub ( result , "{num}" , num );
            end
            if custom1 then
                result = string.gsub ( result , "{custom1}" , custom1 );
            end
            if custom2 then
                result = string.gsub ( result , "{custom2}" , custom2 );
            end
            return result
        end
    else
        if key ~= nil then
            if not GRM_G.Region == "koKR" or key ~= "SYNC USERS" then
                if key ~= "" then
                    if key == "nil" then
                        error ( "Localization key is nil... Please report the error to Addon Dev" )
                    else
                        GRM.Report ( GRM.L ( "GRM WARNING!!! FAILURE TO LOAD THIS KEY: {name}\nPLEASE REPORT TO ADDON DEV! THANK YOU!" , key ) );  -- for debugging purposes.
                    end
                end
            end
        else
            error ( "Localization Key is nil" );
        end
        return key;
    end
end

-- Method:          GRM.OrigL ( string )
-- What it Does:    Takes a hash result and returns the key. It's essentially a dictionary lookup in reverse
-- Purpose:         Some of the code needs to be localized only on the front end, but the backend code is based on some English variables
--                  This allows the localized data to be presented to the user, but on the backend to cycle back to the hash key for parse analysis.
GRM.OrigL = function ( localizedString )
    local result = localizedString;
    -- if it is not nil, then we know we already have the OrigL
    if GRM_L[localizedString] == nil then
        for key , y in pairs ( GRM_L ) do
            if y == localizedString then
                result = key;
                break;
            end
        end
    end
    return result;
end

-- Method:          GRM.NormalizeHitRects ( button , fontstring , int , bool )
-- What it Does:    It ensures that no matter what the localization/translation, the hitRects mnatch up to the text length perfectly
-- Purpose:         Quality of life 
GRM.NormalizeHitRects = function ( checkButton , checkButtonFontstring , modifier , reverse )
    local n = modifier or 0;

    if not reverse then
        checkButton:SetHitRectInsets ( 0 , n - checkButtonFontstring:GetWidth() - 2 , 0 , 0 );
    else
        checkButton:SetHitRectInsets ( n - checkButtonFontstring:GetWidth() + 2 , 0 , 0 , 0 );
    end
end


-- Method:          GRM.Round ( float , int )
-- What it Does:    Returns a given number with the given number of requested decimals places.
-- Purpose:         Clean reporting and aesthetics...
GRM.Round = function ( num , numDecimals )
    local modifier = 10 ^ ( numDecimals or 0 );
    return math.floor ( num * modifier + 0.5 ) / modifier;
end

-- Method:          GRM.Random ( int , int )
-- What it Does:    Returns a random number with millisecond precision
-- Purpose:         Default built-in random number generator not precise enough.
GRM.Random = function ( lower , upper )
    return GRM.Round ( lower + ( upper * math.random() ) , 2 );
end

-- Method:          GRM.DeepCopyArray(array)
-- What it Does:    Makes a Deep copy, including all children, recursively, so as to create a new memory reference of the array
-- Purpose:         In Lua, you cannot just copy a table. It copies the reference and changes made to new table and references the memory to being the same, even if they have different variable names
--                  So, to truly create a unique reference to an array, so if you edit one it doesn't edit both, you need to do a true copy. This basically creates a new empty array and imports each value
--                  to the table. Backups would not be possible without this code right here.
GRM.DeepCopyArray = function( tableToCopy )
    local copy;
    if type ( tableToCopy ) == 'table' then
        copy = {};
        for orig_key , orig_value in next , tableToCopy , nil do
            copy [ GRM.DeepCopyArray ( orig_key ) ] = GRM.DeepCopyArray ( orig_value );     -- This recursive action is essentially taking every multi-D array value and it keeps digging til it builds every layer of multi-dimensional array
        end
        setmetatable ( copy , GRM.DeepCopyArray ( getmetatable ( tableToCopy ) ) );
    else
        copy = tableToCopy;         -- Imported data was not a table... just return orig. value - error protection
    end
    return copy;
end

-- Method:          GRM.ConvertTableToArray ( table , bool )
-- What it Does:    Takes a Lua table and converts it to a standard array, with option to sort
-- Purpose:         Useful when needing to cycle through a table alphabetically.
GRM.ConvertTableToArray = function ( data , needToSort )
    local result = {};

    for a in pairs ( data ) do
        table.insert ( result , a );
    end
    
    if needToSort and #result > 0 then
        sort ( result );
    end

    return result;
end

-- Method:          GRM.ConvertTableTo2DArray ( table , bool ) 
-- What it Does:    Takes a dictionary table and converts it to a 2D array, then allows you to sort it alphabetically.
-- Purpose:         Useful when taking apart tables, like in sync - easier to go through in an ordered list.
GRM.ConvertTableTo2DArray = function ( dataToConvert , needToSort )
    local result = {};
    for a , b in pairs ( dataToConvert ) do
        table.insert ( result , { a , b } );
    end
    
    if needToSort and #result > 0 then
        sort ( result , function ( a , b ) return a[1] < b[1] end );
    end

    return result;
end

-- Method:          GRM.GetNumGuildiesInGuild ( table )
-- What it Does:    Returns the number of current guildies there are
-- Purpose:         For accurate reporting on most recent current snapshot of a guild in the database
GRM.GetNumGuildiesInGuild = function ( guildData )
    local c = 0;

    for _ , p in pairs ( guildData ) do
        if type ( p ) == "table" then
            c = c + 1;
        end
    end

    return c;
end

-- Method:          GRM.IsMergedRealmServer()
-- What it Does:    Returns true if the player is currently on a merged realm server
-- Purpose:         Useful to know in certain circumstances, like not relying on the guild name alone to identify guild home.
GRM.IsMergedRealmServer = function()
    local result = false;
    if #GetAutoCompleteRealms() > 0 then
        result = true;
    end
    return result
end

-- Method:          GRM.GetAllConnectedRealms()
-- What it Does:    Returns all the connected realm names in an array, and if there are none, it just returns the player's own array.
-- Purpose:         Useful for autocomplete reasons.
GRM.GetAllConnectedRealms = function()
    local realms = GetAutoCompleteRealms();
    if #realms == 0 then
        realms = { GRM_G.realmName };
    end
    return realms;
end

--------------------------------
-- TRANSFER/RESTORE POINT ------
--------------------------------

-- Method:          GRM.AddGuildBackup ( string , string )
-- What it Does:    Adds a backup point of the given selected guild.
-- Purpose:         Save your database as needed.
GRM.AddGuildBackup = function( guildName , creationDate )

    if creationDate ~= GRM.L ( "Unknown" ) then

        if GRM_GuildMemberHistory_Save[guildName] then
            GRM_GuildDataBackup_Save[guildName].date = GRM.GetTimestamp();
            GRM_GuildDataBackup_Save[guildName].epochDate = time();
            GRM_GuildDataBackup_Save[guildName].numGuildies = GRM.GetNumGuildiesInGuild( GRM_GuildMemberHistory_Save[guildName] );
            GRM_GuildDataBackup_Save[guildName].members = GRM.DeepCopyArray ( GRM_GuildMemberHistory_Save[guildName] );
            GRM_GuildDataBackup_Save[guildName].formerMembers = GRM.DeepCopyArray ( GRM_PlayersThatLeftHistory_Save[guildName] );
            GRM_GuildDataBackup_Save[guildName].log = GRM.DeepCopyArray ( GRM.GetLog(guildName) );
            GRM_GuildDataBackup_Save[guildName].alts = GRM.DeepCopyArray ( GRM_Alts[guildName] );

            GRM.Report ( GRM.L ( "Backup Point Set for Guild \"{name}\"" , guildName ) );

        else
            GRM.Report ( GRM.L ( "Unable to properly locate guild for backup" ) );
        end

    else
        GRM.Report ( "GRM: Unable to Create Backup for a Guild With Unknown Creation Date! Log into that guild on any alt to update old database." );
    end
end

-- Method:          GRM.RemoveGuildBackup ( string , bool )
-- What it Does:    Removes a Backup Point for the guild...
-- Purpose:         Database Backup Management
GRM.RemoveGuildBackup = function( guildName , isTransfer )

    if GRM_GuildDataBackup_Save[guildName] ~= nil then
        local creationDate = GRM_GuildDataBackup_Save[guildName].guildCreationDate;
        GRM_GuildDataBackup_Save[guildName] = {};
        GRM_GuildDataBackup_Save[guildName].guildCreationDate = creationDate;   -- Need to keep this.
        GRM_GuildDataBackup_Save[guildName].date = "";
        GRM_GuildDataBackup_Save[guildName].epochDate = 0;
        GRM_GuildDataBackup_Save[guildName].numGuildies = 0;
        GRM_GuildDataBackup_Save[guildName].members = {};
        GRM_GuildDataBackup_Save[guildName].formerMembers = {};
        GRM_GuildDataBackup_Save[guildName].log = {};
        GRM_GuildDataBackup_Save[guildName].alts = {};
        if not isTransfer then
            GRM.Report ( GRM.L ( "Backup Point Removed for Guild \"{name}\"" , guildName ) );
        end
    end

end

-- Method:          GRM.LoadRestorePoint ( string , string , string )
-- What it Does:    Restores backup point of a guild
-- Purpose:         Database Backup Management
GRM.LoadRestorePoint = function( guild , guildTransfer , oldName )

    local guildName = guild or GRM_G.guildName;

    if GRM_GuildMemberHistory_Save[guildName] ~= nil then
        
        if guildTransfer then

            local newServerName = string.match ( guild , "-(.+)" );

            GRM_GuildMemberHistory_Save[guildName] = GRM.ChangeServerNameOfAll ( GRM.DeepCopyArray ( GRM_GuildDataBackup_Save[oldName].members ) , newServerName , false , true , false );
            GRM_GuildMemberHistory_Save[guildName].grmName = guildName; -- Need to update the saved name too.

            if GRM_G.BuildVersion >= 80000 then
                GRM_GuildMemberHistory_Save[guildName].grmClubID = C_Club.GetGuildClubId();
            else
                GRM_GuildMemberHistory_Save[guildName].grmClubID= GRM.CreateCustomGUIDValue( guildName );
            end

            GRM_PlayersThatLeftHistory_Save[guildName] = GRM.ChangeServerNameOfAll ( GRM.DeepCopyArray ( GRM_GuildDataBackup_Save[oldName].formerMembers ) , newServerName , false , true , true );
            GRM_LogReport_Save[guildName] = GRM.DeepCopyArray ( GRM_GuildDataBackup_Save[oldName].log );
            GRM_Alts[guildName] = GRM.ChangeServerNameOfAll ( GRM.DeepCopyArray ( GRM_GuildDataBackup_Save[oldName].alts ) , newServerName , true , false , false );
            GRM_CalendarAddQue_Save[guildName] = {};

            -- Clear the backup point
            GRM_GuildDataBackup_Save[guildName] = {};
            GRM_GuildDataBackup_Save[guildName].guildCreationDate = GRM_GuildDataBackup_Save[oldName].guildCreationDate;   -- Need to keep this.
            GRM_GuildDataBackup_Save[guildName].date = "";
            GRM_GuildDataBackup_Save[guildName].epochDate = 0;
            GRM_GuildDataBackup_Save[guildName].numGuildies = 0;
            GRM_GuildDataBackup_Save[guildName].members = {};
            GRM_GuildDataBackup_Save[guildName].formerMembers = {};
            GRM_GuildDataBackup_Save[guildName].log = {};
            GRM_GuildDataBackup_Save[guildName].alts = {};

            -- need to purge the old backup
            GRM.RemoveGuildBackup ( guildName , true );
            if GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_UIOptionsFrame:IsVisible() then
                GRM.BuildBackupScrollFrame ( true , true );
            end

            if not GRM_PlayerListOfAlts_Save[guildName] then
                GRM_PlayerListOfAlts_Save[guildName] = {};
            end

            GRM.RestoreAllOldNotes(); -- Import the notes.

            GRM.Report ( GRM.L ( "Data has been transferred from the old Guild \"{name}\"" , oldName ) );

        else

            GRM_GuildMemberHistory_Save[guildName] = GRM.DeepCopyArray ( GRM_GuildDataBackup_Save[guildName].members );
            GRM_PlayersThatLeftHistory_Save[guildName] = GRM.DeepCopyArray ( GRM_GuildDataBackup_Save[guildName].formerMembers );
            GRM_LogReport_Save[guildName] = GRM.DeepCopyArray ( GRM_GuildDataBackup_Save[guildName].log );
            GRM_Alts[guildName] = GRM.DeepCopyArray ( GRM_GuildDataBackup_Save[guildName].alts );
            GRM.Report ( GRM.L ( "Backup Point Restored for Guild \"{name}\"" , guildName ) );
            GRM_CalendarAddQue_Save[guildName] = {};

        end

        if GRM_UI.GRM_MemberDetailMetaData:IsVisible() then
            GRM.ClearAllFrames( false );
            GRM.PopulateMemberDetails ( GRM_G.currentName );
        end

        GRM.RefreshAllMacroToolFrames();

        if GRM_UI.GRM_AuditJDTool:IsVisible() then
            GRM.AuditRefresh( true );
        end

        if GRM_UI.GRM_ExportLogBorderFrame:IsVisible() then
            GRM_UI.SetExportTabHighlights ();
        end;

        GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_LogEditBox:SetText ( "" );
        GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_LogEditBox:SetText ( GRM.L ( "Search Filter" ) );  -- By clearing it and restoring it, it triggers the build log action
        
        GRM_G.changeHappenedExitScan = true;
    end
end

-- Method:          GRM.RestoreAllOldNotes()
-- What it Does:    Restores all of the original notes
-- Purpose:         Sets all public and officer notes.
GRM.RestoreAllOldNotes = function()
    local guildData = GRM.GetGuild();
    local name = "";

    for i = 1 , GRM.GetNumGuildies() do
        -- For guild info
        name = GetGuildRosterInfo ( i );

        if guildData[name] then

            -- player found in guild, let's update the notes.
            if GRM.CanEditOfficerNote() and guildData[name].officerNote then
                GuildRosterSetOfficerNote ( i , guildData[name].officerNote );
            end

            if GRM.CanEditPublicNote() and guildData[name].note then
                GuildRosterSetPublicNote ( i , guildData[name].note );
            end

        end
    end
end

-- Method:          GRM.ChangeServerNameOfAll ( table , string , bool , bool , bool )
-- What it Does:    Converts all of the server names of the players on the saved guild DB to the new server, in case of a guild transfer
-- Purpose:         Restore all guild data easily when transferring servers.
GRM.ChangeServerNameOfAll = function( guildData , newServerName , isAlts , addFlag , oldRoster )

    local newGuildData = {};

    if not isAlts then

        for name , player in pairs ( guildData ) do
            if type(player) == "table" then

                    -- Update whoever left the custom note
                if player.customNote[3] ~= "" then
                    player.customNote[3] = string.match ( player.customNote[3] , "(.+-)" ) .. newServerName;
                end 

                -- Update name of player who banned
                if player.bannedInfo[4] ~= "" and string.find ( player.bannedInfo[4] , "-" ) ~= nil then
                    player.bannedInfo[4] = string.match ( player.bannedInfo[4] , "(.+-)" ) .. newServerName;
                else
                    player.bannedInfo[4] = "";
                end

                if not oldRoster then
                    if #player.joinDateHist > 0 then
                        if player.joinDateHist[1][6] then
                            player.joinDateHist[1][5] = time();     -- Preserve these dates
                        end
                    end

                    if #player.rankHist > 1 then
                        if player.rankHist[1][7] then
                            player.rankHist[1][6] = time();     -- Preserve these dates
                        end
                    end
                end

                -- Update list of alts.
                if #player.altsAtTimeOfLeaving > 0 then
                    for i = 1 , #player.altsAtTimeOfLeaving do
                        player.altsAtTimeOfLeaving[i][1] = string.match ( player.altsAtTimeOfLeaving[i][1] , "(.+-)" ) .. newServerName;
                    end
                end

                -- Fix player name
                -- Only want to change the player name if they are banned
                if not oldRoster or ( oldRoster and not player.bannedInfo[1] ) then
                    player.name = string.match ( player.name , "(.+-)" ) .. newServerName;
                    newGuildData[player.name] = GRM.DeepCopyArray ( player );
                    if addFlag then
                        newGuildData[player.name].isTransfer = true;
                    end
                else
                    newGuildData[player.name] = GRM.DeepCopyArray ( player );
                    if addFlag then
                        newGuildData[player.name].isTransfer = true;
                    end
                end                

            else
                newGuildData[name] = GRM.DeepCopyArray ( player );

            end
        end
    else

        for _ , altGroup in pairs ( guildData ) do
            if altGroup.main ~= "" then
                altGroup.main = string.match ( altGroup.main , "(.+-)" ) .. newServerName;
            end

            for i = 1 , #altGroup do
                altGroup[i].name = string.match ( altGroup[i].name , "(.+-)" ) .. newServerName;
            end

        end
        newGuildData = guildData;

    end
    return newGuildData;
end

-- Method:          GRM.ResetAllBackups()
-- What it Does:    Wipes all backup data, but then reinitializes an index for each guild
-- Purpose:         For managing the database of guild backups
GRM.ResetAllBackups = function()
    -- Reset the backup data in case any player was messing around with it...
    for guild in pairs ( GRM_GuildDataBackup_Save ) do
        GRM_GuildDataBackup_Save[guild] = {};
    end
end

-- Method:          GRM.PurgeGuildFromDatabase( string )
-- What it Does:    Completely purges a guild from the player database... that it is not currently logged into
-- Purpose:         Cleanup old guild data from a guild the player is no longer a part of.
GRM.PurgeGuildFromDatabase = function ( guildName )
    local finalMsg = true;

    if guildName == GRM_G.guildName then
        GRM.Report ( "\n" .. GRM.L ( "Player Cannot Purge the Guild Data they are Currently In!!!" ) .. "\n" .. GRM.L( "To reset your current guild data type '/grm clearguild'" ) );
    else

        if not GRM_GuildMemberHistory_Save[guildName] and GRM_GuildDataBackup_Save[guildName] then
            GRM.Report ( GRM.L ( "Error: Guild Not Found..." ) );
            finalMsg = false;
        end

        GRM_GuildMemberHistory_Save[guildName] = nil;
        GRM_PlayersThatLeftHistory_Save[guildName] = nil;
        GRM_CalendarAddQue_Save[guildName] = nil;
        GRM_LogReport_Save[guildName] = nil;
        GRM_GuildDataBackup_Save[guildName] = nil;
        GRM_PlayerListOfAlts_Save[guildName] = nil;
        GRM_Alts[guildName] = nil;
        GRM_AddonSettings_Save[guildName] = nil;

        if finalMsg then
            GRM.Report ( GRM.L ( "{name} has been removed from the database." , guildName ) );
        end
    end
end

--------------------------------
--- END OF RESTORE POINT -------
--------------------------------

--------------------------------------
-------- DEBUGGING -------------------
--------------------------------------

-- Method:          GRM.DebugLog ( int )
-- What it Does:    Prints out the Debug Log the last X number of items that occurred before logging off or disconnecting.
-- Purpose:         Occasionally disconnects happen. This will let me know what happened!
GRM.DebugLog = function ( numToShow )
    local index;
    if numToShow < 0 or #GRM_G.DebugLog - numToShow < 0 then
        index = 0;
        numToShow = #GRM_G.DebugLog;
    else
        index = #GRM_G.DebugLog - numToShow;
    end

    GRM.Report ( string.upper ( GRM.L ( "Debugger Start" )  .. ": " .. numToShow .. "/" .. #GRM_G.DebugLog ) );
    for i = index + 1 , #GRM_G.DebugLog do
        GRM.Report( GRM_G.DebugLog[i] );
    end
end

-- Method:          GRM.AddDebugMessage ( string )
-- What it Does:    Addes messages of recent events to debug log...
-- Purpose:         Debugging tracking
GRM.AddDebugMessage = function ( msg )
    -- To prevent too large of a debug log...
    if msg == "" then
        msg = "Empty Msg";
    end
    if #GRM_G.DebugLog < 250 then
        table.insert ( GRM_G.DebugLog , time() .. ": " .. msg );
    else
        local tempLog = {};
        for i = #GRM_G.DebugLog - 50 , #GRM_G.DebugLog do
            table.insert ( tempLog , time() .. ": " .. GRM_G.DebugLog[i] );
        end
        GRM_G.DebugLog = tempLog;
        table.insert ( GRM_G.DebugLog , msg );
    end
end

-- Method:          GRM.DebugMessages()
-- What it Does:    Enables debugging messages
-- Purpose:         Get rid of need of 2 sets of programs... just enable and disable.
GRM.DebugMessages = function()
    if GRM_G.DebugMsgEnabled then
        GRM_G.DebugMsgEnabled = false;
        GRM.Report ( GRM.L ( "Debugging Enabled" ) );
    else
        GRM_G.DebugMsgEnabled = true;
        GRM.Report ( GRM.L ( "Debugging Disabled" ) );
    end
end

--------------------------------------
------ GROUP METHODS AND LOGIC -------
--------------------------------------

-- Method:          GRM.GetClubEpochJoinTime ( int )
-- What it Does:    Returns the epoch stamp of when a player joined a guild or community
-- Prupose:         Useful to know exact date...
GRM.GetClubEpochJoinTime = function ( clubID )
    local info = C_Club.GetClubInfo ( clubID );
    local result = -1;
    if info then
        result = GRM.ConvertToRealEpochNumber ( info.joinTime );
    end
    return result;
end

-- Method:          GRM.GetSelectedClubID()
-- What it Does:    Returns the selected club ID - to be used as GRM expands to all communities
-- Purpose:         To pull data from specific club only.
GRM.GetSelectedClubID = function()
    return CommunitiesFrame:GetSelectedClubId();
end

-- Method:          GRM.GetStreamViewMarker ( int , int )
-- What it Does:    Returns the time as an epoch timestamp format of wher ethe cutoff of the Unread messages lies
-- Purpose          on back reading the chat stream of the guild or community, this will tell you the time your unread messages begin.
GRM.GetStreamViewMarker = function( clubID , channelID )
    local streamViewMarker = C_Club.GetStreamViewMarker ( clubID , channelID );
    local number = nil;
    if streamViewMarker then
        number = GRM.ConvertToRealEpochNumber ( streamViewMarker );
    end
    return number;
end

-- Method:          GRM.ConvertToRealEpochNumber ( Number in scientific notation, like a float, 1.52223232323e+15 )
-- What it Does:    Returns the epoch real number from a converted number in the default Lua scientific notation format.
-- Purpose:         Blizz provides a microsecond version of the epoch time stamp, which is unnecessary, and rather than rewrite all my other epoch methods, I just convert to proper epoch format here
GRM.ConvertToRealEpochNumber = function ( scientificNotedNumber )
    return math.floor ( ( tonumber ( string.format ( "%.0f" , scientificNotedNumber ) ) / 1000000 ) + 0.5 );
end

-- Method:          GRM.GetFullNameClubMember ( guid(as string) )
-- What it Does:    Appends the server to the end of the player name properly...
-- Purpose:         To append the full player name properly since it is not given by default
GRM.GetFullNameClubMember = function( memberGUID )
    local result = "";

    if memberGUID and memberGUID ~= "" then
        local name , realm = select ( 6 , GetPlayerInfoByGUID ( memberGUID ) );
        
        -- For some reason the server sometimes fails to give info on the first ask that session.
        if name == nil or name == "" then
            for i = 1 , 10 do
                name , realm = select ( 6 , GetPlayerInfoByGUID ( memberGUID ) );

                -- if name ~= nil and name ~= "" then
                --     break;
                -- end
            end
        end
                
        if name ~= nil and name ~= "" then
            if realm == "" then
                result = name .. "-" .. GRM_G.realmName;
            else
                result = name .. "-" .. realm;
            end
        end
    end
    return result;
end

-- Method:          GRM.AppendServerName ( string , bool )
-- What it Does:    Adds the server name to the player's name if it is not there
-- Purpose:    AppendServerName = fun     In some cases you need the full name-serverName to do some actions, when the server only gives you the name of players you are on same realm with trimmed of server. This adds it back.
GRM.AppendServerName = function ( name , currentGuild )
    if name ~= nil and name ~= "" and not string.find ( name , "-" , 1 , true ) then
        name = name .. "-" .. GRM.GetPlayerServer ( name , currentGuild );
    end

    return name;
end

-- Method:          GRM.GetPlayerServer ( string , bool )
-- What it Does:    Attempts to determine the player's serverName, for database purposes.
-- Purpose:         Unfortunately, some system messages do not inlcude the metadata to determine a player's name
GRM.GetPlayerServer = function ( name , currentGuild )
    local server = GRM_G.realmName;
    
    if string.find ( name , "-" ) then
        server = string.match ( name , "%-(.+)" );
    else

        -- Logic on merged realms is a bit more complicated.
        if GRM.IsMergedRealmServer() then
            local realms = GRM.GetAllConnectedRealms();
            local listOfNames = {};
            local player = {};

            for i = 1 , #realms do

                if currentGuild == nil then
                    player = GRM.GetPlayer ( name .. "-" .. realms[i] );

                    if not player then
                        player = GRM.GetFormerPlayer ( name .. "-" .. realms[i] );
                    end

                else
                    if currentGuild then
                        player = GRM.GetPlayer ( name .. "-" .. realms[i] );
                    else
                        player = GRM.GetFormerPlayer ( name .. "-" .. realms[i] );
                    end
                end
                
                if player then
                    table.insert ( listOfNames , player.name );
                end

            end

            -- More than 1 player found with same name, but different servers...
            if #listOfNames > 1 then

                for i = 1 , #listOfNames do

                    if currentGuild == nil then
                        player = GRM.GetPlayer ( listOfNames[i] );

                        if not player then
                            player = GRM.GetFormerPlayer ( listOfNames[i] );
                        end
                    else
                        if currentGuild then
                            player = GRM.GetPlayer ( listOfNames[i] );
                        else
                            player = GRM.GetFormerPlayer ( listOfNames[i] );
                        end
                    end

                    if player then

                        -- Logic isn't perfect, but I will just default if player is online.
                        if player.isOnline then
                            server = string.match ( listOfNames[i] , "-(.+)" );
                            break;
                        end

                    end

                end
                
            elseif #listOfNames == 1 then
                server = string.match ( listOfNames[1] , "-(.+)" );
            end

        end
    end

    return server;
end

-- Method:          GRM.GetNumGuildies()
-- What it Does:    Returns the int number of total toons within the guild, including main/alts
-- Purpose:         For book-keeping and tracking total guild membership.
--                  Overall, this is mostly redundant as a simple GetNumGuildMembers() call is the same thing, however, this is just a tech Demo
--                  as a coding example of how to pull info and return it in your own function.
--                  A simple "GetNumGuildMembers()" would result in the same result in less steps. This is just more explicit to keep it within the style of the functions of the addon.
GRM.GetNumGuildies = function()
    return select ( 1 , GetNumGuildMembers() );
end

-- Method:          GRM.GetNumMains()
-- What it Does:    Returns the total number of players designated as "Main" in the guild
-- Purpose:         Mainly for audit log stat reporting.  
GRM.GetNumMains = function()
    local count = 0;

    for _ , player in pairs ( GRM.GetGuild() ) do
        if type ( player ) == "table" then
            if player.isMain then
                count = count + 1;
            end
        end
    end
    return count;
end

-- Method:          GetListOfGuildRanks( bool )
-- What it Does:    Gets a list of all rank names for dropdown menu
-- Purpose:         For building the macro dropdown menu for destination rank
GRM.GetListOfGuildRanks = function( includeLeader , descending , asString )
    local numRanks = GuildControlGetNumRanks(); -- minus 1 because we are not including the guild leader
    local result = {};
    local resultString = "";

    local delimiter = "||";

    local c = 1;
    if not includeLeader then
        c = 2;
    end

    if descending then
        for i = c , numRanks do

            if asString then
                if i == numRanks then
                    resultString = resultString .. GuildControlGetRankName ( i );
                else
                    resultString = resultString .. GuildControlGetRankName ( i ) .. delimiter;
                end
            else
                table.insert ( result , GuildControlGetRankName ( i ) );
            end
        end
    else
        for i = numRanks , c , -1 do
            if asString then
                if i == c then
                    resultString = resultString .. GuildControlGetRankName ( i );
                else
                    resultString = resultString .. GuildControlGetRankName ( i ) .. delimiter;
                end
            else
                table.insert ( result , GuildControlGetRankName ( i ) );
            end
        end
    end

    if asString then
        return resultString;
    else
        return result;
    end
end

-- Method:          GetNumberPatternMatches ( string , string )
-- What it Does:    Returns the integer count number of matches of a pattern, like how many commas in a string
-- Purpose:         Easier to parse some strings with simpler logic.
GRM.GetNumberPatternMatches = function ( text , pattern )
    return select ( 2 , string.gsub ( text , pattern , "" ) );
end

-- Method:          GRM.CreateGuildCreationDatePattern()
-- What it Does:    Creates the guild Creation Date Pattern
-- Purpose:         Easier parse the creation date without repetitive work.
GRM.CreateGuildCreationDatePattern = function()
    local pattern = GUILD_INFO_TEMPLATE;

    if GRM_G.BuildVersion >= 30000 or GRM_G.Region == "deDE" or GRM_G.Region == "frFR" or GRM_G.Region == "koKR" then
        for i = 1 , 5 do
            pattern = string.gsub ( pattern  , "%%" .. i .. "$d" , "(%%d+)" );
        end
    else
        pattern = string.gsub ( pattern  , "%%d" , "(%%d+)" );
    end

    return pattern;
end

-- Method:          GRM.SetSystemMessageFilter ( self , string , string )
-- What it Does:    Starts tracking the system messages for filtering. This is only triggered on the audit frame initialization or if a player has left the guild
-- Purpose:         To control system message spam when doing server inquiries
GRM.SetSystemMessageFilter = function ( _ , _ , msg , ... )
    local result = false;
    GRM_G.SystemMessageTest = true;

    -- Error protection to not break chat
    if GRM.S() then
        if msg and time() - GRMsyncGlobals.timeAtLogin > 1 and not GRM_G.TempBanSystemMessage then
            GRM_G.guildInfoSystemMessage = GRM_G.guildInfoSystemMessage or string.sub ( GUILD_INFO_TEMPLATE , 1 , string.find ( GUILD_INFO_TEMPLATE , "%%" ) - 1 );
            -- GUILD INFO FILTER (GuildInfo())
            if GRM_G.MsgFilterDelay and ( string.find ( msg , GRM_G.guildInfoSystemMessage ) ~= nil or string.find ( msg , GRM.Trim ( CHAT_GUILD_SEND ) ) ~= nil ) then       -- These may need to be localized. I have not yet tested if other regions return same info. It IS system info.
                if string.find ( msg , GRM_G.guildInfoSystemMessage ) ~= nil and ( ( time() - GRM_G.SystemMsgThrottle ) > 1 ) then
                    GRM_G.SystemMsgThrottle = time();
                    GRM_G.CreationDatePattern = GRM_G.CreationDatePattern or GRM.CreateGuildCreationDatePattern();

                    local a , b , c , _ , numUniqueAccounts = string.match ( msg , GRM_G.CreationDatePattern );
                    local month , day , year;
                    -- a , b , c can be either day, month, or year, depending on the Region formatting for the note.
                    if GRM_G.Region == "deDE" or GRM_G.Region == "esES" or GRM_G.Region == "esMX" or GRM_G.Region == "frFR" then
                        day = a;
                        month = b;
                        year = c;
                    elseif GRM_G.Region == "enUS" or GRM_G.Region == "itIT" or GRM_G.Region == "ptBR" or GRM_G.Region == "ruRU" or GRM_G.Region == "zhCN" or GRM_G.Region == "zhTW" then
                        day = b;
                        month = a;
                        year = c;
                    elseif GRM_G.Region == "koKR" then
                        day = c;
                        month = b;
                        year = a;
                    end

                    -- On first logging in, there can be an error and not be able to load.
                    if day ~= "0" then
                        
                        numUniqueAccounts = tonumber ( numUniqueAccounts );
                        
                        -- For auto-main tagging... detect the change here!
                        if numUniqueAccounts > GRM_G.numAccounts and GRM_G.numAccounts ~= 0 then
                            GRM_G.DesignateMain = true;
                            C_Timer.After ( 10.1 , function()
                                GRM_G.DesignateMain = false;
                            end);
                        end
                        
                        GRM_G.numAccounts = numUniqueAccounts;

                        local date = day .. "-" .. month .. "-" .. year;

                        if GRM_G.guildCreationDate == "" or GRM_G.guildCreationDate ~= date then
                            GRM_G.guildCreationDate = date;
                        end

                    end
                end
                result = true;

            -- Player Not Found when trying to add to friends list message
            elseif ( GRM_G.MsgFilterDelay or GRM_G.MsgFilterDelay2 ) and ( msg == GRM.L ( "Player not found." ) or string.find ( msg , GRM.L ( "added to friends" ) ) ~= nil or string.find ( msg , GRM.L ( "is already your friend" ) ) ~= nil ) then
                result = true;

            elseif GRMsyncGlobals.CurrentSyncPlayer and GRMsyncGlobals.CurrentSyncPlayer ~= "" and GRM.SystemMessagePatternMatchCheck ( 1 , msg , GRMsyncGlobals.CurrentSyncPlayer ) then

                if GRMsyncGlobals.currentlySyncing then
                    GRMsync.EndSync ( false );
                end

                result = true;

            elseif string.find ( msg , GRM.L ( "has promoted" ) ) ~= nil or string.find ( msg , GRM.L ( "has demoted" ) ) ~= nil or string.find ( msg , GRM.L ( "joined the guild." ) ) ~= nil or string.find ( msg , GRM.L ( "left the guild." ) ) ~= nil or string.find ( msg , GRM.L ( "has been kicked" ) ) ~= nil then
                -- Silence messages the log
                result = GRM.SystemMessageLiveDetectionControl ( msg );
    -- 
            -- Normal System message... Let's add the main tags...
            elseif not GRM_G.MainNameSystemMsgControl then  -- No need to add a tag if they just joined... as they have no tag, and their profile is not yet generated. Addon will see them as a non-guildie the first instant.
                if ( time() - GRMsyncGlobals.timeAtLogin ) > 5 and GRM.S() and ( ( GRM_G.MainTagHexCode ~= "" and GRM.S().showMainName ) or GRM.S().colorizeNames ) then
                    if string.find ( msg , GRM.L ( "has come online." ) ) ~= nil then
                        msg = GRM.AddMainTagToComeOnlineSystemMessage ( msg );

                        -- Check if it is their birthday.
                        GRM.AnnounceIfBirthday ( msg );

                        C_Timer.After ( 1.5 , function()    -- Giving a delay as I found instantly the "IsOnline" to not be accurate from server always. Need a second or so to register.
                            GRM.AnnounceIfMacroReady ( msg );
                        end);

                    elseif string.find ( msg , GRM.L ( "has gone offline." ) ) ~= nil then
                        if GRMsyncGlobals.currentlySyncing and GRM.SyncPlayerGoneOffline( msg ) then
                            GRMsync.EndSync ( false );
                        end
                        msg = GRM.AddMainTagToGoneOfflineSystemMessage ( msg );
                    end
                end
            elseif GRM_G.MainNameSystemMsgControl and string.find ( msg , GRM.L ( "has gone offline." ) ) ~= nil and GRMsyncGlobals.currentlySyncing and GRM.SyncPlayerGoneOffline( msg ) then
                GRMsync.EndSync ( false );
            end
        else
            result = true;
        end
    end

    -- Re-evaluate message controls
    GRM.SystemMessageHookControl()

    return result , msg , ... ;
end

-- Method:          GRM.SyncPlayerGoneOffline ( string )
-- What it Does:    Reports back if player you are syncing with has gone offline.
-- Purpose:         Will need to break sync if players has gone offline.
GRM.SyncPlayerGoneOffline = function ( msg )
    local result = false;

    local breakIndex = string.find ( msg , " " );                  -- This format fits almost all
    if breakIndex == nil then
        breakIndex = string.find ( msg , "下線了。" );              -- Taiwanese
        if breakIndex == nil then
            breakIndex = string.find ( msg , "下线了。" );          -- Mandarin
        end
    end

    local fullName = GRM.AppendServerName ( string.sub ( msg , 1 , breakIndex - 1 ) , true );

    if ( GRMsyncGlobals.IsElectedLeader and GRMsyncGlobals.CurrentSyncPlayer == fullName ) or ( not GRMsyncGlobals.IsElectedLeader and GRMsyncGlobals.DesignatedLeader == fullName ) then
        result = true;
    end

    return result;
end

-- Method:          GRM.SystemMessagePatternMatchCheck ( string , string , string )
-- What it Does:    Return true if the pattern matches
-- Purpose:         During sync, if a player goes offline then you will be notified that sync has failed using this.
GRM.SystemMessagePatternMatchCheck = function( pattern , msg , name )

    local result = false;
    local toMatch = "";
    if pattern == 1 then

        if not GRM_G.NotOnlineSystemMessage then
            if GRM_G.Region == "esES" or GRM_G.Region == "esMX" or GRM_G.Region == "koKR" or GRM_G.Region == "zhTW" then
                toMatch = "%%s";

            elseif GRM_G.Region == "zhCN" then
                if GRM_G.BuildVersion < 40000 then  -- Not known exact expansion it changed
                    toMatch = "\"%%s\""
                else
                    toMatch = "“%%s”";
                end

            elseif GRM_G.Region == "itIT" or GRM_G.Region == "ruRU" then
                toMatch = "\"%%s\""

            elseif GRM_G.Region == "koKR" then
                toMatch = "“%%s";

            else
                toMatch = "\'%%s\'";
            end

            GRM_G.NotOnlineSystemMessage = string.gsub ( ERR_CHAT_PLAYER_NOT_FOUND_S , toMatch , "(.+)" );
        end
        if string.match ( msg , GRM_G.NotOnlineSystemMessage ) ~= nil and string.find ( msg , name , 1 , true ) ~= nil then
            result = true;
        end

    end

    return result;
end

-- Method:          GRM.AnnounceIfBirthday ( string )
-- What it Does:    Announces to chat that it is the player's bday when they login or when first logging on.
-- Purpose:         So you will have the knowledge to say happy birthday when someone logs in!
GRM.AnnounceIfBirthday = function ( msg )
    if not GRM.S().AnnounceBdayOnLogin then
        return;
    end

    local names = {}
    local player;

    if msg then
        names = { GRM.AppendServerName ( select ( 3 , msg:find ( "|Hplayer:([^:]*)(.-)|h%[.-%]|h" ) ) ) }; -- Parses name out, then formats it to show server for DB reasons.
    else
        names = GRM.GetListOfOnlinePlayers();
    end

    if GRM.GetGuild() then
        for i = 1 , #names do
        -- Is Player in the guild?
            player = GRM.GetPlayer ( names[i] );
            if player then
                -- First, check if bday even configured
                if player.events[2][1][1] > 0 then
                    -- Birthday is set, now we compare!
                    local month , day = select ( 2 , GRM.GetTodaysDate() );
                    if player.events[2][1][1] == day and player.events[2][1][2] == month then

                        -- Only announce if necessary
                        if not GRM_DailyAnnounce[player.name] then
                            GRM_DailyAnnounce[player.name] = true;
                            local color = GRM.S().logColor[11];
                            C_Timer.After ( 0.1 , function()
                                GRM.Report ( GRM.L ( "It's {name}'s Birthday today!!!" , GRM.GetClassifiedName ( names[i] , true ) ) , color[1] , color[2] , color[3] );
                            end);
                        end

                    end
                end
            end
        end
    end
end

-- Method:          GRM.AnnounceIfMacroReady( string )
-- What it Does:    Announces if a player, after they logon, match a macro rule
-- Purpose:         To give a reminder to perform an action once the person is currently online.
GRM.AnnounceIfMacroReady = function ( msg )
    if CanGuildPromote() or CanGuildDemote() then
        local listOfNames = {};

        local name = GRM.AppendServerName ( string.match ( msg , "|Hplayer:([^:]*)(.-)|h%[.-%]|h" ) );

        if name and CanGuildPromote() then
            listOfNames = GRM.GetNamesByFilterRules( 2 );

            for i = 1 , #listOfNames do
                if listOfNames[i].name == name then
                    if GRM.IsGuildieOnline ( listOfNames[i].name ) then

                        if not GRM_G.MacroMatchList[listOfNames[i].name] then
                            GRM_G.MacroMatchList[listOfNames[i].name] = { false , false };
                        end

                        if not GRM_G.MacroMatchList[listOfNames[i].name][1] then
                            GRM.Report ( GRM.L ( "GRM:" ) .. " " .. GRM.L ( "{name} matches rules for a promotion and is currently online." , GRM.GetClassifiedName ( listOfNames[i].name ) ) );
                            GRM_G.MacroMatchList[listOfNames[i].name][1] = true;
                        end

                        break;
                    end
                end
            end
        end

        if CanGuildDemote() then
            listOfNames = GRM.GetNamesByFilterRules( 3 );

            for i = 1 , #listOfNames do
                if listOfNames[i].name == name then
                    if GRM.IsGuildieOnline ( listOfNames[i].name ) then

                        if not GRM_G.MacroMatchList[listOfNames[i].name] then
                            GRM_G.MacroMatchList[listOfNames[i].name] = { false , false };
                        end

                        if not GRM_G.MacroMatchList[listOfNames[i].name][2] then
                            GRM.Report ( GRM.L ( "GRM:" ) .. " " .. GRM.L ( "{name} matches rules for a demotion and is currently online." , GRM.GetClassifiedName ( listOfNames[i].name ) ) );
                            GRM_G.MacroMatchList[listOfNames[i].name][2] = true;
                        end

                        break;
                    end
                end
            end
        end
    end
end

-- Method:          GRM.GetListOfOnlinePlayers()
-- What it Does:    Returns a string array of names, sorted in order, of players that are currently online
-- Purpose:         Easy use to know who is online currently in case you are checking something relevant.
GRM.GetListOfOnlinePlayers = function()
    local list = {};
    for _ , player in pairs ( GRM.GetGuild() ) do
        if type ( player ) == "table" then
            if player.isOnline then
                table.insert ( list , player.name );
            end
        end
    end

    sort ( list );

    return list;
end

-- Method:          GRM.AddMainTagToComeOnlineSystemMessage ( string )
-- What it Does:    Adds the main/alt tags to the system messages for coming online.
-- Purpose:         Alt management feature!
GRM.AddMainTagToComeOnlineSystemMessage = function( msg )
    local name, msgID = select ( 3 , msg:find ("|Hplayer:([^:]*)(.-)|h%[.-%]|h" ) );
    local fullName = GRM.AppendServerName ( name );
    local includeMainTag = ( GRM_G.MainTagHexCode ~= "" and GRM.S().showMainName );
    local result = "";
    
    if GRM_G.guildName ~= "" then
        -- Is Player in the guild?
        if IsInGuild() and GRM.GetPlayer ( fullName ) then
            local mainName = "";
            local hexCode = "";
            local mainColoring = "";
            local systemMsgHex = "|CFFFFFF00";  -- For display controls further...
            local mainDisplay = "";
            local necessaryGap = "";
            local hasAlts = false;
            
            if GRM.S().useMainTag then
                -- Just add main tag...
                msg = GRM_G.MainTagHexCode .. mainDisplay .. "|r " .. msg;
            end
            if includeMainTag then
                mainName = GRM.GetMainName ( fullName , false );
                mainColoring , hasAlts = GRM.GetStringClassColorByName ( mainName );
                mainDisplay = GRM.GetMainTags ( false , GRM.S().mainTagIndex );
                
                if GRM.S().useMainTag or hasAlts then
                    necessaryGap = " ";
                else
                    mainDisplay = "";
                end
            end

            -- Only color it if needed.
            if GRM.S().colorizeNames then
                hexCode , hasAlts = GRM.GetStringClassColorByName ( fullName );
            end        

            if mainName ~= "" and mainName ~= fullName then
                mainName = systemMsgHex .. "(|r" .. mainColoring .. GRM.SlimName ( mainName ) .. "|r" .. systemMsgHex .. ")|r " .. GRM_G.MainTagHexCode .. mainDisplay .. "|r";
            elseif mainName == fullName then
                if ( GRM.S().useMainTag or hasAlts ) then
                    mainName = GRM_G.MainTagHexCode .. mainDisplay .. "|r";
                else
                    mainName = "";
                end
            end

            result = systemMsgHex .. string.format ( "%s|Hplayer:%s|h[%s]|h|r" , hexCode , name , name ) .. necessaryGap .. mainName .. systemMsgHex .. " " .. GRM.L ( "has come online." );
        else
            -- Send it back regular format...
            result = msg;
        end
    else
        result = msg;
    end

    return result;
end

-- Method:          GRM.AddMainTagToGoneOfflineSystemMessage ( string )
-- What it Does:    Adds the main tag to the system message announce when a player goes offline and colorizes their names
-- Purpose:         Quality of life information.
GRM.AddMainTagToGoneOfflineSystemMessage = function ( msg )
    local breakIndex = string.find ( msg , " " );                  -- This format fits almost all
    if breakIndex == nil then
        breakIndex = string.find ( msg , "下線了。" );              -- Taiwanese
        if breakIndex == nil then
            breakIndex = string.find ( msg , "下线了。" );          -- Mandarin
        end
    end

    local fullName = GRM.AppendServerName ( string.sub ( msg , 1 , breakIndex - 1 ) );
    local includeMainTag = ( GRM_G.MainTagHexCode ~= "" and GRM.S().showMainName );
    local nameWithTag = "";
    local finalNameFormat = "";
    local hexCode = "";
    local necessaryTag = "";
    local hasAlts = false;

    if includeMainTag then
        nameWithTag , hasAlts = GRM.GetNameWithMainTags ( fullName , true , true , false , true );
        

        if GRM.S().useMainTag or hasAlts then
            necessaryTag = "|r";
        end
    end

    if GRM.S().colorizeNames then
        hexCode = GRM.GetStringClassColorByName ( fullName );
        necessaryTag = "|r";
    end

    if includeMainTag then
        if ( GRM.S().useMainTag or hasAlts ) then
            finalNameFormat = nameWithTag;
        else
            finalNameFormat = GRM.SlimName ( fullName );
        end
    else
        finalNameFormat = GRM.SlimName ( fullName );
    end

    return hexCode .. finalNameFormat .. necessaryTag .. string.sub ( msg , breakIndex );
end

-- Method:          GRM.ConfigureSystemMessages()
-- What it Does:    Checks all active windows to see if at least one has system messag
-- Purpose:         To be able to auto-manage system messages behind the scenes.
GRM.ConfigureSystemMessages = function()
    local tempNumber = tonumber ( CURRENT_CHAT_FRAME_ID );
    local result = false;
    local nameMatchingID = 0;
    local reportChannels = {};
    if not GRM.S() or ( GRM.S() and #GRM.S().reportChannel == 0 ) then
        reportChannels = { DEFAULT_CHAT_FRAME.name };
    else
        reportChannels = GRM.S().reportChannel;
    end
    local name = "";

    for i = 1 , FCF_GetNumActiveChatFrames() do
        name = GetChatWindowInfo ( i );
        CURRENT_CHAT_FRAME_ID = i;

        -- If customChannel then
        if nameMatchingID == 0 then
            for j = #reportChannels , 1 , -1 do
                if reportChannels[j] == name then
                    nameMatchingID = i;
                    break;
                end
            end
        end

        if IsListeningForMessageType ( "SYSTEM" ) then
            result = true;
            break;
        end
    end

    -- Ok setting the system messages on at least to configured window.
    if not result and nameMatchingID ~= 0 then
        CURRENT_CHAT_FRAME_ID = nameMatchingID;
    end

    -- Reset back to default
    CURRENT_CHAT_FRAME_ID = tempNumber;
    return result;
end

-- Method:          GRM.SetGuildInfoDetails()
-- Purpose:         Calls the server info on the guild and parses out the number of exact unique accounts are in the guild. It also filters the chat msg to avoid chat spam, then unfilters it immediately after
--                  as a Quality of Life feature so the user can manually continue to call as needed.
-- Purpose:         It is useful information to know how many unique acocunts are in the guild. This particularly is useful when comparing how many "mains" there 
--                  are on the audit window...
GRM.SetGuildInfoDetails = function()
    GRM_G.MsgFilterDelay = true;         -- Resets the 1 second timer upon calling this method for the chat spam blocking. This ensures player manual calls are visual, but code calls are filtered.

    GRM.ConfigureGuild();

    if not GRM_G.MsgFilterEnabled then   -- Gate to ensure this only is registered one time. This is also controlled here so as to not waste resources by being called needlessly if player never checks audit window
        GRM_G.MsgFilterEnabled = true;   -- Establishing boolean gate so it is only registered once.
        ChatFrame_AddMessageEventFilter ( "CHAT_MSG_SYSTEM" , GRM.SetSystemMessageFilter );
    end

    -- Enable System Messages if Disabled.
    GRM.ConfigureSystemMessages();

    GuildInfo();
    -- This should only be blocked momentarily.
    C_Timer.After ( 2 , function()
        GRM_G.MsgFilterDelay = false;
    end);
end

-- Method:          GRM.GetAllGuildiesOnline( boolean )
-- What it Does:    Returns a table of names of all guildies that are currently online in the guild
-- Purpose:         Group management info and reporting. Pretty much some UI features, but possibly will be expanded upon.
GRM.GetAllGuildiesOnline = function( fullNameNeeded )
    if not GRM.IsCalendarEventEditOpen() then
        GRM.GuildRoster();
    end
    local listOfNames = {};
    for i = 1 , GRM.GetNumGuildies() do
        local name , _ , _ , _ , _ , _ , _ , _ , online = GetGuildRosterInfo ( i );
        if online then
            if name ~= nil then
                if not fullNameNeeded then
                    table.insert ( listOfNames , GRM.SlimName ( name ) );
                else
                    table.insert ( listOfNames , name );
                end
            end
        end
    end
    return listOfNames;
end

-- Method:          GRM.GetAuditLinePlayervalues ( array , boolean )
-- What it Does:    Collections the JoinDateText, the Promo, and the main Status text for use of the audit window
-- Purpose:         Easily callable function for reuse in parsing player data for the audit system.
GRM.GetAuditLinePlayervalues = function ( data , isComplete )
    local joinDate , promoDate , mainStatus = "" , "" , "";
    local classColors = {};
    local player;

    if type ( data ) == "string" then
        player = GRM.GetPlayer ( data );
    else
        player = data;
    end
    
    -- Join date
    if #player.joinDateHist[1][4] == 1 then
        if player.joinDateUnknown then
            joinDate = GRM.L ( "Unknown" );
            if GRM.S().unknownIsComplete then
                isComplete = false;
            end
        else
            joinDate = GRM.L ( "No Date Set" );
            isComplete = false;
        end
    else
        joinDate = GRM.DateUntrustedTag ( player.joinDateHist[1][6] ) .. GRM.FormatTimeStamp ( { player.joinDateHist[1][1] , player.joinDateHist[1][2] , player.joinDateHist[1][3] } , false );
    end

    -- Promo Date
    if player.promoteDateUnknown then
        promoDate = GRM.L ( "Unknown" );
        if GRM.S().unknownIsComplete then
            isComplete = false;
        end
    elseif #player.rankHist[1][5] == 1 then
        promoDate = GRM.L ( "No Date Set" );
        isComplete = false;
    else
        promoDate = GRM.DateUntrustedTag ( player.rankHist[1][7] ) .. GRM.FormatTimeStamp ( { player.rankHist[1][2] , player.rankHist[1][3] , player.rankHist[1][4] } , false );
    end

    -- Main or Alt
    if player.isMain then
        mainStatus = ( GRM.L ( "Main" ) );
    else
        -- Ok, they are not the main... do they have alts? If they have alts, we should see if one of them is listed as main.
        if player.altGroup ~= "" then   -- Player has alts!!

            -- No one is listed as "main" in alt grouping.
            if GRM_Alts[GRM_G.guildName][player.altGroup].main == "" then
                mainStatus = GRM.L ( "Main or Alt?" ) ;
                isComplete = false;
            else
                mainStatus = GRM.L ( "Alt" );
            end
        else
            mainStatus = GRM.L ( "Main or Alt?" );
            isComplete = false;
        end
    end

    -- Class Color
    classColors = GRM.GetClassColorRGB ( player.class );

    -- Birthdate
    local birthDate = "";

    if player.events[2][1][1] == 0 then
        if player.birthdayUnknown then
            birthDate = GRM.L ( "Unknown" );
            if GRM.S().unknownIsComplete then
                isComplete = false;
            end
        else
            birthDate = GRM.L ( "No Date Set" );
            isComplete = false;
        end
    else
        birthDate = GRM.FormatTimeStamp ( { player.events[2][1][1] , player.events[2][1][2] , player.events[2][1][3] } , false , true  );
    end

    -- Whether to even bother including them in the audit
    if not GRM.S().includeBirthdaysInAudit then
        isComplete = false;
    end
   
    return joinDate , promoDate , mainStatus , isComplete , classColors , birthDate;
end


-- Method:          GRM.GetAllGuildiesInOrder ( boolean , boolean )
-- What it Does:    Returns a sorted string array of all guildies
-- Purpose:         Useful to have an alphabetized list of guildies :)
 GRM.GetAllGuildiesInOrder = function( fullNameNeeded , fromAtoZ )
    if not GRM.IsCalendarEventEditOpen() then
        GRM.GuildRoster();
    end
    local listOfGuildies = {};
    local joinDate = "";
    local promoDate = "";
    local mainStatus = "";
    local isComplete = true;
    local classColors = {};
    local birthDate = "";
    local name = "";

    for _ , player in pairs ( GRM.GetGuild() ) do
        if type ( player ) == "table" then
            -- proper name format
            name = player.name;

            if not fullNameNeeded then
                name = GRM.SlimName ( name );
            end

            joinDate , promoDate , mainStatus , isComplete , classColors , birthDate = GRM.GetAuditLinePlayervalues ( player , isComplete );

            table.insert ( listOfGuildies , { name , joinDate , promoDate , mainStatus , classColors , birthDate } );
        end
    end

    sort ( listOfGuildies , function ( a , b ) return a[1] < b[1] end );

    if not fromAtoZ then
        local tempList = {};
        for i = #listOfGuildies , 1 , -1 do
            table.insert ( tempList , listOfGuildies[i] );
        end
        listOfGuildies = tempList;
    end
    return listOfGuildies , isComplete;
end

-- Method:          GRM.GetAllGuildiesInJoinDateOrder ( boolean , boolean )
-- What it Does:    Returns a sorted string array of all guildies in either ascending or descending order of when they joined the guild.
-- Purpose:         For sorting the audit window and keeping track of guildies...
GRM.GetAllGuildiesInJoinDateOrder = function ( fullNameNeeded , newFirst )
    local result = {};
    local listOfGuildiesWithDates = {};
    local listOfGuildiesWithUnknownDates = {};
    local name = "";
    local joinDate = "";
    local promoDate = "";
    local mainStatus = "";
    local isComplete = true;
    local classColors = {};
    local birthDate = "";

    for _ , player in pairs ( GRM.GetGuild() ) do
        if type ( player ) == "table" then
            joinDate , promoDate , mainStatus , isComplete , classColors , birthDate = GRM.GetAuditLinePlayervalues ( player , isComplete );

            if #player.joinDateHist[1][4] > 1 then

                local standardTime = tonumber ( player.joinDateHist[1][4] );

                -- find a proper place to sort
                if #listOfGuildiesWithDates == 0 then                               -- the first one can be a straight insert
                    table.insert ( listOfGuildiesWithDates , { player.name , standardTime , joinDate , promoDate , mainStatus , classColors , birthDate } );
                else
                    -- parse through the dates, new First... (number will be larger)
                    local j = 1;
                    while j <= #listOfGuildiesWithDates and standardTime < listOfGuildiesWithDates[j][2] do
                        j = j + 1;
                    end
                    if j == #listOfGuildiesWithDates + 1 then
                        table.insert ( listOfGuildiesWithDates , { player.name , standardTime , joinDate , promoDate , mainStatus , classColors , birthDate } );
                    else
                        table.insert ( listOfGuildiesWithDates , j , { player.name , standardTime , joinDate , promoDate , mainStatus , classColors , birthDate } );
                    end
                end
            else
                table.insert ( listOfGuildiesWithUnknownDates , { player.name , joinDate , promoDate , mainStatus , classColors , birthDate } );
            end
        end
    end

    -- Sort the unknowns to be added at the end
    sort ( listOfGuildiesWithUnknownDates , function ( a , b ) return a[1] < b[1] end );

    if not newFirst then
        -- need to reverse
        for i = #listOfGuildiesWithDates , 1 , -1 do
            name = listOfGuildiesWithDates[i][1];
            if not fullNameNeeded then
                name = GRM.SlimName ( name );
            end
            
            table.insert ( result , { name , listOfGuildiesWithDates[i][3] , listOfGuildiesWithDates[i][4] , listOfGuildiesWithDates[i][5] , listOfGuildiesWithDates[i][6] , listOfGuildiesWithDates[i][7]} );

        end
    else
        for i = 1 , #listOfGuildiesWithDates do
            name = listOfGuildiesWithDates[i][1];
            if not fullNameNeeded then
                name = GRM.SlimName ( name );
            end

            table.insert ( result , { name , listOfGuildiesWithDates[i][3] , listOfGuildiesWithDates[i][4] , listOfGuildiesWithDates[i][5] , listOfGuildiesWithDates[i][6] , listOfGuildiesWithDates[i][7] } );
        end
    end
    
    -- let's add the sorted unknowns to the end now as well.
    for i = 1 , #listOfGuildiesWithUnknownDates do

        name = listOfGuildiesWithUnknownDates[i][1];
        if not fullNameNeeded then
            name = GRM.SlimName ( name );
        end
        
        table.insert ( result , { name , listOfGuildiesWithUnknownDates[i][2] , listOfGuildiesWithUnknownDates[i][3] , listOfGuildiesWithUnknownDates[i][4] , listOfGuildiesWithUnknownDates[i][5] , listOfGuildiesWithUnknownDates[i][6] } );
    end
    return result , isComplete;
end

-- Method:          GRM.GetAllGuildiesInPromoDateOrder ( boolean , boolean )
-- What it Does:    Returns a sorted string array of all guildies in either ascending or descending order of when they were promoted last in the guild.
-- Purpose:         For sorting the audit window and keeping track of guildies...
GRM.GetAllGuildiesInPromoDateOrder = function ( fullNameNeeded , newFirst )
    local result = {};
    local listOfGuildiesWithDates = {};
    local listOfGuildiesWithUnknownDates = {};
    local name = "";
    local joinDate = "";
    local promoDate = "";
    local mainStatus = "";
    local isComplete = true;
    local classColors = {};
    local birthDate = "";

    for _ , player in pairs ( GRM.GetGuild() ) do
        if type ( player ) == "table" then
            joinDate , promoDate , mainStatus , isComplete , classColors , birthDate = GRM.GetAuditLinePlayervalues ( player , isComplete );

            if #player.rankHist[1][5] > 1 then
                -- find a proper place to sort
                local standardTime = tonumber ( player.rankHist[1][5] );

                if #listOfGuildiesWithDates == 0 then                               -- the first one can be a straight insert
                    table.insert ( listOfGuildiesWithDates , { player.name , standardTime , joinDate , promoDate , mainStatus , classColors , birthDate } );
                else
                    -- parse through the dates, new First... (number will be larger)
                    local j = 1;
                    while j <= #listOfGuildiesWithDates and standardTime < listOfGuildiesWithDates[j][2] do
                        j = j + 1;
                    end
                    if j == #listOfGuildiesWithDates + 1 then
                        table.insert ( listOfGuildiesWithDates , { player.name , standardTime , joinDate , promoDate , mainStatus , classColors , birthDate } );
                    else
                        table.insert ( listOfGuildiesWithDates , j , { player.name , standardTime , joinDate , promoDate , mainStatus , classColors , birthDate } );
                    end
                end
            else
                table.insert ( listOfGuildiesWithUnknownDates , { player.name , joinDate , promoDate , mainStatus , classColors , birthDate } );
            end
        end
    end

    -- Sort the unknowns to be added at the end
    sort ( listOfGuildiesWithUnknownDates , function ( a , b ) return a[1] < b[1] end );

    if not newFirst then
        -- need to reverse
        for i = #listOfGuildiesWithDates , 1 , -1 do

            name = listOfGuildiesWithDates[i][1];
            if not fullNameNeeded then
                name = GRM.SlimName ( name );
            end
            table.insert ( result , { name , listOfGuildiesWithDates[i][3] , listOfGuildiesWithDates[i][4] , listOfGuildiesWithDates[i][5] , listOfGuildiesWithDates[i][6] , listOfGuildiesWithDates[i][7] } );

        end
    else
        for i = 1 , #listOfGuildiesWithDates do

            name = listOfGuildiesWithDates[i][1];
            if not fullNameNeeded then
                name = GRM.SlimName ( name );
            end
            table.insert ( result , { name , listOfGuildiesWithDates[i][3] , listOfGuildiesWithDates[i][4] , listOfGuildiesWithDates[i][5] , listOfGuildiesWithDates[i][6] , listOfGuildiesWithDates[i][7] } );

        end
    end
    
    -- let's add the sorted unknowns to the end now as well.
    for i = 1 , #listOfGuildiesWithUnknownDates do
        name = listOfGuildiesWithUnknownDates[i][1];
        if not fullNameNeeded then
            name = GRM.SlimName ( name );
        end
        
        table.insert ( result , { name , listOfGuildiesWithUnknownDates[i][2] , listOfGuildiesWithUnknownDates[i][3] , listOfGuildiesWithUnknownDates[i][4] , listOfGuildiesWithUnknownDates[i][5] , listOfGuildiesWithUnknownDates[i][6] } );
    end
    return result , isComplete;
end

-- Method:          GRM.GetAllMainsAndAltsInOrder ( boolean )
-- What it Does:    Returns the guild roster sorted with either mains first or alts alphebatized, then alphabetizes the rest.
-- Purpose:         Auditing the roster and sorting!
GRM.GetAllMainsAndAltsInOrder = function ( mainsFirst )
    local result = {};
    local listOfMains = {};
    local listOfAlts = {};
    local listOfNeither = {};
    local joinDate = "";
    local promoDate = "";
    local mainStatus = "";
    local isComplete = true;
    local classColors = {};
    local birthDate = "";

    for _ , player in pairs ( GRM.GetGuild() ) do
        if type ( player ) == "table" then
            joinDate , promoDate , mainStatus , isComplete , classColors , birthDate = GRM.GetAuditLinePlayervalues ( player , isComplete );

            if player.isMain then
                table.insert ( listOfMains , { player.name , joinDate , promoDate , mainStatus , classColors , birthDate } );     -- Can just add if main.

            elseif player.altGroup ~= "" then                       -- if not main, but you do have alts, scan through the alts to see if they are a main.

                if GRM_Alts[GRM_G.guildName][player.altGroup].main ~= "" then
                    table.insert ( listOfAlts , { player.name , joinDate , promoDate , mainStatus , classColors , birthDate } );
                else
                    table.insert ( listOfNeither , { player.name , joinDate , promoDate , mainStatus , classColors , birthDate } );
                end
            else
                table.insert ( listOfNeither , { player.name , joinDate , promoDate , mainStatus , classColors , birthDate } );
            end
        end
    end

    sort ( listOfMains , function ( a , b ) return a[1] < b[1] end );
    sort ( listOfAlts , function ( a , b ) return a[1] < b[1] end );
    sort ( listOfNeither , function ( a , b ) return a[1] < b[1] end );

    -- Combine the tables...
    if mainsFirst then
        result = listOfMains;
        for i = 1 , #listOfAlts do
            table.insert ( result , listOfAlts[i] );
        end
    else
        result = listOfAlts;
        for i = 1 , #listOfMains do
            table.insert ( result , listOfMains[i] );
        end
    end

    for i = 1 , #listOfNeither do
        table.insert ( result , listOfNeither[i] );
    end
    return result , isComplete;
end

-- Method:          GRM.GetAllGuildiesByBirthdayDateOrder ( boolean , boolean )
-- What it Does:    Returns a sorted string array of all guildies in either ascending or descending order of when their birthday is
-- Purpose:         For sorting the audit window and keeping track of guildies...
GRM.GetAllGuildiesByBirthdayDateOrder = function ( fullNameNeeded , newFirst )
    local result = {};
    local listOfGuildiesWithDates = {};
    local listOfGuildiesWithUnknownDates = {};
    local name = "";
    local joinDate = "";
    local promoDate = "";
    local mainStatus = "";
    local isComplete = true;
    local classColors = {};
    local birthdate = "";

    for _ , player in pairs ( GRM.GetGuild() ) do
        if type ( player ) == "table" then
            joinDate , promoDate , mainStatus , isComplete , classColors , birthdate = GRM.GetAuditLinePlayervalues ( player , isComplete );
            
            if GRM.S().includeBirthdaysInAudit then
                
                if player.events[2][1][1] ~= 0 then
                    -- find a proper place to sort
                    local timestamp = daysBeforeMonthEnum [ tostring ( player.events[2][1][2] ) ] + player.events[2][1][1];

                    if #listOfGuildiesWithDates == 0 then                               -- the first one can be a straight insert
                        table.insert ( listOfGuildiesWithDates , { player.name , timestamp , joinDate , promoDate , mainStatus , classColors , birthdate } );
                    else
                        -- parse through the dates, new First... (number will be larger)
                        local j = 1;
                        while j <= #listOfGuildiesWithDates and timestamp < listOfGuildiesWithDates[j][2] do
                            j = j + 1;
                        end
                        if j == #listOfGuildiesWithDates + 1 then
                            table.insert ( listOfGuildiesWithDates , { player.name , timestamp , joinDate , promoDate , mainStatus , classColors , birthdate } );
                        else
                            table.insert ( listOfGuildiesWithDates , j , { player.name , timestamp , joinDate , promoDate , mainStatus , classColors , birthdate } );
                        end
                    end
                else
                    table.insert ( listOfGuildiesWithUnknownDates , { player.name , joinDate , promoDate , mainStatus , classColors , birthdate } );
                end
            else
                -- Birthdays are disabled...
                table.insert ( listOfGuildiesWithUnknownDates , { player.name , joinDate , promoDate , mainStatus , classColors , birthdate } );
            end
        end
    end

    -- Sort the unknowns to be added at the end
    sort ( listOfGuildiesWithUnknownDates , function ( a , b ) return a[1] < b[1] end );

    if not newFirst then
        -- need to reverse
        for i = #listOfGuildiesWithDates , 1 , -1 do

            name = listOfGuildiesWithDates[i][1];
            if not fullNameNeeded then
                name = GRM.SlimName ( name );
            end
            table.insert ( result , { name , listOfGuildiesWithDates[i][3] , listOfGuildiesWithDates[i][4] , listOfGuildiesWithDates[i][5] , listOfGuildiesWithDates[i][6] , listOfGuildiesWithDates[i][7] } );

        end
    else
        for i = 1 , #listOfGuildiesWithDates do

            name = listOfGuildiesWithDates[i][1];
            if not fullNameNeeded then
                name = GRM.SlimName ( name );
            end
            table.insert ( result , { name , listOfGuildiesWithDates[i][3] , listOfGuildiesWithDates[i][4] , listOfGuildiesWithDates[i][5] , listOfGuildiesWithDates[i][6] , listOfGuildiesWithDates[i][7] } );

        end
    end
    
    -- let's add the sorted unknowns to the end now as well.
    for i = 1 , #listOfGuildiesWithUnknownDates do
        name = listOfGuildiesWithUnknownDates[i][1];
        if not fullNameNeeded then
            name = GRM.SlimName ( name );
        end
        
        table.insert ( result , { name , listOfGuildiesWithUnknownDates[i][2] , listOfGuildiesWithUnknownDates[i][3] , listOfGuildiesWithUnknownDates[i][4] , listOfGuildiesWithUnknownDates[i][5] , listOfGuildiesWithUnknownDates[i][6] } );
    end
    return result , isComplete;
end

-- Method:          GRM.GetListOfGuildies( bool )
-- What it Does:    Returns a list of all current members of the guild in alphabetical order
-- Purpose:         Occasionally you want a list of guild members.
GRM.GetListOfGuildies = function( slimName )
    local list = {};
    local name;

    for i = 1 , GetNumGuildMembers() do
        name = GetGuildRosterInfo ( i );

        if slimName then
            name = GRM.SlimName ( name );
        end

        table.insert ( list , name );
    end
    sort ( list );

    return list;
end

-- Method:          GRM.GetAllCurrentAndFormerGuildies( boolean , boolean )
-- What it Does:    Collects the names and class of every player currently in the guild, formerly in the guild in database, and sorts the 2D array alphabetically
-- Purpose:         This will be useful when adding people manually to ban list for auto-complete
GRM.GetAllCurrentAndFormerGuildies = function( getCurrent , getFormer )
    local result = {};
    local guildData = GRM.GetGuild();

    if getCurrent then
        guildData = GRM.GetGuild();
        -- First, grab those currently in the guild
        for _ , player in pairs ( guildData ) do
            if type ( player ) == "table" then
                table.insert ( result , { player.name , player.class } );
            end
        end
    end

    if getFormer then
        -- Nemembert, grab those not in the guild
        guildData = GRM.GetFormerMembers();
        for _ , player in pairs ( guildData ) do
            if type ( player ) == "table" then
                table.insert ( result , { player.name , player.class } );
            end
        end
    end

    -- Now we sort "Complemember" table
    sort ( result , function ( a , b ) return a[1] < b[1] end );    -- Alphabetizing it for easier parsing for buttontemembert updating. - This sorts the first indemember of the 2D array

    return result;
end

-- Method:          GRM.RemoveSpecialCharacters ( string )
-- What it Does:    Replaces all the special alt characters with English alphabet chars
-- Purpose:         Allows the autocomplete search of a player to provide results without needing to know special chars
GRM.RemoveSpecialCharacters = function( word )
    local result = word;
    local listOfChars = {  { "Ç" , "c" } , { "ü" , "u" } , { "é" , "e" } , { "â" , "a" } ,
                        { "ä" , "a" } , { "à" , "a" } , { "å" , "a" } , { "ç" , "c" } , { "ê" , "e" } ,
                        { "ë" , "e" } , { "è" , "e" } , { "ï" , "i" } , { "î" , "i" } , { "ì" , "i" } ,
                        { "Ä" , "a" } , { "Å" , "a" } , { "É" , "e" } , { "æ" , "ae" } ,
                        { "Æ" , "ae" } , { "ô" , "o" } , { "ö" , "o" } , { "ò" , "o" } , { "û" , "u" } ,
                        { "ù" , "u" } , { "ÿ" , "y" } , { "Ö" , "o" } , { "Ü" , "u" } , { "¢" , "c" } ,
                        { "á" , "a" } , { "í" , "i" } , { "ó" , "o" } , { "ú" , "u" } , { "ñ" , "n" } ,
                        { "Ñ" , "n" } , { "Θ" , "o" } , { "Á" , "a" } , { "Â" , "a" } , { "À" , "a" } ,
                        { "ã" , "a" } , { "Ã" , "a" } , { "Ð" , "d" } , { "Ê" , "e" } , { "Ë" , "e" } ,
                        { "È" , "e" } , { "Í" , "i" } , { "Î" , "i" } , { "Ï" , "i" } , { "Ó" , "o" } ,
                        { "ß" , "b" } , { "Ô" , "o" } , { "Ò" , "o" } , { "õ" , "o" } , { "Õ" , "o" } ,
                        { "µ" , "u" } , { "Ú" , "u" } , { "Û" , "u" } , { "Ù" , "u" } , { "ý" , "y" } ,
                        { "Ý" , "y" } };
    
    for i = 1 , #listOfChars do
        result = string.gsub ( result , listOfChars[i][1] , listOfChars[i][2] );
    end

    return result;
end

-- NOTE: This is assuming 2D arrays and match is at index [i][1]
-- Method:          GRM.GetAutoCompleteMatches ( array , string )
-- What it Does:    This scans through the given list and returns a new list with only the string matched items.
-- Purpose:         Useful for auto-complete filtering.
GRM.GetAutoCompleteMatches = function ( list , key , maxResult )
    local result = {};
    if key == "" then
        return result;
    end
    key = string.lower ( key );
    
    for i = 1 , #list do
        
        if string.find ( GRM.RemoveSpecialCharacters ( string.lower ( list[i][1] ) ) , key , 1 , true ) or string.find ( string.lower ( list[i][1] ) , key , 1 , true ) then
            table.insert ( result , list[i] );
        end

        if maxResult ~= nil and maxResult == #result then
            break;
        end
    end

    return result;
end

-- Method:          GRM.GetNumGuildiesOnline()
-- What it Does:    Returns the int number of players currently online, with option to include those only on mobile, but not physically in the game, or not.
-- Purpose:         So on mouseover, the index on the roster call can be determined properly as online people are indexed first.
GRM.GetNumGuildiesOnline = function()
    return select ( 2 , GetNumGuildMembers() );
end

-- Method:          GRM.GetGuildMemberRankID ( string )
-- What it does:    Returns the rank index of the given player's name, or 0 if unable to find player
-- Purpose:         Rank needs to be known in certain circumstances, like knowing if something was a promotion or a demotion.
GRM.GetGuildMemberRankID = function( name )
    local result = -1;
    -- Prevents errors if the other players sends a sync call too early, it will just ignore it.
    if GRM.GetGuild() and GRM.GetPlayer ( name ) then
        result = GRM.GetPlayer ( name ).rankIndex;
    end
    return result;
end

-- Method:          GRM.GetReputationTextLevel ( int , bool )
-- What it Does:    Returns the text name of a rank, localized
-- Purpose:         For use on the player mouseover window to reveal player guild rank.
GRM.GetReputationTextLevel = function ( index , includeColoring )
    local result = "";
    local color = "";
    if index == 8 then
        if includeColoring then
            color = "|cff00ffff";
        end
        result = color .. GRM.L ( "Exalted" ) .. "|r";
    elseif index == 7 then
        if includeColoring then
            color = "|cff00ffcc";
        end
        result = color .. GRM.L ( "Revered" ) .. "|r";
    elseif index == 6 then
        if includeColoring then
            color = "|cff00ff88";
        end
        result = color .. GRM.L ( "Honored" ) .. "|r";
    elseif index == 5 then
        if includeColoring then
            color = "|cff32CD32";
        end
        result = color .. GRM.L ( "Friendly" ) .. "|r";
    else
        if includeColoring then
            color = "|cffffff00";
        end
        result = color .. GRM.L ( "Neutral" ) .. "|r";
    end
    return result;
end

-- Method:          GRM.RegisterGuildChatPermission()
-- What it Does:    Initiates attempt to determine player has access to proper channel
-- Purpose:         If guild chat channel is restricted then sync cannot be enabled either...
GRM.RegisterGuildChatPermission = function()
    GRM_G.HasAccessToGuildChat = C_GuildInfo.CanSpeakInGuildChat();
    if GRM.CanEditOfficerNote() then
        GRM_G.HasAccessToOfficerChat = true;
    end
end

-- Method:          GRM.AddPlayerStatusCheck ( string , int )
-- What it Does:    Adds a player to the status check, to notify when they come Online!
-- Purpose:         Active tracking of changes within the guild on player status. Easy to notify you when someone comes online!
GRM.AddPlayerStatusCheck = function ( name , checkIndex )
    local isFound = false;
    local needsToActivateNotification = false;

    for i = 1 , #GRM_G.ActiveStatusQue do
        if name == GRM_G.ActiveStatusQue[i][1] and checkIndex == GRM_G.ActiveStatusQue[i][3] then
            isFound = true;
            break;
        end
    end

    -- Good, the notification has not already been set...
    if not isFound then
        -- Only need to activate if at zero loop resting state, not if it is already scanning something.
        if #GRM_G.ActiveStatusQue == 0 then
            needsToActivateNotification = true;
        end
        local player = GRM.GetPlayer ( name );
        if player then

            table.insert ( GRM_G.ActiveStatusQue , { name , player.isOnline , checkIndex } );
            -- Return from AFK
            if checkIndex == 1 then
                GRM.Report ( "|cffff0000" .. GRM.L ( "Notification Set:" ) .. " |r" .. GRM.L ( "Report When {name} is ACTIVE Again!" , GRM.GetClassifiedName ( name , true ) ) );
            -- Return from Offline
            elseif checkIndex == 2 then
                GRM.Report ( "|cffff0000" .. GRM.L ( "Notification Set:" ) .. " |r" .. GRM.L ( "Report When {name} Comes Online!" , GRM.GetClassifiedName ( name , true ) ) );
            -- Goes Offline
            elseif checkIndex == 3 then
                if name == GRM_G.addonUser then
                    GRM.Report ( GRM.L ( "Unable to notify yourself if you go offline." ) );
                    needsToActivateNotification = false;
                    table.remove ( GRM_G.ActiveStatusQue , #GRM_G.ActiveStatusQue );
                else
                    GRM.Report ( "|cffff0000" .. GRM.L ( "Notification Set:" ) .. " |r" .. GRM.L ( "Report When {name} Goes Offline!" , GRM.GetClassifiedName ( name , true ) ) );
                end
            end

        end
    else
        GRM.Report ( GRM.L ( "GRM:" ) .. " " .. GRM.L ( "Notification Has Already Been Arranged..." ) );
    end

    if needsToActivateNotification then
        GRM.NotificationIndependentChecker();
    end
end

-- Method:          GRM.IsGuildieOnline( string )
-- What it Does:    Lets you know if a guildie is currently online by returning true
-- Purpose:         It is useful to save resources and for knowledge to know if a player is currently online or not. No need to scan certain things wastefully if they are offline.
GRM.IsGuildieOnline = function ( name )
    if not GRM.IsCalendarEventEditOpen() then
        GRM.GuildRoster();
    end
    local result = false;

    if GRMsyncGlobals.offline then
        result = false;
    else
        for i = 1 , GRM.GetNumGuildies() do
            local fullName , _, _, _, _, _, _, _, online = GetGuildRosterInfo ( i );
            if name == fullName then
                result = online;
                break;
            end
        end
    end
    
    return result;
end

----------------------------------
----- SOCIAL API -----------------
----------------------------------

-- Method:          GRM.IsOnFriendsList ( string )
-- What it Does:    Returns true if the given player is on your friends list (not battle.net friends, just WOW only)
-- Purpose:         Useful to know as if a player leaves the guild, you can add them to a friends list, and if the player does not exist, it will say
--                  "Player Not Found" thus revealing that the player that left the guild either left the server too, or namechanged after leaving.
GRM.IsOnFriendsList = function ( fullName )
    local result = { false , false , "" , "" };
    for i = 1 , C_FriendList.GetNumFriends() do
        local player = C_FriendList.GetFriendInfoByIndex ( i );
        if player.name == fullName or player.name == GRM.SlimName ( fullName ) then
            result[1] = true;           -- They are on FriendsList
            result[2] = player.connected;       -- if that player happens to be online
            local trigger = GetPlayerInfoByGUID ( player.guid );                   -- you need to query server twice often to trigger it to work.
            trigger = select ( 2 , GetPlayerInfoByGUID ( player.guid ) );
            result[3] = trigger;
            result[4] = player.guid;
            break;
        end
    end
    return result;
end

-- Method:          GRM.SetplayersStillOnServer ( string , bool )
-- What it Does:    Builds the list of players that have left the guild but are still on the server... by triggering the GUID check, when it calls it again it will be refreshed.
-- Purpose:         Reliable way to see if player is on the server -- updated in BFA to be more responsive.
--                  Note -- players who have deleted a toon the GUID remains for restoration purposes, it seems. At least for some period of time.
GRM.SetplayersStillOnServer = function( playerNames , isBanCheck )

    if not isBanCheck then
        GRM_G.playersStillOnServer = {};
    else
        GRM_G.LeftBanPlayersStillOnServer = {};
    end

    for i = 1 , #playerNames do
        GRM.IsPlayerStillOnServerByGUID ( playerNames[i][1] , playerNames[i][2] , isBanCheck , true )
    end

    C_Timer.After ( 1 , function()
        for i = 1 , #playerNames do
            GRM.IsPlayerStillOnServerByGUID ( playerNames[i][1] , playerNames[i][2] , isBanCheck , false )
        end
    end);
end

-- Method:          GRM.IsPlayerStillOnServerByGUID ( string , string , bool , bool )
-- What it Does:    Returns true if the player is still on the server by checking their GUID. If no GUID info returned you can know they either deleted or transferred
-- Purpose:         Useful info to know when a player leaves or older list information.
GRM.IsPlayerStillOnServerByGUID = function ( name , guid , isBanCheck , firstCheck )

    if guid ~= nil and guid ~= "" and C_PlayerInfo.GUIDIsPlayer ( guid ) then
        local needToCallOnceToTrigger = GetPlayerInfoByGUID ( guid );

        if not needToCallOnceToTrigger then
            needToCallOnceToTrigger = GetPlayerInfoByGUID ( guid );
        end

        if not firstCheck then
            if needToCallOnceToTrigger then
                if not isBanCheck then
                    table.insert ( GRM_G.playersStillOnServer , name );
                else
                    table.insert ( GRM_G.LeftBanPlayersStillOnServer , name );
                end

            end
        end
    end

 end

 -- Method:         GRM.ValidateBanGUIDs( string )
 -- What it Does:   Checks against the given result from a Ban list GUID check and returns a list of the players whose info went missing.
 -- Purpose:        To be able to update the Ban Frames with relevant info on if player is still on the server or not on the fly.
 GRM.ValidateBanGUIDs = function ( textSearch )
    local currentBanList = GRM.GetSortedBanListNamesWithDetails ( textSearch );
    local result = {};
    local isFound = false;

    for i = 1 , #currentBanList do
        if currentBanList[i][9] ~= "" then
            isFound = false;
            for j = 1 , #GRM_G.LeftBanPlayersStillOnServer do
                if GRM_G.LeftBanPlayersStillOnServer[j] == currentBanList[i][1] then
                    isFound = true;
                    table.remove ( GRM_G.LeftBanPlayersStillOnServer , j );         -- Pure efficiency. Shrink the list
                    break;
                end
            end

            if not isFound then
                table.insert ( result , currentBanList[i][1] );
            end
        end

        -- Exist if the list is now empty
        if #GRM_G.LeftBanPlayersStillOnServer == 0 then
            break;
        end
    end
    
    return result;
 end

-- Method:          GRM.MiscCleanupOnLogin()
-- What it Does:    On player reload, it basically does a quick cleanup of any unfinished business
-- Purpose:         To fix actions that might have been unfinished or interrupted, but saved, so they can be cleaned up and restarted 
--                  without residual messes.
GRM.MiscCleanupOnLogin = function()
    if not GRM_G.MsgFilterEnabled then
        GRM_G.MsgFilterEnabled = true;   -- Establishing boolean gate so it is only registered once.
        ChatFrame_AddMessageEventFilter ( "CHAT_MSG_SYSTEM" , GRM.SetSystemMessageFilter );
    end

    -- Friends list actions...
    if GRM_Misc[GRM_G.addonUser] ~= nil then
        GRM_G.MsgFilterDelay = true
        for i = 1 , #GRM_Misc[GRM_G.addonUser] do
            if GRM_Misc[GRM_G.addonUser][i][1] then

                -- Friends List Fix
                if i == 1 then
                    C_Timer.After ( 1 , function()
                        for j = 1 , #GRM_Misc[GRM_G.addonUser][i][2] do
                            GRM_G.MsgFilterDelay = true
                            GRM_G.MsgFilterDelay2 = true;
                            C_FriendList.RemoveFriend ( GRM_Misc[GRM_G.addonUser][i][2][j] );
                            C_FriendList.RemoveFriend ( GRM.SlimName ( GRM_Misc[GRM_G.addonUser][i][2][j] ) );          -- On reload of the server, it refreshes the names and purges the server from some...
                        end
                        GRM_Misc[GRM_G.addonUser] = nil;
                    end);
                end

            end
        end
    end

    GRM_G.MsgFilterDelay = false;
    C_Timer.After ( 2 , function()
        GRM_G.MsgFilterDelay2 = false;
    end);
end

-- Method:          GRM.GetPlayersWithoutGUID();
-- What it Does:    Gets a list of names of all players no longer in the guild who do not have GUIDs
-- Purpose:         Necessary info to pull on a player to get their GUID
GRM.GetPlayersWithoutGUID = function()
    local result = {};
    local oldMemberData = GRM.GetFormerMembers();

    for name , player in pairs ( oldMemberData ) do
        if type ( player ) == "table" then
            if player.GUID == "" or player.class == "UNKNOWN" then
                table.insert ( result , name );
            end
        end
    end

    return result;
end

-- Method:          GRM.QueryPlayersGUIDByFriendsList ( array , int , boolean , boolean )
-- What it Does:    Adds players to friends list to determine their proper class and GUID
-- Purpose:         Pre-8.0 it was impossible to determine a player's GUID unless they were currently online. This is no longer the case. GUID is very useful.
GRM.QueryPlayersGUIDByFriendsList = function ( playerNames , initialValue , cleanUpNoLongers , reportClassChange )
    GRM_G.CheckingGUIDThroughFriendsList = true;
    C_Timer.After ( 1 , function()
        if not GRM_G.MsgFilterEnabled then
            GRM_G.MsgFilterEnabled = true;
            ChatFrame_AddMessageEventFilter ( "CHAT_MSG_SYSTEM" , GRM.SetSystemMessageFilter );
        end
        GRM_G.TempBanSystemMessage = true;
        local count = 0;

        if C_FriendList.GetNumFriends() < 100 then
            -- Add the names!!!
            -- Now, we use the friends list by cheating the server to get around the /who slow callback.
            local isFound = {};
            local startValue = initialValue or 1;       -- For some reason recursively it shows the initialValue as a nil, so reset it to 1
            GRM_G.TempListNamesAddedGUIDCheck = {};              -- This list will be used to determine who to remove from friend's list.
            if #playerNames > 0 then

                if GRM_Misc[GRM_G.addonUser] == nil then
                    GRM.ConfigureMiscForPlayer( GRM_G.addonUser );
                end

                GRM_Misc[GRM_G.addonUser][1] = { true , {} };      -- for backup incase player logs off in the middle of adding names...
                local toAddNumber = #playerNames;
                if C_FriendList.GetNumFriends() + #playerNames > 100 then 
                    toAddNumber = 100 - C_FriendList.GetNumFriends();
                end
                for i = 1 , toAddNumber do
                    if initialValue <= #playerNames then
                        isFound = GRM.IsOnFriendsList ( playerNames[initialValue] );

                        if not isFound[1] and C_FriendList.GetNumFriends() < 100 then
                            GRM_G.MsgFilterDelay2 = true;                            
                            C_FriendList.AddFriend ( playerNames[initialValue] );
                            table.insert ( GRM_G.TempListNamesAddedGUIDCheck , playerNames[initialValue] );
                        end
                        initialValue = initialValue + 1;
                    else
                        break;
                    end
                end
                GRM_Misc[GRM_G.addonUser][1][2] = GRM_G.TempListNamesAddedGUIDCheck;
            end

            -- Now we need to pull the data!!!
            C_Timer.After ( 1.5 , function()
                local isFound;
                local oldMemberData = GRM.GetFormerMembers();
                local player;
                
                for i = startValue , initialValue - 1 do                -- Minus one because it incremented up by 1 in the final C_FriendList.AddFriend for loop.
                    isFound = GRM.IsOnFriendsList ( playerNames[i] );
                    player = oldMemberData[playerNames[i]];
                    
                    -- isFound = { isOnFriendsList , isOnline , className , guid }
                    if isFound[1] then
                        if player then

                            if reportClassChange and player.name == GRM_G.CurrentBanSelectedName[1] and player.class ~= isFound[3] then
                                GRM.Report ( GRM.L ( "{name} plays the {custom1} class, not {custom2}." , GRM.GetClassColorRGB ( isFound[3] , true ) .. GRM.SlimName ( GRM_G.CurrentBanSelectedName[1] ) .. "|r" , nil , nil , GRM.GetClassColorRGB ( isFound[3] , true ) .. GRM.L ( GRM.FormatInputName( isFound[3] ) ) .. "|r" , GRM.GetClassColorRGB ( player.class , true ) .. GRM.GetClassName ( player.class ) .. "|r" ) );
                            end
                            player.class = isFound[3];               -- Updates Class properly
                            player.GUID = isFound[4];              -- Updates GUID since this was not obtainable until post 8.0 launch
                            count = count + 1;
                        end

                        GRM_G.MsgFilterDelay2 = true;
                        C_FriendList.RemoveFriend ( playerNames[i] );
                        C_FriendList.RemoveFriend ( GRM.SlimName ( playerNames[i] ) );   -- Non merged realm will not have the server name, so this avoids the "Player not found" error]

                    else
                        -- NEED TO REMOVE THEM FROM THE DATABASE
                        if cleanUpNoLongers then

                            if player then
                                if not player.bannedInfo[1] then
                                    oldMemberData[playerNames[i]] = nil;
                                else
                                    player.isUnknown = true
                                    if reportClassChange and player.name == GRM_G.CurrentBanSelectedName[1] then
                                        GRM.Report ( GRM.L ( "Unable to identify {name}. Ensure your spelling is accurate! Otherwise, they may have left the server." , GRM.GetClassColorRGB ( GRM_G.CurrentBanSelectedName[2] , true ) .. GRM_G.CurrentBanSelectedName[1] .. "|r" ) );
                                    end
                                end
                            end
                        end
                    end
                end

                -- In case it finds anything, it updates
                if count > 0 then
                    C_Timer.After ( 2 , GRM.RefreshBanListFrames );
                end

                -- Do a recursive re-check if necessary...
                if initialValue <= #playerNames then
                    GRM_G.CheckingGUIDThroughFriendsList = true;
                    GRM.QueryPlayersGUIDByFriendsList ( playerNames , initialValue , cleanUpNoLongers , reportClassChange );
                    return;
                else
                    GRM_G.CheckingGUIDThroughFriendsList = false;
                    C_Timer.After ( 2 , function()
                        GRM_G.MsgFilterDelay2 = false;
                        GRM_G.TempBanSystemMessage = false;
                    end);
                    -- FINISHED!!!
                end
                -- For restoring on logging off in middle of group friend adding...
                GRM_Misc[GRM_G.addonUser] = nil
            end);
        else
            C_Timer.After ( 2 , function()
                GRM_G.MsgFilterDelay2 = false;
            end);
            if not GRM_G.TooManyFriendsWarning then
                GRM_G.TooManyFriendsWarning = true;
                GRM.Report ( GRM.L ( "You currently are at {num} non-Battletag friends. To fully take advantage of all of GRM features, please consider clearing some room." , nil , nil , 100 ) );
            end
        end
    end);
end

-- Method:          GRM.DelayMinimapButtonOpen ( boolean )
-- What it Does:    Triggers the core GRM window only to open when hitting the minimap button if the player is out of combat, and then delays open if in combat.
-- Purpose:         To prevent accidental click of the minmap button if player is in combat.
GRM.DelayMinimapButtonOpen = function ( messageDisplayed , message2Displayed )
    
    if not GRM_G.inCombat and GRM.GetLog() ~= nil then
        GRM_G.minmapButtonDelay = false;
        -- Set Window Scales
    
        GRM_UI.GRM_RosterChangeLogFrame:Show();
    else
        if not message2Displayed and GRM.GetLog() == nil then
            GRM.Report ( GRM.L ( "Database Still Loading. GRM will open automatically when finished." ) );
            message2Displayed = true;
        end

        if GRM_G.inCombat and not messageDisplayed then
            GRM.Report ( GRM.L ( "GRM window will open when combat ends." ) );
            messageDisplayed = true;
        end
        GRM_G.minmapButtonDelay = true;
        C_Timer.After ( 1 , function()
            GRM.DelayMinimapButtonOpen ( messageDisplayed , message2Displayed );
        end);
    end
end

-- DEFAULT WARCRAFT CHANNELS
local channelEnum = {
    ["CHAT_MSG_GUILD"] = "Guild",
    ["CHAT_MSG_OFFICER"] = "Officer",
    ["CHAT_MSG_PARTY"] = "Party",
    ["CHAT_MSG_PARTY_LEADER"] = "Party Leader",
    ["CHAT_MSG_RAID"] = "Raid",
    ["CHAT_MSG_RAID_LEADER"] = "Raid Leader",
    ["CHAT_MSG_INSTANCE_CHAT"] = "Instance",
    ["CHAT_MSG_INSTANCE_CHAT_LEADER"] = "Instance Leader",
    ["CHAT_MSG_ACHIEVEMENT"] = "Achievement"
}

-- Method:          GRM.GetChannelType ( string )
-- What it Does:    Returns the type of channel, be it guild, be it anniversary, be it whatever. This returns all social chat channel types
-- Purpose:         A helper to identify new events in relation to chat monitoring.
GRM.GetChannelType = function ( channelName )
    local result = "";
    for key, y in pairs ( channelEnum ) do
        if y == channelName then
            result = key;
            result = string.gsub ( result , "CHAT_MSG_" , "" ); -- Parses out the CHAT_MSG_ and leaves the title.
            break;
        end
    end
    return result;
end

-- Method:          GRM.GetChatRGB ( string )
-- What it Does:    Returns the RGB color code for the given chat channel
-- Purpose:         Being able to create custom channels and match them to the player's settings is extremely useful for downstream plans.
GRM.GetChatRGB = function ( channel )
    local result = {};
    if ChatTypeInfo[ channel ] ~= nil then
        result = { ChatTypeInfo[channel].r , ChatTypeInfo[channel].g , ChatTypeInfo[channel].b , ChatTypeInfo[channel].colorNameByClass };
    end
    return result;
end

-- Method:          GRM.ShowCustomColorPicker ( float , float , float , float , int , function )
-- What it Does:    Established some default values for the colorpicker frame, and then shows it
-- Purpose:         One, to configure the color picker frames, and two, to create a universally recyclable function for all potential future colorpicker options as well.
GRM.ShowCustomColorPicker = function ( r , g , b , a , setting , callback )

    if setting == 98 then
        GRM_G.MainTagColor = true
    elseif setting == 99 then
        GRM_G.GroupInfoIconColor = true;
    else
        GRM_G.CurrentTagColorBox = setting;
    end

    ColorPickerFrame:SetColorRGB ( r , g , b );
    ColorPickerFrame.previousValues = { r , g , b , a };
    ColorPickerFrame.func, ColorPickerFrame.opacityFunc, ColorPickerFrame.cancelFunc = callback, callback, callback;
    GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_MainTagFormatMenu:Hide();
    ColorPickerFrame:Hide(); -- Need to run the OnShow handler.
    ColorPickerFrame:Show();
end

-- Method:          GRM.ColorSelectFrameTextureUpdate()
-- What it Does:    When on the ColorPickerWindow from the Options, this is the logic that updates on the fly and saves the colors as you go.
-- Purpose:         To establish the proper RGB coloring of the text in the General options tab
GRM.ColorSelectFrameTextureUpdate = function()
    local r , g , b = ColorPickerFrame:GetColorRGB();
    -- Texture Box
    if GRM_G.MainTagColor and GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame:IsVisible() then
        GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_ColorSelectOptionsFrame.GRM_OptionsTexture:SetColorTexture ( r , g , b , 1 );
        -- Update the dropdown window color too
        GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_MainTagFormatSelected.GRM_TagText:SetTextColor ( r , g , b , 1 );                  -- color for the box AND the dropdown selection on tag format

    elseif GRM_G.GroupInfoIconColor and GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_ModulesFrame:IsVisible() then
        GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_ModulesFrame.GRM_GroupInfoColorPickerFrame.GRM_GroupInfoOptionsTexture:SetColorTexture ( r , g , b , 1 );

    elseif GRM_G.CurrentTagColorBox > 0 then
        GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_LogExtraOptionsFrame[ "colorBoxTexture" .. GRM_G.CurrentTagColorBox ]:SetColorTexture ( r , g , b , 1 );
        GRM_UI.UpdateLogFilterTextColor ( r , g , b , GRM_G.CurrentTagColorBox );
        
    end

    if GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_ColorPickerR:IsVisible() then
        GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_ColorPickerR:SetText ( math.floor ( r * 255 ) );
        GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_ColorPickerR:Show();
        GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_ColorPickerG:SetText ( math.floor ( g * 255 ) );
        GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_ColorPickerG:Show();
        GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_ColorPickerB:SetText ( math.floor ( b * 255 ) );
        GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_ColorPickerB:Show();
    end
end

-- Method:          GRM.GetNameWithMainTags( ( string , boolean , boolean , boolean , boolean )
-- What it Does:    On refresh or any changes on the CalenderInviteFrame it resets the main/alt tags
-- Purpose:         This needs to be handled and refreshed constantly because any changes, even with the slider, it overwrites all script handlers. So 
--                  tags needs to be reapplied.
GRM.GetNameWithMainTags = function( name , slimName , includeMainOnAlts , includeAltTagIfMain , includeParentheses )
    local hasAlts = false;
    local player = GRM.GetPlayer ( name  );

    if GRM_G.MainTagHexCode ~= "" and player then
        local hexCode = GRM_G.MainTagHexCode;
        local mainDisplay = GRM.GetMainTags ( false , GRM.S().mainTagIndex );
        local altDisplay = GRM.GetAltTags ( false , GRM.S().mainTagIndex );

        local par1 , par2 = "" , "";
        if includeParentheses then
            par1 = "|r(";
            par2 = "|r)";
        end
        
        local needsSlimming = true;

        if player.isMain then
            needsSlimming = false;
            if slimName then
                name = ( GRM.SlimName ( name ) .. " " .. hexCode .. mainDisplay .. "|r" );     -- This player is the main
            else
                name = ( name .. " " .. hexCode .. mainDisplay .. "|r" );
            end
            if GRM.PlayerHasAlts ( player ) then
                hasAlts = true;
                GRM_G.IsAltGrouping = true;
            end
        elseif GRM.PlayerHasAlts ( player ) then
            hasAlts = true;
            GRM_G.IsAltGrouping = true;
            if player.altGroup ~= "" and GRM_Alts[GRM_G.guildName][player.altGroup].main ~= "" then
                needsSlimming = false;
                -- Formatting...
                if slimName then
                    name = GRM.SlimName ( name );  -- This player is not the main, but is part of a grouping with a player who is main
                end
                -- for alt tag to be added
                if includeAltTagIfMain then
                    name = name .. " " .. hexCode .. altDisplay .. "|r"; 
                end
                if includeMainOnAlts then
                    name = name .. " " .. par1 .. GRM.GetClassifiedName ( GRM_Alts[GRM_G.guildName][player.altGroup].main , slimName ) .. par2 .. " " .. hexCode .. mainDisplay .. "|r";
                end
            end
        end

        if needsSlimming and slimName then
            name = GRM.SlimName ( name );
        end

    end
    return name , hasAlts;
end

-- Method:          GRM.AddMainToChat ( ... )
-- What it Does:    It adds either a Main tag to the player, or if they are on an alt, includes the name of the main.
-- Purpose:         Easy to see player name in guild chat, for achievments and so on...
GRM.AddMainToChat = function( _ , event , msg , sender , ... )

    if IsInGuild() and GRM.S() ~= nil then
        local placeHolderMsg = msg;

        if sender ~= GRM_G.addonUser then
            if GRM.S().showMainName then
                local guildData = GRM.GetGuild();
                local channelName = channelEnum [ event ];
                local mainDisplay = GRM.GetMainTags ( false , GRM.S().mainTagIndex );
                -- Find the player in the guild!

                if guildData and ( mainDisplay == "" or ( mainDisplay ~= "" and not string.find ( msg , mainDisplay , 1 , true ) ) ) then
                    local player = guildData[sender];

                    if player then
                        -- Let's see if they are the main. If they are, no need to do anything...
                        if player.isMain then
                            if GRM.S().useMainTag then
                                -- Just add main tag...
                                msg = GRM_G.MainTagHexCode .. mainDisplay .. "|r " .. msg;
                            end
                        elseif GRM.PlayerHasAlts ( player ) then
                            local main = GRM.GetAltGroupMain ( player.altGroup );
                            if main ~= "" then
                                if channelName ~= "Achievement" then
                                    msg = GRM_G.MainTagHexCode .. mainDisplay .. "|r(" .. GRM.GetStringClassColorByName ( main ) .. GRM.FormatName ( main ) .. "|r): " .. msg;
                                else
                                    msg = GRM.GetStringClassColorByName ( main ) .. GRM.FormatName ( main ) .. "|r" .. GRM_G.MainTagHexCode .. mainDisplay .. "|r " .. msg;
                                end
                            end    
                        end
                    end
                end
            end
        end

        -- This will check if public note needs to be set.
        if GRM.S().noteSetEnabled and event == "CHAT_MSG_GUILD" or event == "CHAT_MSG_OFFICER" then
            GRM.TriggerPlayerNote ( sender , placeHolderMsg );
        end

        GRM.MessageHookControl();
    end

    return false , msg, sender, ...
end

-- Method:          GRM.RefreshMainTagHexCode()
-- What it Does:    Reconverts the RGB values, scales then, then converts to hexcode
-- Purpose:         So, this only needs to be configured one time on load, or when the player updates the settings.
GRM.RefreshMainTagHexCode = function()
    GRM_G.MainTagHexCode = GRM.rgbToHex ( { GRM.ConvertRGBScale ( GRM.S().mainTagColor.r , true ) , GRM.ConvertRGBScale ( GRM.S().mainTagColor.b , true ) , GRM.ConvertRGBScale ( GRM.S().mainTagColor.g , true ) } );

    GRM_G.mainTag = GRM.GetCurrentMainTag();
    GRM_G.altTag = GRM.GetCurrentAltTag();
end

-- Method:          GRM.GetMainTags();
-- What it Does:    Returns the table of potential main tags
-- Purpose:         For easy marking of alts/mains in gchat.
GRM.GetMainTags = function( returnTable , index )
    local tags = { "<" .. GRM.L ( "M" ) .. ">" , "(" .. GRM.L ( "M" ) .. ")" , "<" .. GRM.L ( "Main" ) .. ">" , "(" .. GRM.L ( "Main" ) .. ")" , "[" .. GRM.L ( "Main" ) .. "]" , "[" .. GRM.L ( "M" ) .. "]" , "" };
    if returnTable then
        return tags;
    else
        return tags[index];
    end
end

-- Method:          GRM.GetAltTags();
-- What it Does:    Returns the table of potential main tags
-- Purpose:         For easy marking of alts/mains in gchat.
GRM.GetAltTags = function( returnTable , index )
    local tags = { "<" .. GRM.L ( "A" ) .. ">" , "(" .. GRM.L ( "A" ) .. ")" , "<" .. GRM.L ( "Alt" ) .. ">" , "(" .. GRM.L ( "Alt" ) .. ")" , "[" .. GRM.L ( "Alt" ) .. "]" , "[" .. GRM.L ( "A" ) .. "]" , "" };
    if returnTable then
        return tags;
    else
        return tags[index];
    end
end

-- Method:          GRM.GetCurrentMainTag()
-- What it Does:    Returns the string, properly colored, of current main tag
-- Purpose:         Quality of life UI feature showing main tags.
GRM.GetCurrentMainTag = function()
    return GRM_G.MainTagHexCode .. GRM.GetMainTags ( false , GRM.S().mainTagIndex ) .. "|r";
end

-- Method:          GRM.GetCurrentAltTag()
-- What it Does:    Returns the string, properly colored, of current alt tag
-- Purpose:         Quality of life UI feature showing alt tags.
GRM.GetCurrentAltTag = function ()
    return GRM_G.MainTagHexCode .. GRM.GetAltTags ( false , GRM.S().mainTagIndex ) .. "|r";
end

-- Method:          GRM.RemoveMainAltTags ( string )
-- What it Does:    takes the name, and parses out both the string coloring and the main tag. There is ALWAYS hexcode, so "|" can be found.
-- Purpose:         Add Alt window has the tags added, this just retroactively removes them.
GRM.RemoveMainAltTags = function ( text )
    local index = string.find ( text , "|" )
    if index ~= nil then
        text = string.sub ( text , 1 , index - 1 );
    end
    return GRM.Trim ( text );
end

-- Method:          GRM.RemoveHexCodeColoringFromString ( string )
-- What it Does:    Removes the hexcopde coloring from any string - Example
-- Purpose:         Useful to parse out names for compatibility reasons for cross addon compatibility with the groupInfo module.
GRM.RemoveHexCodeColoringFromString = function ( text )
    local result = string.gsub ( text , "||r" , "" );    -- Firsr thing, remove the end coloring cuts
    local ind = string.find ( result , "||cff" , 1 , true );

    if not ind then
        ind = string.find ( result , "||CFF" , 1 , true ); 
    end

    while ( ind ~= nil ) do
        result = string.gsub ( result , string.sub ( result , ind , ind + 10 ) , "" );
        ind = string.find ( result , "||" , 1 , true );
    end

    return GRM.Trim ( result );
end

-- Method:          GRM.RemoveStringColoring(string)
-- What it Does:    Removes the HexTag Blizz uses to identify and color the text. Anything that starts with |cffxxxxxx
-- Purpose:         Clean up the texts for export so it is just plain text.
GRM.RemoveStringColoring = function( text )
    local start = string.find ( text , "\000" );
    if start ~= nil then
        text = string.sub ( text , 1 , start - 1 );
    end
    while ( string.find ( string.lower ( text ) , string.char(124) .. "cff" ) ~= nil ) do
        local index = string.find ( string.lower ( text ) , string.char(124) .. "cff" );
        text = string.sub ( text , 1 , index -1 ) .. string.sub ( text , index + 10 );
    end
    text = string.gsub ( text , string.char(124) .. "r" , "" );    -- if I use string.lower, it returns a full lower string. don't want that.
    text = string.gsub ( text , string.char(124) .. "R" , "" );

    return text;
end


-----------------------------------
-------- PROFESSIONS --------------
-----------------------------------


-- Nothing yet - possibly future or classic integration


-----------------------------------
--------- Version Tracking --------
--------- Addon User Tracking -----
-----------------------------------

-- Method:          GRM.VersionCheck ( string )
-- What it Does:    Checks player version compared to another player's and recommends updating your version if needed
-- Purpose:         Encourage the player to keep their addon up to date!
GRM.VersionCheck = function( msg )
    -- parse the message
    local version = string.match ( "msg" , "(.+)?" ) ;
    local time = tonumber ( GRM.Next ( msg ) );

    -- If the versions are not equal and the received data is larger (more recent) than player's time, player should receive reminder to update!
    if version ~= GRM_G.Version then
        
        if time > GRM_G.PatchDay then
            if GRM.S().syncCompatibilityMsg and not GRM_G.VersionChecked then
                GRM_G.VersionChecked = true;
                -- Let's report the need to update to the player!
                GRM.Report ( "|cff00c8ff" .. GRM.L ( "GRM:" ) .. " |cffffffff" .. GRM.L ( "A new version of Guild Roster Manager is Available!" ) .. " |cffff0044" .. GRM.L ( "Please Upgrade!" ) );
            end
            -- No need to send comm because he has the update, not you!

        elseif time < GRM_G.PatchDay then
            -- Your version is more up to date! Send comms out!
            C_ChatInfo.SendAddonMessage ( "GRMVER" , GRM_G.Version .. "?" .. GRM_G.PatchDayString , "GUILD" ); -- Remember, patch day is an int in epoch time, so needs to be converted to string for comms
        end
    end
end

-- Method:          GRM.RegisterVersionCheck()
-- What it Does:    Registers the logic for comm talk between addon users to do a version check.
-- Purpose:         Version checking! Encourages the player to upgrade their addon if it is outdated!
GRM.RegisterVersionCheck = function()
    -- Registering comm prefix, establishing event monitoring for comm activity across guild channel.
    C_ChatInfo.RegisterAddonMessagePrefix ( "GRMVER" );
    VersionCheck:RegisterEvent ( "CHAT_MSG_ADDON" );
    -- Register used prefixes!

    -- Setup tracking actions
    VersionCheck:SetScript ( "OnEvent" , function ( _ , event , prefix , msg , channel , sender )
        if event == "CHAT_MSG_ADDON" and prefix == "GRMVER" and channel == "GUILD" then
                -- Gotta filter my own messages out too!
            if sender ~= GRM_G.addonUser then
                -- Just to ensure it only does a check one time from each player with the addon installed.

                if not GRM_G.VersionCheckedNames[semder] then
                    GRM_G.VersionCheckedNames[sender] = true;
                else
                    GRM.VersionCheck ( msg );
                end
            end
        end
    end);
end

-- Method:          GRM.RegisterGuildAddonUsersRefresh ()
-- What it Does:    Two uses. One, it checks to see if all the people on the list of users with addon installed are still online, and if not, purges them
--                  and two, requests data from the players again to be updated. This is useful because players may change their settings.
-- Purpose:         To keep the UI up to date. It is necessary to refresh the info occasionally rather than just on login.
GRM.RegisterGuildAddonUsersRefresh = function ()              -- LoadRefresh is just OnShow() for the window, no need to have 10 sec delay as we are not oging to send requests, just purge the offlines.
    -- Purge the players that are no longer online...
    if time() - GRM_G.refreshAddonUserDelay >= 5 then
        GRM_G.refreshAddonUserDelay = time();
        local listOfNames = GRM.GetAllGuildiesOnline( true );
        local notFound = true;

        for i = 1 , #GRM_G.currentAddonUsers do
            notFound = true;
            for j = 1 , #listOfNames do
                if GRM_G.currentAddonUsers[i] ~= nil and listOfNames[j] ~= nil then
                    if listOfNames[j] == GRM_G.currentAddonUsers[i][1] then
                        notFound = false;
                        break;
                    end
                end
            end
            
            -- if notfound, purge em. They're no longer online...
            if notFound then
                table.remove ( GRM_G.currentAddonUsers , i );
            end
        end
        -- Request the updated info!
        C_ChatInfo.SendAddonMessage ( "GRMUSER" , "REQ?" , GRMsyncGlobals.channelName );
        

        -- Updating the frames. Giving 2 seconds to receive responses!
        if GRM_UI.GRM_RosterChangeLogFrame.GRM_AddonUsersFrame:IsVisible() then
            C_Timer.After ( 2 , function()
                if GRM_G.guildName ~= "" then
                    GRM.BuildAddonUserScrollFrame();
                end
            end);
        end
    end

end

-- Method:          GRM.AddonUserRegister ( string , string )
-- What it Does:    Analyzes to see if the addon user communicating with you is capable of syncing with you, as you could filter them or they could filter you.
-- Purpose:         Having a UI showing who has the addon, what version, if you can sync is just useful information. Not necessary for addon functionality, but is good for Quality of Life.
GRM.AddonUserRegister = function( sender , msg )

    if GRM_G.guildName ~= "" then
        local rankOfSender = GRM.GetGuildMemberRankID ( sender );
        local playerRankID = GRM.GetGuildMemberRankID ( GRM_G.addonUser )

        -- Error protection.
        if rankOfSender == -1 or playerRankID == -1 then
            return;
        end

        local senderBanRequirement = 0;
        local senderRankRequirement = 0;
        local result = "";
        local isGrouped = false;
        local badVersion = false;
        local syncEnabled = false;
        local exportAllRanks = false;
        local banDataOk = 1;
        local syncOk = false;
        local syncType = 1;

        -- Parsed Data
        local version = string.sub ( msg , 1 , string.find ( msg , "?" ) - 1 );
        msg = GRM.Next ( msg );
        local epochTimeVersion = tonumber ( string.sub ( msg , 1 , string.find ( msg , "?" ) - 1 ) );
        msg = GRM.Next ( msg ); -- Skipping old redundant info from older versions...

        if epochTimeVersion < GRM_G.PatchDay then
            result = "Outdated Version" -- Outdated Version.
            badVersion = true;
        elseif GRM_G.PatchDay < epochTimeVersion then
            result = "You Need Updated Version"; -- Your version outdated.
            badVersion = true;
        end

        if not badVersion then

            senderRankRequirement = tonumber ( string.sub ( msg , 1 , string.find ( msg , "?" ) - 1 ) );
            msg = GRM.Next ( msg );

            senderBanRequirement = tonumber ( string.sub ( msg , 1 , string.find ( msg , "?" ) - 1 ) );
            msg = GRM.Next ( msg );

            if string.sub ( msg , 1 , string.find ( msg , "?" ) - 1 ) == "true" then
                isGrouped = true;
            end
            msg = GRM.Next ( msg );
            
            if string.sub ( msg , 1 , string.find ( msg , "?" ) - 1 ) == "true" then
                syncEnabled = true;
            end
            
            if GRM.Next ( msg ) == "true" then
                exportAllRanks = true;
            end

            if syncEnabled then

                if isGrouped then
                    result = "Disabled While Player is Grouped";
                    
                else
                    -- The person you are syncing with their rank is too low.
                    if rankOfSender > GRM.S().syncRank then
                        if GRM.S().exportAllRanks then
                            result = "Sync Ok, but their rank is too low to make changes.";
                            syncOk = true;
                            syncType = 2;
                        else
                            result = "Their Rank is too Low. All data is restricted.";
                        end

                    elseif senderRankRequirement < playerRankID then
                        if exportAllRanks then
                            result = "Sync Ok, but your rank is too low to sync your changes.";
                            syncOk = true;
                            syncType = 3;
                        else
                            result = "Your Rank is too Low. Player is restricting all data."
                        end

                    else
                        result = "Syncing all player data.";
                        syncOk = true;
                    end

                    -- Ban
                    if rankOfSender > GRM.S().syncRankBanList then
                        banDataOk = 2;
                        if result == "Syncing all player data." then
                            result = "Syncing all data except ban list. Player rank is too low.";
                        end
                    elseif senderBanRequirement < playerRankID then
                        banDataOk = 3;
                        if result == "Syncing all player data." then
                            result = "Syncing all data except ban list. Your rank is too low.";
                        end
                    else
                        banDataOk = 1;
                    end
                end

            else
                result = "Player Sync Disabled"; -- Disabled
            end
        end
        
        -- Now, let's see if they are already in the table.
        local isFound = false;
        for i = 1 , #GRM_G.currentAddonUsers do
            if GRM_G.currentAddonUsers[i][1] == sender then
                GRM_G.currentAddonUsers[i][2] = result;
                GRM_G.currentAddonUsers[i][3] = version;
                GRM_G.currentAddonUsers[i][4] = epochTimeVersion;
                GRM_G.currentAddonUsers[i][5] = isGrouped;
                GRM_G.currentAddonUsers[i][6] = syncEnabled;
                GRM_G.currentAddonUsers[i][7] = exportAllRanks;
                GRM_G.currentAddonUsers[i][8] = banDataOk;  -- 1 = ok , 2 = Sender Not OK, 3 = You are not ok
                GRM_G.currentAddonUsers[i][9] = syncOk;
                GRM_G.currentAddonUsers[i][10] = syncType; -- 1 = ok , 2 = Only outgoing, 3 = Only Incoming
                isFound = true;
                break;
            end
        end

        if not isFound then
            table.insert ( GRM_G.currentAddonUsers , { sender , result , version , epochTimeVersion , isGrouped , syncEnabled , exportAllRanks , banDataOk , syncOk , syncType } );
            GRM.RegisterGuildAddonUsersRefresh();
        end
    end    
end

-- General Data, Ban Data , Reason

-- Method:          GRM.GetNumAddonUsersOutdated()
-- What it Does:    Returns the integer count of number of addon users with outdated addons
-- Purpose:         For easier reporting when a person tries to sync with outdated version of the addon.
GRM.GetNumAddonUsersOutdated = function()
    local result = 0;

    for i = 1 , #GRM_G.currentAddonUsers do
        if GRM_G.currentAddonUsers[i][4] < GRM_G.PatchDay then
            result = result + 1;
        end
    end

    return result;
end

-- Method:          GRM.GetNumAddonUsersAvailableToSync()
-- What it Does:    Checks available sync users
-- Purpose:         Useful to know for proper communication with addon user.
GRM.GetNumAddonUsersAvailableToSync = function()
    local count = #GRM_G.currentAddonUsers;

    for i = 1 , #GRM_G.currentAddonUsers do
        if not GRM_G.currentAddonUsers[i][6] or not GRM_G.currentAddonUsers[i][9] or GRM_G.currentAddonUsers[i][5] or GRM_G.currentAddonUsers[i][4] < GRM_G.PatchDay then
            count = count - 1;
        end
    end

    return count;
end

-- Method:          GRM_G.RegisterMessage()
-- What it Does:    Registers your current sync status to other GRM users in guild.
-- Purpose:         This is kept in its own function so it can be called whenever status changes, or as requested.4
GRM_G.RegisterMessage = function()
    if GRM.S() ~= nil then
        C_ChatInfo.SendAddonMessage ( "GRMUSER" , "REG?" .. GRM_G.Version .. "?" .. GRM_G.PatchDayString .. "?" .. tostring ( GRM.S().syncRank ) .. "?" .. tostring ( GRM.S().syncRankBanList ) .. "?" .. tostring ( IsInGroup() ) .. "?" .. tostring ( GRM.S().syncEnabled ) .. "?" .. tostring ( GRM.S().exportAllRanks ) , "GUILD" );
    end
end

-- Method           GRM.RegisterGuildAddonUsers()
-- What it Does:    Initiates the event listening for sync'd user addon info
-- Purpose:         So player can see who has the addon installed and if you are good to sync with each other and if not, why not.
GRM.RegisterGuildAddonUsers = function()

    -- Registering frames for event listening.
    C_ChatInfo.RegisterAddonMessagePrefix ( "GRMUSER" );
    AddonUsersCheck:RegisterEvent ( "CHAT_MSG_ADDON" );
    -- Event listening for addon talk on successful event found!
    AddonUsersCheck:SetScript ( "OnEvent" , function ( _ , event , prefix , msg , channel , sender )
        if event == "CHAT_MSG_ADDON" and prefix == "GRMUSER" and channel == "GUILD" and sender ~= GRM_G.addonUser then
            -- parse out the header
            local header = string.sub ( msg , 1 , string.find ( msg , "?" ) - 1 );
            msg = GRM.Next ( msg );
            if header == "REG" or header == "INIT" then
                GRM.AddonUserRegister ( sender , msg );

            elseif header == "REQ" then
                -- player is requesting info again. Sending update!
                GRM_G.RegisterMessage();

            elseif header == "GRM_MACRO_R" then
                if not GRMsyncGlobals.RulesSet then
                    GRMsync.MessageTracking = GRMsync.MessageTracking or CreateFrame ( "Frame" , "GRMsyncMessageTracking" );
                    GRMsync.BuildSyncNetwork ( true , true );
                else
                    GRM.MacroSyncSendTime();
                end
            end

        end
    end);

    -- Send out initial comms
    -- Name Version , epochTimestamp of update , string version of boolean if player restricts sync only to those with latest version of addon or higher. 
    GRM_G.RegisterMessage();
    -- Request for their data.
    GRM.RegisterGuildAddonUsersRefresh();
end

-- Method:          GRM.IsNumInString(string) 
-- What it Does:    Returns true if a numerical value is found in the form of a string.
-- Purpose:         Useful for player name submission, to verify if valid formatting.
GRM.IsNumInString = function( text )
    local numFound = false;
    for i = 1 , #text do
        if tonumber ( string.sub ( text , i , i ) ) ~= nil then
            -- NUM FOUND!
            numFound = true;
            break
        end
    end
    return numFound;
end

-- STILL NEED TO COMPLETE OTHER REGIONS' FONTS!!!!!!!!!!
-- Method:          GRM.IsValidName(string)
-- What it Does:    Returns true if the name only contains valid characters in it... based on ASCII numeric values
-- Purpose:         When player is manually adding someone to the player data, we need ot ensure only proper characters are allowed.
GRM.IsValidName = function ( name )
    local result = true;
    name = GRM.Trim ( name ); -- In case any whitespace before or after...
    for i = 1, #name do
        -- As a stopgap until I scan for all fonts, let's check this.
        local char = string.sub ( name , i , i );
        -- local byteValue = string.byte ( char );
        if tonumber ( char ) ~= nil or char == " " or char == "\\" or char == "\n" or char == ":" or char == "(" or char == "$" or char == "%" or char == "/" then
            return false;
        end

    end
    return result;
end

-- Method:          GRM.ByteRulesFollowed ( string , boolean , object [EditBox] )
-- What it Does:    It checks each char of the string for proper ASCII characters and if they are proper send messages and returns false if not, with optional error message
--                  in either the context of a string, or an editBox text
-- Purpose:         Certain characters if sent over Blizz's API can disconnect a character if not proper.
GRM.ByteRulesFollowed = function ( text , displayerErrorMessage , editBox )
    local result = true;
    local charValue;
    local count = 0;
    local warningGiven = false;

    for i = 1 , #text do
        charValue = string.byte ( text , i );
        if charValue < 32 then
            count = count + 1;
            result = false;

            if displayerErrorMessage and not warningGiven then
                warningGiven = true;
                if editBox then
                    GRM.Report ( GRM.L ( "The highlighted character is not valid for messages. Please remove." ) );
                    editBox:HighlightText ( i , i );
                    editBox:SetCursorPosition ( i + 1 );
                else
                    GRM.Report ( GRM.L ( "Not all characters are valid. Please remove any non-text characters." ) );
                end
            end
        end
    end
    return result;
end

-- Method:          GRM.UTF8char ( int , int )
-- What it Does:    Returns the number of bytes used by the UTF8 value
-- Purpose:         So as to maintain character count compatibility for all languages.
GRM.UTF8char = function ( s , i )
	i = i or 1

    local c = string.byte ( s , i );

	-- byte 1
	if c > 0 and c <= 127 then
		-- UTF8-1
		return 1

    -- byte 2
	elseif c >= 194 and c <= 223 then
		return 2

    -- byte 3
	elseif c >= 224 and c <= 239 then
		return 3

    -- byte 4
	elseif c >= 240 and c <= 244 then
		return 4
    end
    
end

-- Method:          GRM.UTF8Len ( string )
-- What it Does:    Returns the length of an input string.
-- Purpose:         So the addon can read the proper character length of text no matter the language.
GRM.UTF8Len = function ( s )

	local pos = 1
	local bytes = string.len (s)
	local len = 0

	while pos <= bytes do
		len = len + 1
		pos = pos + GRM.UTF8char ( s , pos )
	end

	return len
end

-- Method:          GRM.GetNumLetters ( text )
-- What it Does:    Returns the character count of the numLetters of a text string
-- Purpose:         Compatibility with ALL languages    
GRM.GetNumLetters = function ( text )
    local c = 0;

    if text ~= nil then
        c = GRM.UTF8Len ( text );
    end

    return c;
end

-- Method:          GRM.CapitalizeFirst ( string )
-- What it Does:    Formats the string properly to have the first letter of the word/name capitalized
-- Purpose:         Cleanup formatting of a name to prevent human error protection.
GRM.CapitalizeFirst = function( text )
    local count = 1;
    local byteCount = text:byte ( 1 );
    if byteCount == 195 or byteCount == 165 or byteCount == 208 then                -- Special cahracters some can be 2 bytes in length and they are given a value of 195 or 165 in Lua return
        count = 2;
    end
    
    if GRM.S().selectedLang < 9 then
        text = string.upper ( string.sub ( text , 1 , count ) ) .. string.sub ( text , count + 1 );
    end
    return text;
end

-- Method:          GRM.FormatInputName ( string )
-- What it Does:    Formats the name to proper pronoun form, but only if a non Asian character language
-- Purpose:         Huaman error protection on player input.
GRM.FormatInputName = function ( name )

    if string.find ( name , " " ) ~= nil then
        -- space found, multi word!!!
        local tempName = string.lower ( name );
        local result = "";
        local number = select ( 2 , string.gsub ( tempName , "%s" , "" ) );

        for i = 1 , number do
            result = result .. GRM.CapitalizeFirst ( string.sub ( tempName , 1 , string.find ( tempName , " " ) -1 ) .. " " );
            tempName = string.sub ( tempName , string.find ( tempName , " " ) + 1 );
            if i == number then
                result = result .. GRM.CapitalizeFirst( tempName );
            end
        end
        name = result;
    else
        name = GRM.CapitalizeFirst( name );
    end
    local byteCount = name:byte ( 1 );
    local count = 1;
    if byteCount == 195 or byteCount == 165 or byteCount == 208 then                -- Special cahracters some can be 2 bytes in length and they are given a value of 195 or 165 in Lua return
        count = 2;
    end
    if GRM.S().selectedLang < 9 and not string.find ( name , " " ) then
        name = string.sub ( name , 1 , count ) .. string.lower ( string.sub ( name , count + 1 ) );
    end
    return name;
end

-- Method:          GRM.Capitalize ( string )
-- What it Does:    Takes the first letter of a word and capitalizes it, whilst lowercasing the rest
-- Purpose:         Proper formatting of names.
GRM.Capitalize = function ( word )
    local result = "";

    if #word > 0 then
        result = word:sub ( 1 , 1 ):upper() .. word:sub ( 2 ):lower(); 
    end

    return result;
end

-- Method           GRM.Trim ( string )
-- What it Does:    Removes the white space at front and at tail of string.
-- Purpose:         Cleanup strings for ease of logic control, as needed.
GRM.Trim = function ( str )
    if str == nil then
        return nil;
    else
        return ( str:gsub ( "^%s*(.-)%s*$" , "%1" ) );
    end
end

-- Method:          GRM.StringToCharArray ( string [, bool]);
-- What it Does:    Converts a string into a char array, and has the option to remove all indexes of a given char
-- Purpose:         More easily cleanup strings, especially when sending data back and forth using the '?' separator
GRM.StringToCharArray = function( text , removeChar )
    local result = {};
    local temp = "";
    for i = 1 , #text do
        temp = string.sub ( text , i , i );
        -- Remove the char by ignoring it
        if not removeChar or ( removeChar and removeChar ~= temp ) then
            table.insert ( result , string.sub ( text , i , i ) );
        end
    end
    return result;
end

-- Method:          GRM.GetWordArrayFromString ( string , string )
-- What it Does:    Returns an array of words or items that were divided by characters
-- Purpose:         Cleanup code for parsing back the sendAddonMessage strings.
GRM.GetWordArrayFromString = function ( text , divider )
    local result = {};
    while string.find ( text , divider ) ~= nil do
        table.insert ( result , string.sub ( text , 1 , string.find ( text , divider ) - 1 ) );
        text = string.sub ( text , string.find ( text , divider ) + 1 );
    end
    if #text > 0 then
        table.insert ( result , text );
    end
    return result;
end

-- Method:          GRM.ConvertStringNumArrayToBoolArray ( array )
-- What it Does:    Sets an array corresponding index to booleans matching another array. 1 = true, 0 = false
-- Purpose:         Slim the sendaddonMessages a bit by converting bools to 1s and 0s and then converting back on the other end.
GRM.ConvertStringNumArrayToBoolArray = function ( listOfNum )
    local result = {};
    for i = 1 , #listOfNum do
        if listOfNum[i] == "1" then
            result[i] = true;
        else
            result[i] = false;
        end
    end
    return result;
end 

-- Method:          GRM.ResetTempLogs()
-- What it Does:    Empties the arrays of the reporting logs
-- Purpose:         Logs are used to build changes in the guild and then to cleanly report them in order.
GRM.ResetTempLogs = function()
    GRM_G.TempNewMember = {};
    GRM_G.TempInactiveReturnedLog = {};
    GRM_G.TempLogPromotion = {};
    GRM_G.TempLogDemotion = {};
    GRM_G.TempLogLeveled = {};
    GRM_G.TempLogNote = {};
    GRM_G.TempLogONote = {};
    GRM_G.TempRankRename = {};
    GRM_G.TempRejoin = {};
    GRM_G.TempBannedRejoin = {};
    GRM_G.TempLeftGuild = {};
    GRM_G.TempLeftGuildPlaceholder = {};
    GRM_G.TempNameChanged = {};
    GRM_G.TempEventReport = {};
    GRM_G.TempEventRecommendKickReport = {};
    GRM_G.TempEventRecommendPromotionReport = {};
    GRM_G.TempEventRecommendDemotionReport = {};
    GRM_G.TempDeathReport = {};
end

------------------------------------
------ TIME TRACKING TOOLS ---------
--- TIMESTAMPS , TIMEPASSED, ETC. --
------------------------------------

-- Method:          GRM.IsLeapYear(int)
-- What it Does:    Returns true if the given year is a leapYear
-- Purpose:         For this addon, the calendar date selection, allows it to know to produce 29 days on leap year.
GRM.IsLeapYear = function ( yearDate )
    if yearDate < 100 then
        yearDate = yearDate + 2000; -- Some old formatting had an array of dates with the year only with the 2 digits. In other words, 2012 would be "12"
    end
    if ( ( ( yearDate % 4 == 0 ) and ( yearDate % 100 ~= 0 ) ) or ( yearDate % 400 == 0 ) ) then
        return true;
    else
        return false;
    end
end

-- Method:          GRM.GetTotalYearHours ( int )
-- What it Does:    Returns the number of hours that have passed based on number of years
-- Purpose:         For exact accuracy, this factors in leapyears.
GRM.GetTotalYearHours = function ( totalYears )
    local hours = 0;
    local month , day , year;
    month , day , year = select ( 2 , GRM.GetTodaysDate() );

    for i = totalYears , 1 , -1 do

        -- initial hours
        hours = hours + 8760;
        -- check for leap year. Logic is different on how it is counted depending on where you are in that month.
        if ( month > 2 or ( month == 2 and day == 29 ) ) then
            -- Check this year.
            if GRM.IsLeapYear ( year ) then
                hours = hours + 24;
            end
        else
            -- Check previous year because even if this WAS a leap year, it's before Feb 29th, so it cannot be added, but previous year can.
            if GRM.IsLeapYear ( year - 1 ) then
                hours = hours + 24;
            end
        end

        year = year - 1;
    end

    return hours;
end

-- Method:          GRM.GetHoursSinceLastOnline(int)
-- What it Does:    Returns the total numbner of hours since the player last logged in at given index position of guild roster
-- Purpose:         For player management to notify addon user of too much time has passed, for recommendation to kick,
GRM.GetHoursSinceLastOnline = function ( index , isOnline )
    local years , months, days, hours;
    years , months, days, hours = GetGuildRosterLastOnline ( index );
    local validTime = true;
    local monthHrs = 0;
    
    if not years then
        years = 0;
    end
    if not months then
        months = 0;
    end
    if not days then
        days = 0;
    end
    if not hours then
        hours = 0;
    end

    -- For some weird reason this can sometimes say 12 months, which means 1 year. -- error protection from Blizz's server.
    if months == 12 then
        years = years + 1;
        months = 0;
    end

    if ( years == 0 ) and ( months == 0 ) and ( days == 0 ) and ( hours == 0) then
        validTime = false;
        if isOnline then
            hours = 0;    -- This can be any value less than 1, but must be between 0 and 1, to just make the point that total number of hrs since last login is < 1
        else
            hours = 0.5
        end
    end

    if months > 0 then
        monthHrs = ( GRM.GetNumHoursTilRecommend ( months , select ( 4 , GRM.GetTodaysDate() ) - years ) );
    end
        
    if validTime then
        return math.floor ( ( GRM.GetTotalYearHours ( years ) ) + monthHrs + ( days * 24 ) + hours );
    else
        return hours
    end
end

-- Method:          GRM.ConvertToStandardFormatDate ( int , int , int )
-- What it Does:    Converts the date into ISO 8601 international standard.
-- Purpose:         It's easy to parse this date.
GRM.ConvertToStandardFormatDate = function ( day , month , year )

    local result = "";

    if year > 0 and month > 0 and day > 0 then

        result = tostring ( year );
        
        if month < 10 then
            result = result .. "0" .. tostring ( month );
        else
            result = result .. tostring ( month );
        end

        if day < 10 then
            result = result .. "0" .. tostring ( day );
        else
            result = result .. tostring ( day );
        end

    end

    return result;
end

-- Method:          GRM.ParseStandardFormatDate ( string )
-- What it Does:    Converts the string formated date into integers, separated by YYYY,MM,DD
-- Purpose:         Easily store the dates of people for sync purposes in easily formatted use
GRM.ParseStandardFormatDate = function ( date )

    if #date == 8 then
        local year , month , day = string.match ( date , "(%d%d%d%d)(%d%d)(%d%d)" );

        return tonumber ( day ) , tonumber ( month ) , tonumber ( year );
    else
        return "";
    end

end

-- Method:          GRM.convertToEpoch ( int , int , int , int , int , int , bool )
-- What it Does:    Converts a time to epochTime
-- Purpose:         Useful in comparing amounts.
GRM.convertToEpoch = function( d , m , y , s , min , h , useOffset )

    if d == 0 or m == 0 or y == 0 then
        return 0;
    end

    local function daysInMonth ( month , year)
        local daysPerMonth = {
            31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31
        }
    
        if month == 2 and GRM.IsLeapYear (year) then
            return 29
        else
            return daysPerMonth[month]
        end
    end
    
    local function dateToTimestamp ( dateTable )
        local day = dateTable[1];
        local month = dateTable[2];
        local year = dateTable[3];
        if year < 1000 then
            year = year + 2000;
        end
        local second = dateTable[4];
        local minute = dateTable[5];
        local hour = dateTable[6];

        -- Validate input values
        day = math.min ( math.max ( day , 1 ) , daysInMonth ( month , year ) );
        month = math.min ( math.max ( month, 1 ) , 12 );
        year = math.max ( year , 1970 ); -- Epoch starts from 1970
        hour = math.min ( math.max ( hour , 0 ), 23);
        minute = math.min ( math.max ( minute , 0 ) , 59);
        second = math.min ( math.max ( second, 0), 59);
    
        -- Calculate timestamp
        local daysSinceEpochStart = 0
    
        -- Calculate days in each year between epoch and the target year
        for y = 1970, year - 1 do
            daysSinceEpochStart = daysSinceEpochStart + ( GRM.IsLeapYear ( y ) and 366 or 365 );
        end

        -- Calculate days in the target year until the target month
        for m = 1, month - 1 do
            daysSinceEpochStart = daysSinceEpochStart + daysInMonth ( m , year );
        end
        
        -- Add days in the target month
        daysSinceEpochStart = daysSinceEpochStart + day - 1
    
        -- Calculate seconds within the day
        local secondsSinceMidnight = ( hour * 3600 ) + ( minute * 60 ) + second
    
        -- Calculate total seconds
        local timestamp = daysSinceEpochStart * 86400 + secondsSinceMidnight
    
        if useOffset then
            return timestamp;
        else
            return timestamp;
        end
    end

    return dateToTimestamp ( { d , m , y , s , min , h } );
end

-- Method:          GRM.GetTimestamp()
-- What it Does:    Reports the current moment in time in a much more clear, concise, pretty way. Example: "9 Feb '17 1:36pm" instead of 09/02/2017/13:36
-- Purpose:         Just for cleaner presentation of the results. Also, need to report based on server time. In-game API only returns hour/min, not month and day. This resolves that.
GRM.GetTimestamp = function()
    -- Time Variables
    local month, day, year , hour , minutes;
    month, day, year , hour , minutes = select ( 2 , GRM.GetTodaysDate() );
    if not hour then
        hour, minutes = GetGameTime();
    end
    local stampMonth = monthAbbrev [ month ];
    local time = "";
    local array = {};

    array = { day , month , year , hour , minutes };
    time = ( day .. " " .. stampMonth .. " '" .. ( year - 2000 ) .. " " .. GRM.GetFormatTime ( hour , minutes ) )

    return time , array;
end

-- Method:          GRM.GetTimestampFromTable ( table )
-- What it Does:    Converts an integer table into a string timestamp
-- Purpose:         Now that many of the dates are stored as a table format, for easier conversion, rather than a string, this allows for quick access and formatting but only in default fashion.
GRM.GetTimestampFromTable = function ( timeArray )

    local result = "";

    if timeArray[3] ~= nil then
        if timeArray[3] > 2000 then
            timeArray[3] = timeArray[3] - 2000;
        end

        if timeArray[3] < 10 then
            timeArray[3] = "0" .. tostring ( timeArray[3] );
        end
        result = ( timeArray[1] .. " " .. monthEnum2[tostring(timeArray[2])] .. " '" .. timeArray[3] );
    else
        result = ( timeArray[1] .. " " .. monthEnum2[tostring(timeArray[2])] );
    end

    return result;
end

-- Method:          GRM.GetTimePassedInZone ( oldTimestamp , int , bool )
-- What it Does:    Reports back how many days, hours, minutes, or seconds has passed since player has been in a zone (days is unrealistic I know but some people might put in a 24hr+ session, so you never know.)
-- Purpose:         Time tracking to keep track of elapsed time in a zone.
GRM.GetTimePassedInZone = function ( oldTimestamp , exactSeconds , includeAll )
    local totalSeconds = exactSeconds or ( time() - oldTimestamp );
    local year = math.floor ( totalSeconds / 31536000 ); -- seconds in a year
    local yearTag = GRM.L ( "Year" );
    local month = math.floor ( ( totalSeconds % 31536000 ) / 2592000 ); -- etc. 
    local monthTag = GRM.L ( "Month" );
    local days = math.floor ( ( totalSeconds % 2592000) / 86400 );
    local dayTag = GRM.L ( "Day" );
    local hours = math.floor ( ( totalSeconds % 86400 ) / 3600 );
    local hoursTag = GRM.L ( "Hour" );
    local minutes = math.floor ( ( totalSeconds % 3600 ) / 60 );
    local minutesTag = GRM.L ( "Minute" );
    local seconds = math.floor ( ( totalSeconds % 60) );
    local secondsTag = GRM.L ( "Second" );
    
    local timestamp = "";
    if year > 1 then
        yearTag = GRM.L ( "Years" );
    end
    if month > 1 then
        monthTag = GRM.L ( "Months" );
    end
    if days > 1 then
        dayTag = GRM.L ( "Days" );
    end
    if hours > 1 then
        hoursTag = GRM.L ( "Hours" );
    end
    if minutes > 1 then
        minutesTag = GRM.L ( "Minutes" );
    end
    if seconds ~= 1 then
        secondsTag = GRM.L ( "Seconds" );
    end

    if year > 0 or month > 0 or days > 0 then

        if year > 0 then
            timestamp = ( GRM.L ( "{num} {custom1}" , nil , nil , year , yearTag ) );
        end
        if month > 0 then
            timestamp = ( timestamp .. " " .. GRM.L ( "{num} {custom1}" , nil , nil , month , monthTag ) );
        end
        if days > 0 then
            timestamp = ( timestamp .. " " .. GRM.L ( "{num} {custom1}" , nil , nil , days , dayTag ) );
        end
    end

    if ( year == 0 and month == 0 and days == 0 ) or includeAll then
        if hours > 0 or minutes > 0 then
            if hours > 0 then
                timestamp = ( timestamp .. " " .. GRM.L ( "{num} {custom1}" , nil , nil , hours , hoursTag ) );
            end
            if minutes > 0 then
                timestamp = ( timestamp .. " " .. GRM.L ( "{num} {custom1}" , nil , nil , minutes , minutesTag ) );
            end
        end
        if ( hours == 0 and minutes == 0 ) or includeAll then
            if not includeAll or #timestamp == 0 then
                timestamp = ( GRM.L ( "{num} {custom1}" , nil , nil , seconds , secondsTag ) );
            else
                timestamp = ( timestamp .. " " .. GRM.L ( "{num} {custom1}" , nil , nil , seconds , secondsTag ) );
            end
        end
    end
    
    return timestamp;
end

-- Method:          GRM.GetTimeOffesets()
-- What it Does:    Determines the number of hours a player needs to gain or lose based on their local time, to match server time.
-- Purpose:         The date() function pulls OS time, not server time. This allows me to adjust for it.
GRM.GetTimeOffesets = function()
    -- First, let's get local time.
    local local_TimeTable = date ( "*t" );
    -- Then, server time
    local day , _ , hour = select ( 3 , GRM.GetTodaysDate() );

    local offsetServer = 0;

    if local_TimeTable.day == day then
        -- we can easily check this now.
        if local_TimeTable.hour == hour then
            offsetServer = 0;
        elseif local_TimeTable.hour > hour then
            offsetServer = ( local_TimeTable.hour - hour ) * -1; -- -hours
        elseif local_TimeTable.hour < hour then
            offsetServer = hour - local_TimeTable.hour --  +hours 
        end

    else
        if local_TimeTable.day > day then
            offsetServer = ( ( local_TimeTable.hour + 24 ) - hour  ) * -1;
        elseif local_TimeTable.day < day then
            offsetServer = ( hour + 24 ) - local_TimeTable.hour
        end
    end

    return offsetServer;
end

-- Method:          GRM.ConvertTimetableToServer ( table )
-- What it Does:    Returns the day, month, year in integer format based on the given timetable, adjusted to match server time based on the given offset.
-- Purpose:         Adapt OS time to match the Blizzard server time
-- Notes:           This can be used manually with the offset. If you already know that your local time is offset by 2 hrs, where your OS is at 9am, but server is 11am, 
--                  then a "+2" offset is what is needed. If you are ahead of the server by 3hrs, the a "-3" is needed to match the server time.
--                  The logic can get complicated for the edge cases, like if it is Jan 1st, 2021 at 1am local time, yet your server is Dec. 31st, 2020 at 11pm. Gotta adjust.
GRM.ConvertTimetableToServer = function ( timeTable )
    
    if GRM_G.OStimeOffset ~= 0 then
        local newHour = timeTable.hour;

        if newHour >= 24 then
            timeTable.hour = newHour - 24;

            -- Ok, need to shift the day up 1;
            local maxDays = daysInMonth [ tostring ( timeTable.month) ];
            if timeTable.month == 2 and GRM.IsLeapYear ( timeTable.year ) then
                maxDays = maxDays + 1;
            end

            if maxDays == timeTable.day then
                -- We have to shift it to the next month and the day goes to 1;\
                timeTable.day = 1;

                -- We need to adjust the month up too
                if timeTable.month == 12 then
                    timeTable.month = 1;
                    timeTable.year = timeTable.year + 1;
                else
                    timeTable.month = timeTable.month + 1;
                end
            else
                -- We are good, no more changing, adjust the day up by 1.
                timeTable.day = timeTable.day + 1;
            end
            
        elseif newHour < 0 then
            timeTable.hour = 24 + newHour;
            -- Ok, we need to shift the day down

            if timeTable.day == 1 then
                -- Now, we need to determine how many days in the month.
                if timeTable.month == 1 then
                    timeTable.month = 12;
                    timeTable.year = timeTable.year - 1;
                else
                    timeTable.month = timeTable.month - 1;
                    timeTable.day = daysInMonth [ tostring ( timeTable.month ) ];
                    if timeTable.month == 2 and GRM.IsLeapYear ( timeTable.year ) then
                        timeTable.day = timeTable.day + 1;
                    end
                    
                end
            else
                timeTable.day = timeTable.day - 1;
            end
        else
            timeTable.hour = newHour;
        end
    end

    return timeTable.day , timeTable.month , timeTable.year , timeTable.hour;
end

-- Method:          GRM.EpochToDateFormat( int , int )
-- What it Does:    It takes an epoch timestamp and converts it into a string format as desired.
-- Purpose:         Epoch is very exact, to the second. It is nice to store that info than hard to interpret, non-mathematical text, for a computer.
--                  This is just easy formatting for human consumption
GRM.EpochToDateFormat = function ( epochstamp , forcedFormat )
    local day , month , year = 0 , 0 , 0;
    local sFormat = "";
    local tFormat;

    if epochstamp > 0 then
        day , month , year = GRM.ConvertTimetableToServer ( date ( "*t" , epochstamp ) );
        sFormat = GRM.FormatTimeStamp ( { day , month , year } , false , false , forcedFormat );
    end

    tFormat = { day , month , year };

    return sFormat , tFormat;
end

-- Method:          GRM.GetFullDate ( int , int , int , int )
-- What it Does:    Returns the properly formatted date by Blizz
-- Purpose:         Useful to get the full date for many obvious reasons I'd think
GRM.GetFullDate = function ( weekday , month , day , year )
	local weekdayName = CALENDAR_WEEKDAY_NAMES[weekday];
	local monthName = CALENDAR_FULLDATE_MONTH_NAMES[month];
	return weekdayName, monthName, day, year, month;
end

-- Method:          GRM.GetHoursSinceTimestamp( int )
-- What it Does:    Returns the number of hours that has passed since as a flat integer. Anything less than 1hr returns zero
-- Purpose:         To be able to return the number of hours since the given time.
GRM.GetHoursSinceTimestamp = function ( epochStamp )
    local totalSeconds = time() - epochStamp;

    return math.floor ( totalSeconds / 3600 );
end

-- Method:          GRM.GetDaysBetweenDates ( table , table )
-- What it Does:    Returns the number of days until the next event
-- Purpose:         Useful for calculating future dates.
-- Formatting       { dd,mm,yyyy }
GRM.GetDaysBetweenDates = function ( currentDate , futureDate )

    -- Setting up the anniversary date
    -- if the future month is less than or equal to the current
    if futureDate[2] <= currentDate[2] then
        if futureDate[2] < currentDate[2] then
            futureDate[3] = currentDate[3] + 1;  -- Move it to the next year.
        else
            -- Both dates are the same month, let's check t he day
            if futureDate[1] < currentDate[1] then
                futureDate[3] = currentDate[3] + 1;
            end
        end
    end

    local function dayOfYear ( date )
        local daysInMonth = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
        local day, month, year = date[1], date[2], date[3];
        
        -- Adjust days in February for leap years
        if GRM.IsLeapYear ( year ) then
            daysInMonth[2] = 29;
        end
        
        local dayOfYear = day
        for i = 1, month - 1 do
            dayOfYear = dayOfYear + daysInMonth[i];
        end
        
        return dayOfYear;
    end

    local currentDayOfYear = dayOfYear ( currentDate );
    local futureDayOfYear = dayOfYear ( futureDate );

    local daysDifference = futureDayOfYear - currentDayOfYear;
    if futureDate[3] == currentDate[3] + 1 then
        -- Handle the case where the future date is in the next year
        daysDifference = daysDifference + 365;
    end
    
    return daysDifference;
end

-- Method:          GRM.GetTimePassedUsingTableOrString()
-- What it Does:    Returns the Years, hours, and days that have passed since the given timestamp ( In format "day mon 'year")
-- Purpose:         Honestly, simpler solution than build a solution to parse through epoch time, since I don't need hours, minutes, seconds.
GRM.GetTimePassedUsingTableOrString = function ( timestamp )

    local startYear, startMonth , startDay;
    local month , day , year = select ( 2 , GRM.GetTodaysDate() );
    local result = { 0 , 0 , 0 , "" , 0 };           -- resultYear, resultMonth , resultDay;

    if type ( timestamp ) == "string" then

        startYear = tonumber ( string.sub ( string.match ( timestamp , "'%d%d" ) , 2 ) ) + 2000;
        startMonth = monthEnum [ string.match ( timestamp , "%a+" ) ];
        startDay = tonumber ( string.match ( timestamp , "%d+" ) );

    elseif type ( timestamp ) == "table" then
        startDay = timestamp[1];
        startMonth = timestamp[2];
        startYear = timestamp[3]
    end

    if startYear < 1000 then
        startYear = startYear + 2000;
    end

    -- Narrow down the year!
    if year > startYear then                -- If this event happened in a previous year.
        result[1] = year - startYear;
        if month < startMonth then          -- Event is less than a year!
            result[1] = result[1] - 1;
        elseif month == startMonth then
            -- Need to check the day!
            if day < startDay then
                result[1] = result[1] - 1;
            else
                result[1] = year - startYear;   -- If >= then it counts as 1 year.
            end
        else                                -- month > start meaning it's been a year.
            result[1] = year - startYear;
        end
    else
        result[1] = 0;
    end

    -- Ok, now let's get the month! Much easier!
    if month < startMonth then
        result[2] = month + ( 12 - startMonth );
        if day < startDay then          -- Not quite 1 month
            result[2] = result[2] - 1;
        end
    elseif month == startMonth then
        if startYear == year then
            result[2] = 0;
        else
            if day < startDay then
                result[2] = 11;
            else
                result[2] = 0;
            end
        end
    else                        -- month > start 
        if day < startDay then
            result[2] = ( month - startMonth ) - 1;
        else
            result[2] = month - startMonth;
        end
    end

    -- Finally, let's do the day!
    if day < startDay then

        local tempMonth = month;
        if tempMonth == 12 then
            tempMonth = 1;
        end
        result[3] = day + ( daysInMonth [ tostring ( tempMonth ) ] - startDay );

    else
        result[3] = day - startDay;
    end

    --Final text report
    if result[1] > 0 then
        if result[1] == 1 then
            
            result[4] = result[4] .. GRM.L ( "{num} year" , nil , nil , result[1] ) .. " ";
        else
            result[4] =  result[4] .. GRM.L ( "{num} years" , nil , nil , result[1] ) .. " ";
        end
    end
    if result[2] > 0 then
        if result[2] == 1 then
            result[4] = result[4] .. GRM.L ( "{num} month" , nil , nil , result[2] ) .. " ";
        else
            result[4] = result[4] .. GRM.L ( "{num} months" , nil , nil , result[2] ) .. " ";
        end
    end
    if result[3] > 0 and result[1] == 0 then            -- To avoid including days if you have more than 1 year just need year and months
        if result[3] == 1 then
            result[4] = result[4] .. GRM.L ( "{num} day" , nil , nil , result[3] ) .. " ";
        else
            result[4] = result[4] .. GRM.L ( "{num} days" , nil , nil , result[3] ) .. " ";
        end
    end
    -- Clear off any white space.
    if result[1] == 0 and result[2] == 0 and result[3] == 0 then
        result[4] = GRM.L ( "< 1 day" );
    else
        result[4] = GRM.Trim ( result[4] );
    end
    return result;
end

-- Method:          GRM.GetTimePassedUsingEpochTime ( int )
-- What it Does:    Returns a table with the time that has passed
-- Purpose:         Easily know how much time has passed since a given event based on the epochstamp
GRM.GetTimePassedUsingEpochTime = function ( epochSeconds )
    local result = {};
    local epochTimeStamp = GRM.EpochToDateFormat ( epochSeconds );
    local details = GRM.GetTimePassedUsingTableOrString ( epochTimeStamp );

    result.Years = details[1];
    result.Months = details[2];
    result.Days = details[3];
    result.timestamp = details[4];
    
    return result;
end

-- Method:          GRM.GetTimePlayerHasBeenMember ( string )
-- What it does:    Parses the string of the player date they joined the guild the most recent, and then obtains how long they have been a member.
-- Purpose:         To display useful info on how long the player has been a member of the guild.
GRM.GetTimePlayerHasBeenMember = function ( name )
    local player = GRM.GetPlayer ( name );
    local result = "";
     
    if player then
        if #player.joinDateHist[1][4] > 1 then
            result = GRM.GetTimePassedUsingTableOrString ( { player.joinDateHist[1][1] , player.joinDateHist[1][2] , player.joinDateHist[1][3] } );
            result = result[4];
        end
    end
    return result;
end

-- Method:          GRM.HoursReport(int)
-- What it Does:    Reports as a string the time passed since player last logged on. The logic is rather complex because this works backward and has to assume that information may not be available as it is used for log reporting even on players that may not be in the guild anymore thus do not have access to current last login information.
-- Purpose:         Cleaner reporting to the log, and it just reports the lesser info, no seconds and so on.
GRM.HoursReport = function ( hours )
    local result = ""

    if hours ~= nil then

        -- Convert total time to Epoch stamp to make life easier...
        local timeTable = date( "*t" , time() - ( hours * 3600 ) );
        timeTable.day , timeTable.month , timeTable.year , timeTable.hour = GRM.ConvertTimetableToServer ( timeTable );
        local currentMonth , currentDay , year , currentHour;
        currentMonth , currentDay , year , currentHour = select ( 2 , GRM.GetTodaysDate() );
        local currentYear = year;
        local years , months , days , hrs = 0 , 0 , 0 , 0;

        local hoursInYear = 8760;
        
        --- YEARS CALCULATION EXACT ---
        -- Let's get the exact number of years.
        while ( hours / 8760 ) > 0 do

            -- Reset hours each loop to default;
            hoursInYear = 8760;

            -- hours in a year is 8760 or 8784 if leap year.
            if ( currentMonth > 2 or ( currentMonth == 2 and currentDay == 29 ) ) then
                if GRM.IsLeapYear ( year ) then
                    hoursInYear = 8784;
                end
            elseif currentMonth <= 2 and GRM.IsLeapYear ( year - 1 ) then
                hoursInYear = 8784;
            end

            if hours < hoursInYear then
                -- This indicates that player is at 8760+ but <= 8784
                -- 365 days on a 366 day leap year... ALMOST a year, not quite.
                break;
            else
                hours = hours - hoursInYear;
                years = years + 1;
                year = year - 1;
            end
            
        end
        
        --- MONTHS CALCULATION EXACT ---
        -- No need to calculate the number of months if it is the same year and same month, we know it is less than
        -- it could be same month but different years and be 11 months X days though.
        if currentYear == timeTable.year and currentMonth == timeTable.month then
            months = 0;
        else
            -- Determine Months
            if currentMonth > timeTable.month then
                -- Ok, we don't have to cross years, this makes it easier.
                months = currentMonth - timeTable.month;
                if currentDay < timeTable.day then
                    months = months - 1;
                elseif currentDay == timeTable.day then
                    -- We need to compare the hour now.
                    if currentHour < timeTable.hour then
                        months = months - 1;
                    end
                end

            elseif currentMonth < timeTable.month then
                months = ( currentMonth + 12 ) - timeTable.month;
                if currentDay < timeTable.day then
                    months = months - 1;
                elseif currentDay == timeTable.day then
                    -- We need to compare the hour now.
                    if currentHour < timeTable.hour then
                        months = months - 1;
                    end
                end

            elseif currentMonth == timeTable.month then

                -- same month means we either just hit a new year so it's zero, or we are at 11 months approaching 0
                if currentDay <= timeTable.day then
                    if currentDay < timeTable.day then
                        months = 11;

                    elseif currentDay == timeTable.day then
                        -- we need to check the hour now.
                        if currentHour <= timeTable.hour then
                            if currentHour < timeTable.hour then
                                months = 11;
                            end
                        end
                    end
                end
            end
        end

        --- DAYS CALCULATION EXACT ---
        if currentYear == timeTable.year and currentMonth == timeTable.month and currentDay == timeTable.day then
            days = 0;

        else
            if currentDay > timeTable.day then
                days = currentDay - timeTable.day;
                if currentHour < timeTable.hour then
                    days = days - 1;
                end

            elseif currentDay < timeTable.day then
                local leapYearModifier = 0;

                -- this year should reflect the timestamp of former year now, not current.
                if timeTable.month == 2 and GRM.IsLeapYear ( year ) then
                    leapYearModifier = 1;
                end;

                days = ( currentDay + daysInMonth[ tostring ( timeTable.month ) ] + leapYearModifier ) - timeTable.day;

                -- now we need to compare hours.
                if currentHour < timeTable.hour then
                    days = days - 1;
                end

            elseif currentDay == timeTable.day then
                -- It could either be ZERO or it could be max days that month - 1.
                if currentHour < timeTable.hour then

                    local leapYearModifier = 0;

                    -- this year should reflect the timestamp of former year now, not current.
                    if timeTable.month == 2 and GRM.IsLeapYear ( year ) then
                        leapYearModifier = 1;
                    end;

                    days = daysInMonth[ tostring ( timeTable.month ) ] + leapYearModifier - 1;
                else
                    days = 0;
                end

            end
        end

        --- HRS CALCULATION EXACT ---
        if currentYear == timeTable.year and currentMonth == timeTable.month and currentDay == timeTable.day and currentHour == timeTable.hour then
            hrs = 0;

        else
            if currentHour > timeTable.hour then
                hrs = currentHour - timeTable.hour;

            elseif currentHour < timeTable.hour then
                hrs = ( currentHour + 24 ) - timeTable.hour;

            elseif currentHour == timeTable.hour then
                hrs = 0;
            end

        end
   
        if years >= 1 then
            if years > 1 then
                result = result .. "" .. GRM.L ( "{num} yrs" , nil , nil , years ) .. " ";
            else
                result = result .. "" .. GRM.L ( "{num} yr" , nil , nil , years ) .. " ";
            end
        end

        if months >= 1 then
            if years > 0 then
                result = GRM.Trim ( result ) .. ", ";
            end
            if months > 1 then
                result = result .. "" .. GRM.L ( "{num} mos" , nil , nil , months ) .. " ";
            else
                result = result .. "" .. GRM.L ( "{num} mo" , nil , nil , months ) .. " ";
            end
        end

        if days >= 1 then
            if months > 0 then
                result = GRM.Trim ( result ) .. ", ";
            end
            if days > 1 then
                result = result .. "" .. GRM.L ( "{num} days" , nil , nil , days ) .. " ";
            else
                result = result .. "" .. GRM.L ( "{num} day" , nil , nil , days ) .. " ";
            end
        end

        if hrs >= 1 and years < 1 and months < 1 then  -- No need to give exact hours on anything over than a month, just the day is good enough.
            if days > 0 then
                result = GRM.Trim ( result ) .. ", ";
            end
            if hrs > 1 then
                result = result .. "" .. GRM.L ( "{num} hrs" , nil , nil , hrs ) .. " ";
            else
                result = result .. "" .. GRM.L ( "{num} hr" , nil , nil , hrs ) .. " ";
            end
        end
    end

    if result == "" or result == nil then
        result = GRM.L ( "< 1 hour" );
    end
    return GRM.Trim ( result );
end

-- Method:          GRM.GetNumHoursTilRecommend( int )
-- What it Does:    Returns the number of hours need to match the given numMonths time passed
-- Purpose:         Useful for checking if the player has been, for example, offline X number of months, if the time has passed, since the server gives time in hours since last online.
GRM.GetNumHoursTilRecommend = function( numMonths , specialYear )
    local month , day , year = select ( 2 , GRM.GetTodaysDate() );

    if numMonths == 0 then
        return 0;
    end

    if specialYear then
        year = specialYear;
    end

    -- Error protection
    if month == 0 or day == 0 then
        return nil;
    end
    local totalDays = 0;
    local numYears = math.floor ( numMonths / 12 );
    numMonths = numMonths % 12;
    local monthReference = month - numMonths;

    -- ok let's calculate the month index
    if monthReference < 1 then
        monthReference = 12 + month - numMonths;
    end

    -- Add up the total days...
    if numMonths > 0 then
        totalDays = day;               -- This sets the initial number, which is this month.
        if numMonths >= month then
            totalDays = totalDays + daysBeforeMonthEnum[ tostring ( month ) ];                                      -- Counts all the days of this year
            totalDays = totalDays + ( 365 - daysBeforeMonthEnum[ tostring ( monthReference ) ] ) - day;             -- Counts all of the days from the reference month X months ago til end of the year

            -- Check Leap Year
            if ( month > 2 or ( month == 2 and day == 29 ) ) and GRM.IsLeapYear ( year ) and numYears == 0 then -- Adding 1 for the leap year   -- If the year > 1 then the end of this function will tally it auto for each year, if not it is calculated here.
                totalDays = totalDays + 1;
            end

        else                                                                                                        -- Ex: if today is May, 11 months ago, reference month is June last year
            totalDays = totalDays + ( daysBeforeMonthEnum[ tostring ( month ) ] - daysBeforeMonthEnum[ tostring ( monthReference ) ] ) - day;
            if monthReference <= 2 and ( month > 2 or ( month == 2 and day == 29 ) ) and GRM.IsLeapYear ( year ) and numYears == 0  then
                totalDays = totalDays + 1;
            end
        end
    end
    for i = 0 , numYears - 1 do
        if GRM.IsLeapYear ( year - i ) then
            totalDays = totalDays + 1;
        end
    end
    return ( totalDays + ( 365 * numYears ) ) * 24
end

-- Method:          GRM.GetTimestampBasedOnTimePassed ( array )
-- What it Does:    Returns an array that contains a string timestamp of the date based on the timepassed, as well as the epochstamp corresponding to that date
-- Purpose:         Incredibly necessary for join date and promo date tagging with proper dates for display and for sync.
GRM.GetTimestampBasedOnTimePassed = function ( dateInfo )
    local stampDay = dateInfo[1];
    local stampMonth = dateInfo[2];
    local stampYear = dateInfo[3];
    local stampHour = dateInfo[4];
    local month, day, year , hour , minutes;

    month, day, year , hour , minutes = select ( 2 , GRM.GetTodaysDate() );

    if not hour then
        hour, minutes = GetGameTime();
    end
    local LeapYear = GRM.IsLeapYear ( year );
    local time = "";                     -- Generic stamp placeholder
    if not GRM.S().twentyFourHrScale then
        time = "12:01am";
    else
        time = "00:01" .. GRM.L ( "24HR_Notation" );
    end
    -- Adjust the year back for how many years passed
    year = year - stampYear;
    
    -- The month now... Must be a number for 1-12 for corresponding month index
    if month - stampMonth > 0 then
        month = month - stampMonth;
    else
        month = 12 - ( stampMonth - month );
        year = year - 1;
    end

    -- Day
    if day - stampDay > 0 then
        day = day - stampDay;
    else
        local daysInSelectedMonth = daysInMonth[ tostring ( month ) ];
        if LeapYear and month == 2 then
            daysInSelectedMonth = daysInSelectedMonth + 1;
        end
        day = daysInSelectedMonth - ( stampDay - day );
        month = month - 1;
        if month == 0 then
            month = 12;
            year = year - 1;
        end
    end

    -- Hour
    if hour - stampHour > 0 then
        hour = hour - stampHour;
    else
        hour = 24 - ( stampHour - hour );
        day = day - 1;
        if day == 0 then
            -- First, need to determine month now.
            month = month - 1;
            if month == 0 then
                month = 12;
                year = year - 1;
            end
            local dim = daysInMonth[ tostring ( month ) ];      -- Days In Month = dim
            if LeapYear and month == 2 then
                dim = dim + 1;
            end
            day = dim - ( stampDay - day );
        end
    end

    -- We know that it is within hours now.
    if ( stampYear == 0 and stampMonth == 0 and stampDay == 0 ) then
        -- It's the same day! Use current timestamp!!!!

        time = GRM.GetFormatTime ( hour , minutes );
    end
    
    local timestamp = day .. " " .. monthEnum2[ tostring ( month ) ] .. " '" .. tostring ( year - stampYear - 2000 );
    local arrayFormat = { day , month , year , hour , minutes };
    return { timestamp .. " " .. time , GRM.ConvertToStandardFormatDate ( day , month , year ) , arrayFormat };
end

-- Method:          GRM.FormatTimeStamp( string or table , bool , bool , int ) -- last 3 arguments are optional
-- What it Does:    Returns the timestamp in a format designated by the player
-- purpose:         Give player proper timestamp format options.
GRM.FormatTimeStamp = function ( timestamp , includeHour , removeYear , forcedForm )

    local day = 0;
    local monthNum = 0;
    local year = 0;
    local typeForm = forcedForm or GRM.S().dateFormat;
    local month = ""
    local typeStamp = 0; -- 1 = string, 2 = table, 3 = epochNum

    if type ( timestamp ) == "string" then
        typeStamp = 1;
        timestamp = GRM.GetCleanTimestamp ( timestamp ); -- ensure proper formatting
        -- Default format = 12 Mar '18

        day = string.match ( timestamp , "%d+" );
        if #day == 1 then
            day = "0" .. day;
        end
        month = GRM.GetEventMonth ( timestamp );
        monthNum = tostring ( monthEnum [ month ] ); 
        if #monthNum == 1 then
            monthNum = "0" .. monthNum;
        end
        year = string.sub ( string.match ( timestamp , "'%d%d" ) , 2 );

    elseif type ( timestamp ) == "table" then
        typeStamp = 2;

        day = timestamp[1];
        monthNum = tostring ( timestamp[2] );
        year = timestamp[3];

        if day < 10 then
            day = "0" .. tostring ( day );
        end
        
        if year > 2000 then
            year = year - 2000;
        end
        if year < 10 then
            year = "0" .. tostring ( year );
        end
        month = tostring ( monthEnum2[ monthNum ] );

        if #monthNum == 1 then
            monthNum = "0" .. monthNum;
        end
    end
    local result = "";  

    if typeForm == 1 then                               -- 12 Mar '18
        if removeYear then
            result = day .. " " .. GRM.L ( month );
        else
            result = day .. " " .. GRM.L ( month ) .. " '" .. year;
        end
    elseif typeForm == 2 then                           -- 12 Mar 18
        if removeYear then
            result = day .. " " .. GRM.L ( month );
        else
            result = day .. " " .. GRM.L ( month ) .. " " .. year; 
        end
    elseif typeForm == 3 then                           -- 12-Mar-2018
        if removeYear then
            result = day .. "-" .. GRM.L ( month );
        else
            result = day .. "-" .. GRM.L ( month ) .. "-20" .. year;
        end
    elseif typeForm == 4 then                          -- 03-12-18
        if removeYear then
            result = day .. "-" .. monthNum
        else
            result = day .. "-" .. monthNum .. "-" .. year;
        end
    elseif typeForm == 5 then                          -- 03/12/18
        if removeYear then
            result = day .. "/" .. monthNum;
        else
            result = day .. "/" .. monthNum .. "/" .. year;
        end
    elseif typeForm == 6 then                          -- 03.12.18
        if removeYear then
            result = day .. "." .. monthNum;
        else
            result = day .. "." .. monthNum .. "." .. year;
        end
    elseif typeForm == 7 then                          -- 03.12.2018
        if removeYear then
            result = day .. "." .. monthNum;
        else
            result = day .. "." .. monthNum .. ".20" .. year;
        end
    elseif typeForm == 8 then                           -- Mar 12 '18
        if removeYear then
            result = GRM.L ( month ) .. " " .. day;
        else
            result = GRM.L ( month ) .. " " .. day .. " '" .. year;
        end
    elseif typeForm == 9 then                           -- Mar 12 18
        if removeYear then
            result = GRM.L ( month ) .. " " .. day;
        else
            result = GRM.L ( month ) .. " " .. day .. " " .. year;
        end
    elseif typeForm == 10 then                          -- Mar-12-2018
        if removeYear then
            result = GRM.L ( month ) .. "-" .. day;
        else
            result = GRM.L ( month ) .. "-" .. day .. "-20" .. year;
        end
    elseif typeForm == 11 then                           -- 12-03-18
        if removeYear then
            result = monthNum .. "-" .. day;
        else
            result = monthNum .. "-" .. day .. "-" .. year;
        end
    elseif typeForm == 12 then                           -- 12/03/18
        if removeYear then
            result = monthNum .. "/" .. day;
        else
            result = monthNum .. "/" .. day .. "/" .. year;
        end
    elseif typeForm == 13 then                           -- 12.3.18
        if removeYear then
            result = monthNum .. "." .. day;
        else
            result = monthNum .. "." .. day .. "." .. year;
        end
    elseif typeForm == 14 then                           -- 12.3.2018
        if removeYear then
            result = monthNum .. "." .. day;
        else
            result = monthNum .. "." .. day .. ".20" .. year;
        end
    elseif typeForm == 15 then                           -- 2018-03-12
        if removeYear then
            result = monthNum .. "-" .. day;
        else
            result = "20" .. year .. "-" .. monthNum .. "-" .. day;
        end
    elseif typeForm == 16 then                           -- 2018-03-12
        if removeYear then
            result = day .. "-" .. monthNum;
        else
            result = day .. "-" .. monthNum .. "-" .. "20" .. year;
        end  
    elseif typeForm == 17 then
        if removeYear then
            result = monthNum .. "." .. day;
        else
            result = "20" .. year .. "." .. monthNum .. "." .. day;
        end
    end

    if includeHour then
        if typeStamp == 1 then
            result = result .. " " .. string.sub ( timestamp , string.find ( timestamp , "'" ) + 4 );
        elseif typeStamp == 2 then
            if timestamp[4] ~= nil and timestamp[5] ~= nil then
                result = result .. " " .. GRM.GetFormatTime ( timestamp[4] , timestamp[5] );
            end
        end
    end
    return result;
end

-- Method:          GRM.GetFormatTime ( string , string 
-- What it Does:    Returns the time of day in the proper 24hr or 12hr format
-- Purpose:         To give players the option for time display formatting, but also to ensure 24hr/12hr standards are there as typically in the EU people often use the 24hr clock, whilst in the US it is the 12hr clock.
GRM.GetFormatTime = function ( hour , min )
    local morning = true;
    local amOrpm = GRM.L ( "pm" );
    local result = "";

    if hour ~= nil and min ~= nil then
        -- Swap from military time if set to 12hr        
        if ( GRM.S() ~= nil and not GRM.S().twentyFourHrScale ) then
            if hour > 12 then
                hour = hour - 12;
                morning = false;
            elseif hour == 12 then
                morning = false;
            elseif hour == 0 then
                hour = 12;
            end

            if morning then
                amOrpm = GRM.L ("am" );
            end 
        else
            amOrpm = GRM.L ( "24HR_Notation" );
        end

        -- Formatting...
        if min < 10 then
            min = ( "0" .. min ); -- Example, if it was 6:09, the minutes would only be "9" not "09" - so this looks better.
        end 
        if hour < 10 then
            hour = ( "0" .. hour );
        end

        result = hour .. GRM.L ( "HourBreak" ) .. min .. amOrpm;
    end

    return result;
end

-- Method:          GRM.ConvertGenericTimestampToIntValues(string)
-- What it Does:    Returns an array with the day , month , year values set
-- Purpose:         To be used in converting old method of parsing string timestamps to int values for easier conversion and less processing
GRM.ConvertGenericTimestampToIntValues = function ( timeStamp )
    local tempStamp = GRM.GetCleanTimestamp ( timeStamp ); -- ensure proper formatting
    local day = GRM.GetEventDay ( tempStamp );         -- set the day
    local month = monthEnum [ GRM.GetEventMonth ( tempStamp ) ];      -- set the month
    local year = GRM.GetEventYear ( tempStamp );                    -- set the year

    if day ~= nil and month ~= nil and year ~= nil then
        return { day , month , year };
    else
        return nil;
    end
end

-- Method:          GRM.GetDefaultTimestampUsingIntValues ( int , int , int )
-- What it Does:    Converts int indexes to proper default timestamp format
-- Purpose:         For easy comparison check of a string.
GRM.GetDefaultTimestampUsingIntValues = function ( day , month , year )
    if year < 10 then
        year = "0" .. tostring ( year );
    end
    return day .. " " .. monthEnum2 [ tostring ( month ) ] .. " '" .. year;
end

-- Method:          GRM.GetTimestampOfLastRankChange ( playerObject )
-- What it Does:    Returns the string timestamp based on the array values of the table
-- Purpose:         Quick conversion of time format.
GRM.GetTimestampOfLastRankChange = function ( player )
    local result = "";

    if player and #player.rankHist[1][5] > 1 then
        result = GRM.FormatTimeStamp ( { player.rankHist[1][2] , player.rankHist[1][3] , player.rankHist[1][4] } , false , false );
    end

    return result;
end

-- Method:          GRM.IsValidSubmitDate ( int , int , boolean )
-- What it Does:    Returns true if the submission date is valid (not an untrue day or in the future)
-- Purpose:         Check to ensure the wrong date is not submitted on accident.
GRM.IsValidSubmitDate = function ( daySelected , monthSelected , yearSelected , IsLeapYearSelected )
    local closeButtons = true;
    local month , day , year = select ( 2 , GRM.GetTodaysDate() ); 
    local numDays;
    IsLeapYearSelected = IsLeapYearSelected or GRM.IsLeapYear ( yearSelected );

    if monthSelected > 12 then
        GRM.Report ( GRM.L ( "Please choose a valid Month" ) );
        return false;
    end

    if yearSelected < 2004 then
        GRM.Report ( GRM.L ( "Warcraft was not released until 2004. Please choose a valid year." ) );
        return false;
    end

    if monthSelected == 1 or monthSelected == 3 or monthSelected == 5 or monthSelected == 7 or monthSelected == 8 or monthSelected == 10 or monthSelected == 12 then
        numDays = 31;
    elseif monthSelected == 2 and IsLeapYearSelected then
        numDays = 29;
    elseif monthSelected == 2 then
        numDays = 28;
    else
        numDays = 30;
    end
    if daySelected > numDays then
        closeButtons = false;
    end
    
    if closeButtons then
        if ( year < yearSelected ) or ( year == yearSelected and month < monthSelected ) or ( year == yearSelected and month == monthSelected and day < daySelected ) then
            GRM.Report ( GRM.L ( "Player Does Not Have a Time Machine!" ) );
            closeButtons = false;
        end
    end

    if closeButtons == false then
        GRM.Report ( GRM.L ( "Please choose a valid DAY" ) );
    end

    return closeButtons;
end


------------------------------------
------ END OF TIME METHODS ---------
------------------------------------

------ MYTHIC + TRACKING -----------
------------------------------------

-- Method:          GRM.GetMythicRatingToMatchRaiderIO ( int )
-- What it Does:    Returns the string Hex value coloring of the Mythic + rating based on the RAIDER.IO scale
-- Purpose:         RaidIO is immensely popular, and this just keeps the visual consistent.
GRM.GetMythicRatingToMatchRaiderIO = function ( rating )
    local result = "FFFFFF";

    if rating >= 3625 then
        result = "FF8000";
    elseif rating >= 3465 then
        result = "F9763A";
    elseif rating >= 3345 then
        result = "F36C58";
    elseif rating >= 3225 then
        result = "EB6273";
    elseif rating >= 3105 then
        result = "E2588D";
    elseif rating >= 2985 then
        result = "D64EA6";
    elseif rating >= 2865 then
        result = "C845C0";
    elseif rating >= 2745 then
        result = "B63CD9";
    elseif rating >= 2610 then
        result = "9E3BED";
    elseif rating >= 2490 then
        result = "8152E8";
    elseif rating >= 2370 then
        result = "5F62E3";
    elseif rating >= 2250 then
        result = "246EDE";
    elseif rating >= 2075 then
        result = "307AD3";
    elseif rating >= 1955 then
        result = "4686C5";
    elseif rating >= 1835 then
        result = "5293B8";
    elseif rating >= 1715 then
        result = "5AA0AA";
    elseif rating >= 1595 then
        result = "5EAD9C";
    elseif rating >= 1475 then
        result = "5FBA8D";
    elseif rating >= 1355 then
        result = "5EC77E";
    elseif rating >= 1235 then
        result = "59D46D";
    elseif rating >= 1115 then
        result = "50E159";
    elseif rating >= 995 then
        result = "42EF41";
    elseif rating >= 875 then
        result = "27FC17";
    elseif rating >= 750 then
        result = "67FF4B";
    elseif rating >= 625 then
        result = "96FF7A";
    elseif rating >= 500 then
        result = "BAFFA2";
    elseif rating >= 375 then
        result = "D9DDC9";
    elseif rating >= 250 then
        result = "F4FFF0";
    end
    
    return "|CFF" .. result;
end

------------------------------------
------ UI FORMATTING HELPERS -------
------------------------------------

-- Method:          GRM.AllignTwoColumns ( array , int )
-- What it Does:    Takes the array of strings and then alligns them by fontsize and width...
-- Purpose:         For UI aesthetics and allignment purposes
GRM.AllignTwoColumns = function ( listOfStrings , spacing )
    -- First, determine longest string width of headers
    local result = "\n";
    local modifier = 7;
    local size = 17.08;
    if GRM.S().showLineNumbers then
        modifier = 8.5;
    end

    GRM_UI.GRM_GroupInfo.InvisFontStringWidthCheck:SetFont ( GRM_G.FontChoice , GRM.S().logFontSize + size - modifier ); -- Reset it in case it has changed.
    GRM_UI.GRM_GroupInfo.InvisFontStringWidthCheck:SetText( listOfStrings[1][1] );         -- need to set string to measurable value
    local longestW = GRM_UI.GRM_GroupInfo.InvisFontStringWidthCheck:GetWidth();
    for i = 2 , #listOfStrings do
        GRM_UI.GRM_GroupInfo.InvisFontStringWidthCheck:SetText( listOfStrings[i][1] );
        local tempW = GRM_UI.GRM_GroupInfo.InvisFontStringWidthCheck:GetWidth();
        if tempW > longestW then
            longestW = tempW;
        end
    end

    -- Now, establish the total necessary width - We are setting spacing at 5.
    longestW = longestW + spacing;
    for i = 1 , #listOfStrings do
        GRM_UI.GRM_GroupInfo.InvisFontStringWidthCheck:SetText( listOfStrings[i][1] );
        while GRM_UI.GRM_GroupInfo.InvisFontStringWidthCheck:GetWidth() < longestW do
            GRM_UI.GRM_GroupInfo.InvisFontStringWidthCheck:SetText ( GRM_UI.GRM_GroupInfo.InvisFontStringWidthCheck:GetText() .. " " );       -- Keep adding spaces until it matches
        end
        if listOfStrings[i][2] ~= nil then
            result = result .. GRM_UI.GRM_GroupInfo.InvisFontStringWidthCheck:GetText() .. listOfStrings[i][2];
        else
            result = result .. GRM_UI.GRM_GroupInfo.InvisFontStringWidthCheck:GetText() .. GRM.L ( "Unknown" ); -- Error protection if importing nil value
        end
        if i ~= #listOfStrings then
            result = result .. "\n";
        end
    end
    return result;
end


------------------------------------
------ END OF FORMATTING HELPERS ---
------------------------------------


------------------------------------
---- MousOver Methods --------------
------------------------------------

-- Method:          GRM.GetRosterName ( button , boolean )
-- Method:          To return the current mouseover name of the given button, with the server appended.
-- Purpose:         Need the full name-server, untruncated, to be able to correctly identify the player in database, in case 2 players with same name, but diff. servers
GRM.GetRosterName = function ( button , isMouseClick )
    local name = "";

    if not GRM_G.pause or isMouseClick then

        local memberInfo = button.memberInfo;
        if memberInfo ~= nil then
            name = memberInfo.name;

            if name ~= nil and memberInfo.guid ~= nil and string.find ( name , "-" ) == nil then
                local fullName = GRM.GetFullNameClubMember ( memberInfo.guid );
                if fullName and fullName ~= "" then
                    name = fullName;
                end
            end

        end
    end
    return name;
end

-- Method:          GRM.InitializeRosterButtons()
-- What it Does:    Initializes, one time, the script handlers for the roster frames
-- Purpose:         So main player popup window appears properly 
-- Note:            THIS ONLY WORKS WITH BFA and SL expansions 8.0 and 9.0 -- not Dragonflight
GRM.InitializeRosterButtons = function()
    local cFrame = CommunitiesFrame;
    local memberFrame = cFrame.MemberList;
    local buttons = memberFrame.ListScrollFrame.buttons;
    for i = 1 , #buttons do
        buttons[i]:HookScript ( "OnEnter" , function ( self )
            
            if not CommunitiesFrame.RecruitmentDialog:IsVisible() then
                if cFrame:GetSelectedClubId() == GRM_G.gClubID and GetMouseFocus() == self then
                    local name = GRM.GetRosterName ( buttons[i] , false  );

                    if name ~= "" and name ~= nil and GRM.GetPlayer ( name ) then

                        local memberInfo = self.memberInfo
                        GRM.MemberListBlizTooltip_Update ( buttons[i] , false , memberInfo.classID , memberInfo.name , memberInfo.guildRank , memberInfo.race , memberInfo.level , memberInfo.presence , memberInfo.zone , memberInfo.memberNote , memberInfo.officerNote );
                        GRM_G.currentName = name;
                        GRM.SubFrameCheck();

                        GRM.PopulateMemberDetails ( name , memberInfo );
                        if not GRM_UI.GRM_MemberDetailMetaData:IsVisible() then
                            if GRM_UI.MemberDetailFrame:IsVisible() then
                                GRM_UI.GRM_MemberDetailMetaData:SetPoint ( "TOPLEFT" , GRM_UI.MemberDetailFrame , "TOPRIGHT" , -4 , 5 );
                            else
                                GRM_UI.GRM_MemberDetailMetaData:SetPoint ( "TOPLEFT" , CommunitiesFrame , "TOPRIGHT" , 34 , 5 );
                            end
                            if GRM.S().showMouseoverRetail then
                                if GRM_G.guildName ~= "" then
                                    GRM_UI.GRM_MemberDetailMetaData:Show();
                                end
                            end
                        end

                    else
                        if GRM_UI.GRM_MemberDetailMetaData:IsVisible() then
                            GRM_UI.GRM_MemberDetailMetaData:Hide();
                        end

                    end
                end
            end
        end);
        
        buttons[i]:HookScript ( "OnClick" , function ( self , button )
            if button == "LeftButton" then
                local nameCopy = false;
                if IsShiftKeyDown() then
                    nameCopy = true;
                end

                local name = GRM.GetRosterName ( self , true );
                if name ~= "" and name ~= nil and GRM.GetPlayer ( name ) then
                    if not nameCopy then
                        if name ~= GRM_G.currentName and StaticPopup1:IsVisible() and GRM_UI.GRM_PopupWindow:IsVisible() then
                            StaticPopup1:Hide();
                        end
                        GRM_G.currentName = name;
                        GRM.SubFrameCheck();

                        if not CommunitiesFrame.RecruitmentDialog:IsVisible() then
                            if cFrame:GetSelectedClubId() == GRM_G.gClubID then
                                GRM.PopulateMemberDetails ( name , self.memberInfo );
                                GRM_G.pause = true;
                                if not GRM_UI.GRM_MemberDetailMetaData:IsVisible() then
                                    if GRM_UI.MemberDetailFrame:IsVisible() then
                                        GRM_UI.GRM_MemberDetailMetaData:SetPoint ( "TOPLEFT" , GRM_UI.MemberDetailFrame , "TOPRIGHT" , -4 , 5 );
                                    else
                                        GRM_UI.GRM_MemberDetailMetaData:SetPoint ( "TOPLEFT" , CommunitiesFrame , "TOPRIGHT" , 34 , 5 );
                                    end
                                    if GRM.S().showMouseoverRetail then
                                        if GRM_G.guildName ~= "" then
                                            GRM_UI.GRM_MemberDetailMetaData:Show();
                                        end
                                    end
                                end
                            end
                        end
                    else
                        GRM.GR_Roster_Click ( name );
                    end
                else
                    if GRM_UI.GRM_MemberDetailMetaData:IsVisible() then
                        GRM_UI.GRM_MemberDetailMetaData:Hide();
                    end
                end
            end
        end);

        buttons[i]:HookScript ( "OnUpdate" , GRM.RosterButton_OnUpdate );
    end
end

-- Method:          GRM.InitializeDragonFlightRosterButtons()
-- What it Does:    Initializes, one time, the script handlers for the roster frames
-- Purpose:         So main player popup window appears properly 
GRM.InitializeDragonFlightRosterButtons = function()
    local cFrame = CommunitiesFrame;

    cFrame.MemberList.ScrollBox:ForEachFrame ( function ( scrollButton )

        scrollButton:HookScript ( "OnEnter" , function ()
            if cFrame:GetSelectedClubId() == GRM_G.gClubID and GetMouseFocus() == self then
                local name = GRM.GetRosterName ( scrollButton , false  );

                if name ~= "" and name ~= nil and GRM.GetPlayer ( name ) then

                    local memberInfo = self.memberInfo

                    GRM.MemberListBlizTooltip_Update ( scrollButton , false , memberInfo.classID , memberInfo.name , memberInfo.guildRank , memberInfo.race , memberInfo.level , memberInfo.presence , memberInfo.zone , memberInfo.memberNote , memberInfo.officerNote );
                    GRM_G.currentName = name;
                    GRM.SubFrameCheck();

                    GRM.PopulateMemberDetails ( name , memberInfo );
                    if not GRM_UI.GRM_MemberDetailMetaData:IsVisible() then
                        if GRM_UI.MemberDetailFrame:IsVisible() then
                            GRM_UI.GRM_MemberDetailMetaData:SetPoint ( "TOPLEFT" , GRM_UI.MemberDetailFrame , "TOPRIGHT" , -4 , 5 );
                        else
                            GRM_UI.GRM_MemberDetailMetaData:SetPoint ( "TOPLEFT" , CommunitiesFrame , "TOPRIGHT" , 34 , 5 );
                        end
                        if GRM.S().showMouseoverRetail then
                            if GRM_G.guildName ~= "" then
                                GRM_UI.GRM_MemberDetailMetaData:Show();
                            end
                        end
                    end
                else
                    if GRM_UI.GRM_MemberDetailMetaData:IsVisible() then
                        GRM_UI.GRM_MemberDetailMetaData:Hide();
                    end
                end
            end
        end);
        
        scrollButton:HookScript ( "OnClick" , function ( self , button )
            if button == "LeftButton" then
                local nameCopy = false;
                if IsShiftKeyDown() then
                    nameCopy = true;
                end

                local name = GRM.GetRosterName ( self , true );
                if name ~= "" and name ~= nil and GRM.GetPlayer ( name ) then
                    if not nameCopy then
                        if name ~= GRM_G.currentName and StaticPopup1:IsVisible() and GRM_UI.GRM_PopupWindow:IsVisible() then
                            StaticPopup1:Hide();
                        end
                        GRM_G.currentName = name;
                        GRM.SubFrameCheck();
                        if cFrame:GetSelectedClubId() == GRM_G.gClubID then
                            GRM.PopulateMemberDetails ( name , self.memberInfo );
                            GRM_G.pause = true;
                            if not GRM_UI.GRM_MemberDetailMetaData:IsVisible() then
                                if GRM_UI.MemberDetailFrame:IsVisible() then
                                    GRM_UI.GRM_MemberDetailMetaData:SetPoint ( "TOPLEFT" , GRM_UI.MemberDetailFrame , "TOPRIGHT" , -4 , 5 );
                                else
                                    GRM_UI.GRM_MemberDetailMetaData:SetPoint ( "TOPLEFT" , CommunitiesFrame , "TOPRIGHT" , 34 , 5 );
                                end
                                if GRM.S().showMouseoverRetail then
                                    if GRM_G.guildName ~= "" then
                                        GRM_UI.GRM_MemberDetailMetaData:Show();
                                    end
                                end
                            end
                        end
                    else
                        GRM.GR_Roster_Click ( name );
                    end
                else
                    if GRM_UI.GRM_MemberDetailMetaData:IsVisible() then
                        GRM_UI.GRM_MemberDetailMetaData:Hide();
                    end
                end
            end
        end);

        scrollButton:HookScript ( "OnUpdate" , GRM.RosterButton_OnUpdate );
    end);
end


-- Method:          GRM.RosterButton_OnUpdate ( buttonObject , int )
-- What it Does:    On each frame refresh it does a check (at max 20FPS), and checks to see if the name has changed, and then updates
--                  the player mouseover popup window if so.
-- Purpose:         The main purpose is this allows the frames to be updated if the mouse is stationary over the hybrid scrollframe button, but the mousewheels still scrolls
--                  This is important because the core logic happens "OnEnter" rather than on update.
GRM.RosterButton_OnUpdate = function ( self , elapsed )
    GRM_G.ButtonRosterTimer = GRM_G.ButtonRosterTimer + elapsed;
    if GRM_G.ButtonRosterTimer > 0.05 and GetMouseFocus() == self and CommunitiesFrame:GetSelectedClubId() == GRM_G.gClubID then
        
        local name = GRM.GetRosterName ( self , true );

        if name ~= "" and name ~= nil and name ~= GRM_G.currentName and not GRM_G.pause and not CommunitiesFrame.RecruitmentDialog:IsVisible() then

            if GRM.GetPlayer ( name ) then
                GRM_G.currentName = name;
                GRM.SubFrameCheck();

                if CommunitiesFrame:GetSelectedClubId() == GRM_G.gClubID then
                    GRM.PopulateMemberDetails ( name  , self.memberInfo );
                    if not GRM_UI.GRM_MemberDetailMetaData:IsVisible() then

                        if GRM_UI.MemberDetailFrame:IsVisible() then
                            GRM_UI.GRM_MemberDetailMetaData:SetPoint ( "TOPLEFT" , GRM_UI.MemberDetailFrame , "TOPRIGHT" , -4 , 5 );
                        else
                            GRM_UI.GRM_MemberDetailMetaData:SetPoint ( "TOPLEFT" , CommunitiesFrame , "TOPRIGHT" , 34, 5 );
                        end

                        if GRM.S().showMouseoverRetail then
                            if GRM_G.guildName ~= "" then
                                GRM_UI.GRM_MemberDetailMetaData:Show();
                            end
                        end
                    end
                end
            else
                if GRM_UI.GRM_MemberDetailMetaData:IsVisible() then
                    GRM_UI.GRM_MemberDetailMetaData:Hide();
                end
            end
        end

        GRM_G.ButtonRosterTimer = 0;
    end
end

-- Method:          GRM.UpdateMemberDetailNameClassColor()
-- What it Does:    Changes the default Yellow/Gold coloring in Classic to Class colors
-- Purpose:         To enable class coloring in Classic, which is a very useful feature
GRM.UpdateMemberDetailNameClassColor = function()
    
    if GRM_G.BuildVersion < 40000 and GRM.S().colorizeClassicRosterNames then
        local class = select ( 11 , GetGuildRosterInfo ( GRM_G.RosterSelection ) );
        local colors = GRM.GetClassColorRGB ( class , false );

        GuildMemberDetailName:SetTextColor ( colors[1] , colors[2] , colors[3] );
    end

end

-- Method:          GRM.InitializeOldRosterButtons( string )
-- What it Does:    Initializes, one time, the script handlers for the roster frames
-- Purpose:         So main player popup window appears properly 
GRM.InitializeOldRosterButtons = function( classicSpecific )
    local buttonString = "";
    if classicSpecific then
        buttonString = classicSpecific;
    else
        buttonString = GRM_UI.OldRosterButtonName;
    end

    for i = 1 , GRM_UI.ContainerButtonCount do
        local button = _G[ buttonString .. i ];

        button:HookScript ( "OnEnter" , function ( self )
            if not GRM_G.pause and GetMouseFocus() == self and not ( GRM_UI.GRM_MemberDetailMetaData:IsVisible() and GRM_UI.GRM_MemberDetailMetaData:IsMouseOver() ) then
                
                local name , rank , _ , level , _ , zone , memberNote , officerNote , _ , _ , classFile , _ , _ , isMobile , _ , _ , guid = GetGuildRosterInfo ( button.guildIndex );
                
                if name ~= "" and name ~= nil and GRM.GetPlayer ( name ) then
                    if GRM_G.BuildVersion >= 80000 then
                        local presence = 1;
                        if isMobile then
                            presence = 2;
                        end
                        GRM.MemberListBlizTooltip_Update ( button , true , GRM_G.classFileIDEnum[classFile] , name , rank , raceIDEnum [ select ( 4 , GetPlayerInfoByGUID ( guid ) ) ] , level , presence , zone , memberNote , officerNote );
                    end
                    
                    GRM_G.currentName = name;
                    GRM_G.RosterSelection = button.guildIndex;

                    if GRM.S().showMouseoverOld then    
                        GRM.SubFrameCheck();
                        GRM.PopulateMemberDetails ( name );
                        if not GRM_UI.GRM_MemberDetailMetaData:IsVisible() then
                            if GRM_UI.MemberDetailFrame:IsVisible() then
                                GRM_UI.GRM_MemberDetailMetaData:SetPoint ( "TOPLEFT" , GRM_UI.MemberDetailFrame , "TOPRIGHT" , -4 , 5 );
                            else
                                GRM_UI.GRM_MemberDetailMetaData:SetPoint ( "TOPLEFT" , GRM_UI.GuildRosterFrame , "TOPRIGHT" , -4 , 5 );
                            end
                            if GRM_G.guildName ~= "" then
                                GRM_UI.GRM_MemberDetailMetaData:Show();
                            end
                        end
                    end
                else
                    if GRM_UI.GRM_MemberDetailMetaData:IsVisible() then
                        GRM_UI.GRM_MemberDetailMetaData:Hide();
                    end
                end
            end
        end);

        button:HookScript ( "OnClick" , function ( self , clickButton )
            if clickButton == "LeftButton" then
                local nameCopy = false;
                if IsShiftKeyDown() then
                    nameCopy = true;
                end

                local name = GetGuildRosterInfo ( self.guildIndex );
                if name ~= "" and name ~= nil and GRM.GetPlayer ( name ) then
                    if not nameCopy then

                        if name ~= GRM_G.currentName and StaticPopup1:IsVisible() and GRM_UI.GRM_PopupWindow:IsVisible() then
                            StaticPopup1:Hide();
                        end
                        GRM_G.currentName = name;
                        GRM_G.RosterSelection = self.guildIndex;
                        if GRM.S().showMouseoverOld then
                            GRM.SubFrameCheck();
                            GRM.PopulateMemberDetails ( name );
                            if GRM_UI.MemberDetailFrameClassic:IsVisible() then
                                GRM_G.pause = true;
                            else
                                GRM_G.pause = false;
                            end
                            if not GRM_UI.GRM_MemberDetailMetaData:IsVisible() then
                                if GRM_UI.MemberDetailFrameClassic:IsVisible() then
                                    GRM_UI.GRM_MemberDetailMetaData:SetPoint ( "TOPLEFT" , GRM_UI.MemberDetailFrameClassic , "TOPRIGHT" , -4 , 5 );
                                else
                                    GRM_UI.GRM_MemberDetailMetaData:SetPoint ( "TOPLEFT" , GRM_UI.GuildRosterFrame , "TOPRIGHT" , -4 , 5 );
                                end
                                if GRM_G.guildName ~= "" then
                                    GRM_UI.GRM_MemberDetailMetaData:Show();
                                end
                            end
                        end

                        GRM.UpdateMemberDetailNameClassColor();

                    else
                        GRM.GR_Roster_Click ( name );
                    end
                else
                    if GRM_UI.GRM_MemberDetailMetaData:IsVisible() then
                        GRM_UI.GRM_MemberDetailMetaData:Hide();
                    end
                end
            end
        end);

        button:HookScript ( "OnUpdate" , GRM.OldRosterButton_OnUpdate );

        button:HookScript ( "OnLeave" , function()
            if GameTooltip:IsVisible() then
                GameTooltip:Hide();
            end
        end);

    end
end

-- Method:          GRM.RecolorText()
-- What it Does:    Changes the color of the roster to the default Classic color to the player's class
-- Purpose:         Modernizes the chat a bit
GRM.RecolorText = function( button )
    if GRM.S().colorizeClassicRosterNames then
        if button.guildIndex ~= nil then
            local isOnline , _ , class = select ( 9 , GetGuildRosterInfo ( button.guildIndex ) );
            if isOnline then
                local colors= GRM.GetClassColorRGB ( class , false );

                _G[ button:GetName() .. "Name" ]:SetTextColor ( colors[1] , colors[2] , colors[3] );
            end
        end
    end
end

-- Method:          GRM.OldRosterButton_OnUpdate ( buttonObject , int )
-- What it Does:    On each frame refresh it does a check (at max 20FPS), and checks to see if the name has changed, and then updates
--                  the player mouseover popup window if so.
-- Purpose:         The main purpose is this allows the frames to be updated if the mouse is stationary over the hybrid scrollframe button, but the mousewheels still scrolls
--                  This is important because the core logic happens "OnEnter" rather than on update.
GRM.OldRosterButton_OnUpdate = function ( self , elapsed )
    GRM_G.ButtonRosterTimer2 = GRM_G.ButtonRosterTimer2 + elapsed;
    if GRM_G.ButtonRosterTimer2 > 0.05 then

        if IsInGuild() then
            local name = GetGuildRosterInfo ( self.guildIndex );
            
            if GRM.S().showMouseoverOld and self:IsMouseOver() and not ( GRM_UI.GRM_MemberDetailMetaData:IsVisible() and GRM_UI.GRM_MemberDetailMetaData:IsMouseOver() ) then

                if name ~= "" and name ~= nil and name ~= GRM_G.currentName and not GRM_G.pause then

                    if GRM.GetPlayer ( name ) then
                        GRM_G.currentName = name;
                        GRM_G.RosterSelection = self.guildIndex;
                        GRM.SubFrameCheck();
                        GRM.PopulateMemberDetails ( name );
                        if not GRM_UI.GRM_MemberDetailMetaData:IsVisible() then
                            if GRM_UI.MemberDetailFrame:IsVisible() then
                                GRM_UI.GRM_MemberDetailMetaData:SetPoint ( "TOPLEFT" , GRM_UI.MemberDetailFrame , "TOPRIGHT" , -4 , 5 );
                            else
                                GRM_UI.GRM_MemberDetailMetaData:SetPoint ( "TOPLEFT" , GRM_UI.GuildRosterFrame , "TOPRIGHT" , -4 , 5 );
                            end
                            if GRM_G.guildName ~= "" then
                                GRM_UI.GRM_MemberDetailMetaData:Show();
                            end
                        end
                    else
                        if GRM_UI.GRM_MemberDetailMetaData:IsVisible() then
                            GRM_UI.GRM_MemberDetailMetaData:Hide();
                        end
                    end
                end
            end
        end

        GRM_G.ButtonRosterTimer2 = 0;
    end
end

-- Method:          GRM.GetAllTooltipText()
-- What it Does:    Grabs all parts of the Gametooltip to clone them
-- Purpose:         Universal compatibility of GRM with other addons that modify communityframe tooltip
GRM.GetAllTooltipText = function()
    local result = {};
    if GameTooltip:IsVisible() then
        local count;

        if #GRM_G.ToolTipTextLeft < 24 then
            count = #GRM_G.ToolTipTextLeft;
            
            -- This might seem better to be placed into a table or array, the ultimate issue is by placing it into an array it decalres it as a global, so I first need to check if it exits.
            -- There is no way to call a fontstring with a known API (like GetClickFrame()) and as such they need to be manually selected.
            if 1 > count and GameTooltipTextLeft1 ~= nil then
                table.insert ( GRM_G.ToolTipTextLeft , GameTooltipTextLeft1 );
            elseif 2 > count and GameTooltipTextLeft2 ~= nil then
                table.insert ( GRM_G.ToolTipTextLeft , GameTooltipTextLeft2 );
            elseif 3 > count and GameTooltipTextLeft3 ~= nil then
                table.insert ( GRM_G.ToolTipTextLeft , GameTooltipTextLeft3 );
            elseif 4 > count and GameTooltipTextLeft4 ~= nil then
                table.insert ( GRM_G.ToolTipTextLeft , GameTooltipTextLeft4 );
            elseif 5 > count and GameTooltipTextLeft5 ~= nil then
                table.insert ( GRM_G.ToolTipTextLeft , GameTooltipTextLeft5 );
            elseif 6 > count and GameTooltipTextLeft6 ~= nil then
                table.insert ( GRM_G.ToolTipTextLeft , GameTooltipTextLeft6 );
            elseif 7 > count and GameTooltipTextLeft7 ~= nil then
                table.insert ( GRM_G.ToolTipTextLeft , GameTooltipTextLeft7 );
            elseif 8 > count and GameTooltipTextLeft8 ~= nil then
                table.insert ( GRM_G.ToolTipTextLeft , GameTooltipTextLeft8 );
            elseif 9 > count and GameTooltipTextLeft9 ~= nil then
                table.insert ( GRM_G.ToolTipTextLeft , GameTooltipTextLeft9 );
            elseif 10 > count and GameTooltipTextLeft10 ~= nil then
                table.insert ( GRM_G.ToolTipTextLeft , GameTooltipTextLeft10 );
            elseif 11 > count and GameTooltipTextLeft11 ~= nil then
                table.insert ( GRM_G.ToolTipTextLeft , GameTooltipTextLeft11 );
            elseif 12 > count and GameTooltipTextLeft12 ~= nil then
                table.insert ( GRM_G.ToolTipTextLeft , GameTooltipTextLeft12 );
            elseif 13 > count and GameTooltipTextLeft13 ~= nil then
                table.insert ( GRM_G.ToolTipTextLeft , GameTooltipTextLeft13 );
            elseif 14 > count and GameTooltipTextLeft14 ~= nil then
                table.insert ( GRM_G.ToolTipTextLeft , GameTooltipTextLeft14 );
            elseif 15 > count and GameTooltipTextLeft15 ~= nil then
                table.insert ( GRM_G.ToolTipTextLeft , GameTooltipTextLeft15 );
            elseif 16 > count and GameTooltipTextLeft16 ~= nil then
                table.insert ( GRM_G.ToolTipTextLeft , GameTooltipTextLeft16 );
            elseif 17 > count and GameTooltipTextLeft17 ~= nil then
                table.insert ( GRM_G.ToolTipTextLeft , GameTooltipTextLeft17 );
            elseif 18 > count and GameTooltipTextLeft18 ~= nil then
                table.insert ( GRM_G.ToolTipTextLeft , GameTooltipTextLeft18 );
            elseif 19 > count and GameTooltipTextLeft19 ~= nil then
                table.insert ( GRM_G.ToolTipTextLeft , GameTooltipTextLeft19 );
            elseif 20 > count and GameTooltipTextLeft20 ~= nil then
                table.insert ( GRM_G.ToolTipTextLeft , GameTooltipTextLeft20 );
            elseif 21 > count and GameTooltipTextLeft21 ~= nil then
                table.insert ( GRM_G.ToolTipTextLeft , GameTooltipTextLeft21 );
            elseif 22 > count and GameTooltipTextLeft22 ~= nil then
                table.insert ( GRM_G.ToolTipTextLeft , GameTooltipTextLeft22 );
            elseif 23 > count and GameTooltipTextLeft23 ~= nil then
                table.insert ( GRM_G.ToolTipTextLeft , GameTooltipTextLeft23 );
            elseif 24 > count and GameTooltipTextLeft24 ~= nil then
                table.insert ( GRM_G.ToolTipTextLeft , GameTooltipTextLeft24 );
            end
        end

        count = #GRM_G.ToolTipTextRight;
        if #GRM_G.ToolTipTextRight < 24 then
            if 1 > count and GameTooltipTextRight1 ~= nil then
                table.insert ( GRM_G.ToolTipTextRight , GameTooltipTextRight1 );
            elseif 2 > count and GameTooltipTextRight2 ~= nil then
                table.insert ( GRM_G.ToolTipTextRight , GameTooltipTextRight2 );
            elseif 3 > count and GameTooltipTextRight3 ~= nil then
                table.insert ( GRM_G.ToolTipTextRight , GameTooltipTextRight3 );
            elseif 4 > count and GameTooltipTextRight4 ~= nil then
                table.insert ( GRM_G.ToolTipTextRight , GameTooltipTextRight4 );
            elseif 5 > count and GameTooltipTextRight5 ~= nil then
                table.insert ( GRM_G.ToolTipTextRight , GameTooltipTextRight5 );
            elseif 6 > count and GameTooltipTextRight6 ~= nil then
                table.insert ( GRM_G.ToolTipTextRight , GameTooltipTextRight6 );
            elseif 7 > count and GameTooltipTextRight7 ~= nil then
                table.insert ( GRM_G.ToolTipTextRight , GameTooltipTextRight7 );
            elseif 8 > count and GameTooltipTextRight8 ~= nil then
                table.insert ( GRM_G.ToolTipTextRight , GameTooltipTextRight8 );
            elseif 9 > count and GameTooltipTextRight9 ~= nil then
                table.insert ( GRM_G.ToolTipTextRight , GameTooltipTextRight9 );
            elseif 10 > count and GameTooltipTextRight10 ~= nil then
                table.insert ( GRM_G.ToolTipTextRight , GameTooltipTextRight10 );
            elseif 11 > count and GameTooltipTextRight11 ~= nil then
                table.insert ( GRM_G.ToolTipTextRight , GameTooltipTextRight11 );
            elseif 12 > count and GameTooltipTextRight12 ~= nil then
                table.insert ( GRM_G.ToolTipTextRight , GameTooltipTextRight12 );
            elseif 13 > count and GameTooltipTextRight13 ~= nil then
                table.insert ( GRM_G.ToolTipTextRight , GameTooltipTextRight13 );
            elseif 14 > count and GameTooltipTextRight14 ~= nil then
                table.insert ( GRM_G.ToolTipTextRight , GameTooltipTextRight14 );
            elseif 15 > count and GameTooltipTextRight15 ~= nil then
                table.insert ( GRM_G.ToolTipTextRight , GameTooltipTextRight15 );
            elseif 16 > count and GameTooltipTextRight16 ~= nil then
                table.insert ( GRM_G.ToolTipTextRight , GameTooltipTextRight16 );
            elseif 17 > count and GameTooltipTextRight17 ~= nil then
                table.insert ( GRM_G.ToolTipTextRight , GameTooltipTextRight17 );
            elseif 18 > count and GameTooltipTextRight18 ~= nil then
                table.insert ( GRM_G.ToolTipTextRight , GameTooltipTextRight18 );
            elseif 19 > count and GameTooltipTextRight19 ~= nil then
                table.insert ( GRM_G.ToolTipTextRight , GameTooltipTextRight19 );
            elseif 20 > count and GameTooltipTextRight20 ~= nil then
                table.insert ( GRM_G.ToolTipTextRight , GameTooltipTextRight20 );
            elseif 21 > count and GameTooltipTextRight21 ~= nil then
                table.insert ( GRM_G.ToolTipTextRight , GameTooltipTextRight21 );
            elseif 22 > count and GameTooltipTextRight22 ~= nil then
                table.insert ( GRM_G.ToolTipTextRight , GameTooltipTextRight22 );
            elseif 23 > count and GameTooltipTextRight23 ~= nil then
                table.insert ( GRM_G.ToolTipTextRight , GameTooltipTextRight23 );
            elseif 24 > count and GameTooltipTextRight24 ~= nil then
                table.insert ( GRM_G.ToolTipTextRight , GameTooltipTextRight24 );
            end
        end

        local tempHolder = {};
        local colors1, colors2
        local goodToAdd = false;
        for i = 1 , #GRM_G.ToolTipTextLeft do

            colors1 , colors2 = nil , nil;
            goodToAdd = false;
            colors1 = { GRM_G.ToolTipTextLeft[i]:GetTextColor() };
            colors2 = { GRM_G.ToolTipTextLeft[i]:GetTextColor() };
            tempHolder = { { GRM_G.ToolTipTextLeft[i]:GetText() , 0 , 0 , 0 } , { GRM_G.ToolTipTextRight[i]:GetText() , 0 , 0 , 0 } };
            if ( tempHolder[1][1] ~= nil and GRM.Trim ( tempHolder[1][1] ) ~= "" ) or ( tempHolder[2][1] ~= nil and GRM.Trim ( tempHolder[2][1] ) ~= "" ) then

                if tempHolder[1][1] ~= nil and colors1 ~= nil then
                    tempHolder[1][2] = colors1[1];
                    tempHolder[1][3] = colors1[2];
                    tempHolder[1][4] = colors1[3];
                    goodToAdd = true;
                end
                if tempHolder[2][1] ~= nil and colors2 ~= nil then
                    tempHolder[2][2] = colors2[1];
                    tempHolder[2][3] = colors2[2];
                    tempHolder[2][4] = colors2[3];
                    goodToAdd = true;
                end
                if goodToAdd then
                    table.insert ( result , tempHolder );
                end
            end
        end
    end
    return result;
end

-- Method:          GRM.RebuildToolTip ( ToolTip , table )
-- What it Does:    Looks at the stored data in the array and if index 1 and index 2 of 2D array both have values, it adds a double line to the tooltip, otherwise a single
-- Purpose:         Blizz seems to have broken the tooltip in BFA on the guild community frame and it has never fully been re-implemented properly. This is so my rebuilding
--                  of the tooltip maintains compatibility with other addons that affect the in-game roster tooltip, notably addons like Raider.io
GRM.RebuildToolTip = function( tTip , leftAndRightTable )
    tTip:AddLine ( " " );
    for i = 6 , #leftAndRightTable do
        if leftAndRightTable[i][2][1] ~= nil then
            if leftAndRightTable[i][1][1] ~= nil and leftAndRightTable[i][1][1] ~= "" then
                tTip:AddDoubleLine ( leftAndRightTable[i][1][1] , leftAndRightTable[i][2][1] , leftAndRightTable[i][1][2] , leftAndRightTable[i][1][3] , leftAndRightTable[i][1][4] , leftAndRightTable[i][2][2] , leftAndRightTable[i][2][3] , leftAndRightTable[i][2][4] );
            else
                tTip:AddDoubleLine ( " " , leftAndRightTable[i][2][1] , leftAndRightTable[i][2][2] , leftAndRightTable[i][2][3] , leftAndRightTable[i][2][4] );
            end
        elseif leftAndRightTable[i][1][1] ~= nil then
            tTip:AddLine ( leftAndRightTable[i][1][1] , leftAndRightTable[i][1][2] , leftAndRightTable[i][1][3] , leftAndRightTable[i][1][4] );
        end
    end
end

-- Method:          GRM.MemberListBlizTooltip_Update ( buttonObject , bool )
-- What it Does:    It rebuilds the mouseover tooltip on the community frame for the GUILD ONLY
-- Purpose:         This only occurs during the OnUpdate of the community frame hybrid scrollframe member list button.
--                  This is to make up for a deficiency where Blizz does not update the tooltip if cursor is stationary
GRM.MemberListBlizTooltip_Update = function( self , isOldRoster , classID , name , guildRank , race , level , presence , zone , memberNote , officerNote )
    local cFrame = CommunitiesFrame;
    if isOldRoster or cFrame:GetSelectedClubId() == GRM_G.gClubID then
        local characterFormat = COMMUNITY_MEMBER_CHARACTER_INFO_FORMAT;
        local characterPresenceMobile = COMMUNITIES_PRESENCE_MOBILE_CHAT;
        local memberNoteFormat = COMMUNITY_MEMBER_NOTE_FORMAT;
        local toolTipMergeInfo = {};

        if classID then
            if GameTooltip:IsVisible() then
                toolTipMergeInfo = GRM.GetAllTooltipText();         -- Raider.io compatibility, and other addons...
            end
            GameTooltip:SetOwner ( self );
            local classInfo = "";
            local color = NORMAL_FONT_COLOR;
            if classID then
                classInfo = C_CreatureInfo.GetClassInfo ( classID );
                color = ( classInfo and RAID_CLASS_COLORS[classInfo.classFile] ) or NORMAL_FONT_COLOR;
            end
            GameTooltip:AddLine ( name , color.r , color.g , color.b );
            GameTooltip:AddLine ( guildRank or "" );
            
            if level and race and classID then
                local raceInfo = C_CreatureInfo.GetRaceInfo ( race );
                if raceInfo and classInfo then
                    GameTooltip:AddLine ( characterFormat:format ( level , raceInfo.raceName , classInfo.className ) , HIGHLIGHT_FONT_COLOR.r , HIGHLIGHT_FONT_COLOR.g , HIGHLIGHT_FONT_COLOR.b , true );
                end
            end
            
            if presence == Enum.ClubMemberPresence.OnlineMobile then
                GameTooltip:AddLine ( characterPresenceMobile , HIGHLIGHT_FONT_COLOR.r , HIGHLIGHT_FONT_COLOR.g , HIGHLIGHT_FONT_COLOR.b , true );
            elseif zone then
                GameTooltip:AddLine ( zone , HIGHLIGHT_FONT_COLOR.r , HIGHLIGHT_FONT_COLOR.g , HIGHLIGHT_FONT_COLOR.b , true);
            end
            
            if memberNote and #memberNote > 0 then
                GameTooltip:AddLine ( memberNoteFormat:format ( memberNote ) , NORMAL_FONT_COLOR.r , NORMAL_FONT_COLOR.g , NORMAL_FONT_COLOR.b , true );
            end

            if officerNote and #officerNote > 0 then
                GameTooltip:AddLine ( memberNoteFormat:format ( officerNote ) , NORMAL_FONT_COLOR.r , NORMAL_FONT_COLOR.g , NORMAL_FONT_COLOR.b , true );
            end

            if #toolTipMergeInfo > 6 then
                GRM.RebuildToolTip ( GameTooltip , toolTipMergeInfo );
            end
            
            GameTooltip:Show();
        end
    end
end

-- Method:          GRM.BuildGuildRosterHotkeyAndMacro ( int , bool )
-- What it Does:    Adds tooltip and creates macro compatibiltiy to hotkey the CTRL-J just like live servers
-- Purpose:         Continuity in experience with GRM from latest expansion live to Classic live
GRM.BuildGuildRosterHotkeyAndMacro = function ( count , noptt )
    count = count or 1;

    local noPTT = false;
    if noptt ~= nil then
        noPTT = noptt;
    end

    local hotkeyTemp = "";
    local keyNum = 0;

    if IsInGuild() then

        for i = 1 , GetNumBindings() do
            local name , _ , b = GetBinding(i);

            if name == "TOGGLEGUILDTAB" then
                hotkeyTemp = b;
                keyNum = i;
                break;
            end
        end

        local listOfKeybinds = { "J" , ";" };
        local keybinds = "";

        if not noPTT and C_VoiceChat.GetPushToTalkBinding() == nil then
            C_Timer.After ( 0.5 , function()
                count = count + 1;

                if count > 30 then
                    noPTT = true;
                end
                GRM.BuildGuildRosterHotkeyAndMacro ( count , noPTT );   -- Checked for 15 seconds, PTT keybind still nil, so it is not API not just loading.
            end);
            return;
        else

            local PushToTalkHotKey = "";

            if not noPTT then
                PushToTalkHotKey = C_VoiceChat.GetPushToTalkBinding()[1];
            end

            GuildMicroButton:SetScript ( "OnEnter" , function( self )
                local hotkey = select ( 3 , GetBinding(keyNum) );                  -- This is the hotkey to open guild and community interface.
                local tooltipTopLine = GRM.L ( "Guild & Communities" );

                if hotkey ~= nil then
                    tooltipTopLine = tooltipTopLine .. " |CFFFFD100(" .. hotkey .. ")";
                end

                GameTooltip:SetOwner ( self , "ANCHOR_NONE" );
                GameTooltip:SetPoint( "BOTTOMLEFT" , GuildMicroButton , "TOPRIGHT" , 0 , 0 );   
                GameTooltip:AddLine( tooltipTopLine , 1 , 1 , 1 );
                GameTooltip:Show();
            end);

            -- for i = 1 , #listOfKeybinds do

            --     -- First, determine if keybind has been set. If it has, let's just replicate
            --     if hotkeyTemp ~= nil and string.find ( hotkeyTemp , "-" ) == nil then       -- I don't want a triple action keybind
            --         keybinds = ( "CTRL-" .. hotkeyTemp );
            --     else
            --         keybinds = ( "CTRL-" .. listOfKeybinds[i] );
            --     end

            --     if GetBindingByKey ( keybinds ) ~= nil or keybinds == PushToTalkHotKey then
            --         keybinds = "";
            --     else
            --         break;
            --     end

            -- end

            -- -- MAX_ACCOUNT_MACROS
            -- if GetNumMacros() < MAX_ACCOUNT_MACROS or GetMacroIndexByName ( "GRM_Roster" ) ~= 0 then

            --     local factionIcon = "inv_bannerpvp_01";
            --     if UnitFactionGroup ( "PLAYER" ) == "Alliance" then
            --         factionIcon = "inv_bannerpvp_02";
            --     end

            --     GRM.CreateMacro (
            --         "/run GuildFrame_Toggle()\n/run GuildFrame_TabClicked ( GuildFrameTab2 )" , 
            --         "GRM_Roster" , 
            --         factionIcon , 
            --         keybinds,
            --         false
            --     );

            -- else
            --     GRM.Report ( GRM.L ( "GRM:" ) .. " " .. GRM.L ( "Unable to create GRM hotkey macro. You currently are at the cap of {num} macros." , nil , nil , GetNumMacros() ) )
            -- end
        end
    end
end

-- Method:          GRM.BindingCurrentlyInUse ( string )
-- What it Does:    Returns true if the current keybinding is in use
-- Purpose:         For editing keybinds be notified if already in use
GRM.BindingCurrentlyInUse = function ( keyBind )
    local result = false;
    local name , c , binding , binding2

    for i = 1 , GetNumBindings() do

        name , c , binding , binding2 = GetBinding(i);

        if keyBind == binding or keyBind == binding2 then
            result = true;
            break;
        end
    end

    if not result then
        name = nil;
    end

    return result , name;
end

-- Method:          GRM.BuildGuildRosterHotkeyAndMacroCLASSIC ( int , bool )
-- What it Does:    Adds tooltip and creates macro compatibiltiy to hotkey the CTRL-J just like live servers
-- Purpose:         Continuity in experience with GRM from latest expansion live to Classic live
GRM.BuildGuildRosterHotkeyAndMacroCLASSIC = function( count , noptt )
    
    if IsInGuild() then
    
        count = count or 1;
        local noPTT = false;
        if noptt ~= nil then
            noPTT = noptt;
        end

        local keyBindGuild = "";
        local keyNum = 0;

        for i = 1 , GetNumBindings() do
            local name , _ , b = GetBinding(i);

            if name == "TOGGLEGUILDTAB" then
                keyBindGuild = b;
                keyNum = i;
                break;
            end
        end
        
        local listOfKeybinds = { "J" , ";" };

        if not noPTT and C_VoiceChat.GetPushToTalkBinding() == nil then
            C_Timer.After ( 0.5 , function()
                count = count + 1;

                if count > 30 then
                    noPTT = true;
                end
                GRM.BuildGuildRosterHotkeyAndMacroCLASSIC ( count , noPTT );   -- Checked for 15 seconds, PTT keybind still nil, so it is not API not just loading.
            end);
            return;
        else
            local PushToTalkHotKey = "";

            if not noPTT then
                PushToTalkHotKey = C_VoiceChat.GetPushToTalkBinding()[1];
            end

            if keyBindGuild == nil then
                -- No keybind set, let's verify the first keybind is not in use anywhere...
                for i = 1 , #listOfKeybinds do
                    if GetBindingByKey ( listOfKeybinds[i] ) == nil and listOfKeybinds[i] ~= PushToTalkHotKey then
                        SetBinding( listOfKeybinds[i] , "TOGGLEGUILDTAB" );
                        break;
                    end
                end
            end

            SocialsMicroButton:SetScript ( "OnEnter" , function( self )
                local hotkeySocial = select ( 3 , GetBinding ( keyNum - 3 ) );                  -- This is the hotkey to open guild and community interface.
                local hotkeyRoster = select ( 3 , GetBinding ( keyNum ) ); 
                local tooltipTopLine = GRM.L ( "Social" );
        
                if hotkeySocial ~= nil then
                    tooltipTopLine = tooltipTopLine .. " |CFFFFD100(" .. hotkeySocial .. ")|r"
                end
        
                if IsInGuild() and hotkeyRoster ~= nil then
                    tooltipTopLine = tooltipTopLine .. " " .. GRM.L ( "Roster" ) .. " |CFFFFD100(" .. hotkeyRoster .. ")|r";
                end
        
                GameTooltip:SetOwner ( self , "ANCHOR_NONE" );
                GameTooltip:SetPoint( "BOTTOMLEFT" , SocialsMicroButton , "TOPRIGHT" , 0 , 0 );   
                GameTooltip:AddLine( tooltipTopLine , 1 , 1 , 1 );
                GameTooltip:AddLine ( NEWBIE_TOOLTIP_SOCIAL , 1 , 0.82 , 0 , 1 , true );
                GameTooltip:Show();
            end);

        end
    end
end

-- Method:          GRM.ConfigureOnlineStatusText()
-- What it Does:    So you don't need to reprocess this over and over, it translates it all just one time.
-- Purpose:         Just resource saving.
GRM.ConfigureOnlineStatusText = function()
    local list = { "( Active )" , "( AFK )" , "( Busy )" , "( Mobile )" , "( Offline )" };

    for i = 1 , #list do
        GRM_G.Status[i] = GRM.L ( list[i] );
    end

end

-- Method:              GRM.RosterFrame()
-- What it Does:        Acts as the OnUpdate handler for hiding the frame when necessary and keeping the player presence status and time in zone up to date.
-- Purpose:             Quality of Life UI controls!
GRM.RosterFrame = function()
    if GRM.GetGuild() then

        if GRM_G.pause and not GRM_UI.GRM_MemberDetailMetaData:IsVisible() and not GRM_UI.MemberDetailFrame:IsVisible() then

            if not GRM_UI.MemberDetailFrame:IsVisible() then
                GRM_G.pause = false;
                if GRM_G.BuildVersion < 80000 then
                    GRM.ClearRosterHighlights();
                end
            end

        end

        -- Ensure pinned to correct window.
        if not GRM_G.pause and ( ( GRM_G.BuildVersion >= 80000 and not CommunitiesFrame.MemberList.ScrollBox:IsMouseOver ( 4 , -20 , -4 , 30 ) ) or ( GRM.S().showMouseoverOld and GRM_G.BuildVersion < 80000 and not GRM_UI.GuildRosterContainer:IsMouseOver ( 4 , -20 , -4 , 30 ) ) ) then

            if not GRM_UI.GRM_MemberDetailMetaData:IsVisible() or ( ( ( GRM_G.BuildVersion >= 80000 and CommunitiesFrame and not CommunitiesFrame.MemberList.ScrollBox:IsMouseOver ( 4 , -20 , -4 , 30 ) ) or ( GRM.S().showMouseoverOld and GRM_G.BuildVersion < 80000 and not GRM_UI.GuildRosterContainer:IsMouseOver ( 4 , -20 , -4 , 30 ) ) ) 
            
            and not DropDownList1MenuBackdrop:IsMouseOver ( 2 , -2 , -2 , 2 ) and not StaticPopup1:IsMouseOver ( 2 , -2 , -2 , 2 ) and not GRM_UI.GRM_MemberDetailMetaData:IsMouseOver ( 1 , -1 , -30 , 1 ) and not GRM_UI.GRM_MemberDetailMetaData.GRM_CoreAltFrame:IsMouseOver( 5 , 5 , 5 , 35 ) and not GRM_UI.GRM_MemberDetailMetaData.GRM_CoreAltFrame.GRM_CoreAltScrollFrameSlider:IsMouseOver ( 1 , 1 , 1 , 3 ) ) then  -- If player is moused over side window, it will not hide it!
                
                if GRM_UI.GRM_MemberDetailMetaData:IsVisible() then
                    GRM.ClearAllFrames( true );
                
                end
            end
        end

        local player = GRM.GetPlayer ( GRM_G.currentName );
        if player then

            -- updates zone change info on the fly, as well as online status.
            if ( time() - GRM_G.CommunitiesUpdateTimer ) > 5 then
                local fullName , zone , isOnline , _;

                for i = 1 , GRM.GetNumGuildies() do
                    fullName, _, _, _, _, zone, _, _, isOnline = GetGuildRosterInfo ( i );
                    if fullName == GRM_G.currentName then
                        player.isOnline = isOnline;

                        if player.zone ~= zone then
                            player.zone = zone;
                            player.timeEnteredZone = time();    -- Resets the time
                        end

                        break;
                    end
                end

                GRM_G.CommunitiesUpdateTimer = time();
            end

            -- Keep this data onUpdate handled...
            if player.isOnline or GRM_G.currentName == GRM_G.addonUser then

                if not GRM_UI.GRM_MemberDetailMetaData.GRM_DateSubmitButton:IsVisible() then
                    if player.zone ~= nil then
                        GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailMetaZoneInfoZoneText:SetText ( player.zone );
                        GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailMetaZoneInfoTimeText2:SetText ( GRM.GetTimePassedInZone ( player.timeEnteredZone ) );
                    end
                    GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailMetaZoneInfoText:Show();
                    GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailMetaZoneInfoZoneText:Show();
                    GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailMetaZoneInfoTimeText1:Show();
                    GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailMetaZoneInfoTimeText2:Show();
                end

                -- ACTIVE
                if player.isOnline and player.status ~= 1 and player.status ~= 2 then  -- 1 = AFK, 2 == BUSY
                    if GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailPlayerStatus:GetText() ~= GRM_G.Status[1] then
                        GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailPlayerStatus:SetTextColor ( 0.12 , 1.0 , 0.0 , 1.0 );
                        GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailPlayerStatus:SetText ( GRM_G.Status[1] );
                    end

                --AFK
                elseif player.status == 1 then
                    if GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailPlayerStatus:GetText() ~= GRM_G.Status[2] then
                        GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailPlayerStatus:SetTextColor ( 1.0 , 0.96 , 0.41 , 1.0 );
                        GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailPlayerStatus:SetText ( GRM_G.Status[2] );
                    end

                -- BUSY
                elseif player.status == 2 then
                    if GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailPlayerStatus:GetText() ~= GRM_G.Status[3] then
                        GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailPlayerStatus:SetTextColor ( 0.77 , 0.12 , 0.23 , 1.0 );
                        GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailPlayerStatus:SetText ( GRM_G.Status[3] );
                    end
                end
                if not GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailPlayerStatus:IsVisible() then
                    GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailPlayerStatus:Show();
                end
                
            -- MOBILE only
            elseif player.isMobile then
                GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailPlayerStatus:SetTextColor ( 0.87 , 0.44 , 0.0 , 1.0 );
                GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailPlayerStatus:SetText ( GRM_G.Status[4] );
                if not GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailPlayerStatus:IsVisible() then
                    GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailPlayerStatus:Show();
                end

            -- AFK
            elseif not player.isOnline then
                if GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailPlayerStatus:GetText() ~= GRM_G.Status[5] then
                    GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailPlayerStatus:SetTextColor ( 0.5 , 0.5 , 0.5 , 1.0 );
                    GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailPlayerStatus:SetText ( GRM_G.Status[5] );
                end
                if not GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailPlayerStatus:IsVisible() then
                    GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailPlayerStatus:Show();
                end

            else
                GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailPlayerStatus:Hide();    -- Don't know what to do!
            end
        else
            GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailMetaZoneInfoText:Hide();
            GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailMetaZoneInfoZoneText:Hide();
            GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailMetaZoneInfoTimeText1:Hide();
            GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailMetaZoneInfoTimeText2:Hide();
        end

        if ( GRM_G.BuildVersion >= 80000 and CommunitiesFrame and not CommunitiesFrame:IsVisible() ) or ( GRM_G.BuildVersion < 80000 and GRM.S().showMouseoverOld and GuildFrame and not GuildFrame:IsVisible() ) then
            GRM.ClearAllFrames( true );         -- Reset frames and hide metadata frame...
        end
    end

end

-- Method:          GRM.AltButtonPos(int)
-- What it Does:    Returns the horizontal and vertical coordinates for the button position on frame
-- Purpose:         To adjust the position of the AddAlt button based on the number of alts.
GRM.AltButtonPos = function ( index )
    local result;
    if index == 0 then
        result = { 2 , -16 };
    elseif index == 1 then
        result = { 32 , -20 };
    elseif index == 2 then
        result = { -32 , -37 };
    elseif index == 3 then
        result = { 32 , -37 };
    elseif index == 4 then
        result = { -32 , -54 };
    elseif index == 5 then
        result = { 32 , -54 };
    elseif index == 6 then
        result = { -32 , -71 };
    elseif index == 7 then
        result = { 32 , -71 };
    elseif index == 8 then
        result = { -32 , -88 };
    elseif index == 9 then
        result = { 32 , -88 };
    elseif index == 10 then
        result = { -32 , -103 };
    elseif index == 11 then
        result = { 32 , -103 };
    else -- is 12+ alts
        result = { -32 , -120 };
    end
    return result;
end

-- Method:          GRM.GetLevelRange()
-- What it Does:    Returns a text string of the current level range
-- Purpose:         Clean and clear reporting to the player what levels will be reported to the log.
GRM.GetLevelRange = function()
    local result = "";
    if GRM.S().recordLevelUp then
        result = "|cffffd100" .. GRM.L ( "Reporting:" ) .. "|r|cff00ccff";
        local initialNumber = "";
        local caps = { 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 };
        local addon = "";

        local atLeastOne = false;
        if GRM.S().levelReportMin == GRM_G.LvlCap and GRM.S().levelFilters[#GRM.S().levelFilters] then
            initialNumber = tostring ( GRM_G.LvlCap );
            atLeastOne = true;
        elseif GRM.S().levelReportMin < GRM_G.LvlCap then
            initialNumber = GRM.S().levelReportMin .. "-" .. GRM_G.LvlCap;
            atLeastOne = true;
        end

        local count = 0;
        for i = 1 , #GRM.S().levelFilters do
            if GRM.S().levelFilters[i] and GRM.S().levelReportMin > caps[i] then
                -- This is a standalone number...
                if count == 0 then
                    addon = caps[i];
                    count = 1;
                else
                    addon = addon .. " , " .. caps[i];
                end
            elseif GRM.S().levelReportMin <= caps[i] then
                break;
            end
        end
        if addon ~= "" then
            result = result .. " " .. addon;
            if atLeastOne then
                result = result .. " , " .. initialNumber;
            end
        elseif atLeastOne then
            result = result .. " " .. initialNumber;
        else
            result = GRM.L ( "No Levels to Report to Log" );
        end
        GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_ScanningOptionsFrame.GRM_RosterMinLvlOverlayNoteText:SetTextColor ( 0 , 0.82 , 1 , 1 );
    else
        result = GRM.L ( "No Levels to Report to Log" );
        GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_ScanningOptionsFrame.GRM_RosterMinLvlOverlayNoteText:SetTextColor ( 1 , 0 , 0 , 1 );
    end

    return result;
end

-- Method:          GRM.CopyFromJoinDate()
-- What it Does:    Imports the promo date from a verified Join Date
-- Purpose:         Just another tool to ease player abilities for setting dates
GRM.CopyFromJoinDate = function()
    local player = GRM.GetPlayer ( GRM_G.currentName );

    if player then
        -- Set it to rank history
        local tStamp = GRM.DeepCopyArray ( player.joinDateHist[1] );
        player.rankHist[1][1] = player.rankName;
        player.rankHist[1][2] = tStamp[1];
        player.rankHist[1][3] = tStamp[2];
        player.rankHist[1][4] = tStamp[3];
        player.rankHist[1][5] = tStamp[4];
        player.rankHist[1][6] = time();
        player.rankHist[1][7] = true
        player.rankHist[1][8] = 1;

        player.promoteDateUnknown = false;

        if player.isOnline then
            if player.zone ~= nil then
                GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailMetaZoneInfoZoneText:SetText ( player.zone );                                     -- Zone
                GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailMetaZoneInfoTimeText2:SetText ( GRM.GetTimePassedInZone ( player.timeEnteredZone ) );              -- Time Passed
            end
            GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailMetaZoneInfoText:Show();
            GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailMetaZoneInfoZoneText:Show();
            GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailMetaZoneInfoTimeText1:Show();
            GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailMetaZoneInfoTimeText2:Show();
        end

        GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailRankDateTxt:SetText ( GRM.L ( "Promoted:" ) .. " " .. GRM_UI.GRM_MemberDetailMetaData.GRM_JoinDateText:GetText() );
        GRM_UI.GRM_MemberDetailMetaData.GRM_SetPromoDateButton:Hide();
        GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailRankDateTxt:Show();

        if GRM.S().syncEnabled then
            local syncRankFilter = GRM.S().syncRank;
            if GRM.S().exportAllRanks then
                syncRankFilter = GuildControlGetNumRanks() - 1;
            end
            GRMsync.SendMessage ( "GRM_SYNC" , GRM_G.PatchDayString .. "?GRM_PD?" .. syncRankFilter .. "?" .. player.name .. "?" .. tostring ( player.rankHist[1][5] ) .. "?" .. tostring( player.rankHist[1][6] ) , "GUILD");
        end

        GRM_UI.Unpause();
        -- Update Audit Frames.
        if GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame:IsVisible() then
            GRM.RefreshAuditFrames ( true , true );
        end
    end

    GRM_UI.GRM_MemberDetailMetaData.GRM_altDropDownOptions:Hide();
end

-- Method:          GRM.CopyFromPromoDate()
-- What it Does:    Imports the join date from a verified Promo Date
-- Purpose:         Just another tool to ease player abilities for setting dates
GRM.CopyFromPromoDate = function()
    local player = GRM.GetPlayer ( GRM_G.currentName );
    local showBdayText = false;
    local rankButton = false;
    local formatBdayStamp = "";

    if player then

        local tStamp = GRM.DeepCopyArray ( player.rankHist[1] );
        player.joinDateHist[1][1] = tStamp[2];
        player.joinDateHist[1][2] = tStamp[3];
        player.joinDateHist[1][3] = tStamp[4];
        player.joinDateHist[1][4] = tStamp[5];
        player.joinDateHist[1][5] = time();
        player.joinDateHist[1][6] = true;
        player.joinDateHist[1][7] = 1;

        player.joinDateUnknown = false;

        if player.events[2][1][1] ~= 0 then
            showBdayText = true;
            formatBdayStamp = GRM.FormatTimeStamp ( player.events[2][3] , false , true );
        end

        local joinDate = GRM.FormatTimeStamp ( { player.joinDateHist[1][1] , player.joinDateHist[1][2] , player.joinDateHist[1][3] }  , false );

        -- Update timestamp to officer note.
        GRM.AddTimeStampToNote ( player.name , joinDate );

        -- Gotta update the event tracker date too!
        player.events[1][1][1] = tStamp[2];
        player.events[1][1][2] = tStamp[3];
        player.events[1][1][3] = tStamp[4];
        player.events[1][2] = false;  -- Gotta Reset the "reported already" boolean!
        GRM.RemoveFromCalendarQue ( player.name , 1 , nil );

        -- Should definitely refresh the frame here if necessary... prevent mouse tooltip errors
        if GRM_UI.GRM_RosterChangeLogFrame.GRM_EventsFrame:IsVisible() then
            GRM.RefreshAddEventFrame()
        end

        if player.rankHist[1][2] == 0 and not player.promoteDateUnknown then
            rankButton = true;
        end

        -- Need player index to get this info.
        if player.isOnline then
            if player.zone ~= nil then
                GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailMetaZoneInfoZoneText:SetText ( player.zone );                                       -- Zone
                GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailMetaZoneInfoTimeText2:SetText ( GRM.GetTimePassedInZone ( player.timeEnteredZone ) );                 -- Time Passed
            end
            GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailMetaZoneInfoText:Show();
            GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailMetaZoneInfoZoneText:Show();
            GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailMetaZoneInfoTimeText1:Show();
            GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailMetaZoneInfoTimeText2:Show();
        end

        -- Let's send the changes out as well!
        if GRM.S().syncEnabled then
            local syncRankFilter = GRM.S().syncRank;
            if GRM.S().exportAllRanks then
                syncRankFilter = GuildControlGetNumRanks() - 1;
            end
            GRMsync.SendMessage ( "GRM_SYNC" , GRM_G.PatchDayString .. "?GRM_JD?" .. syncRankFilter .. "?" .. player.name .. "?" .. tostring ( player.joinDateHist[1][5] ) .. "?" .. player.joinDateHist[1][4] .. "?" .. tostring ( GRM.S().joinDateDestination ) , "GUILD");
        end

        GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailJoinDateButton:Hide();
        GRM_UI.GRM_MemberDetailMetaData.GRM_JoinDateText:SetText ( joinDate )
        GRM_UI.GRM_MemberDetailMetaData.GRM_JoinDateText:Show();
        if rankButton then
            GRM_UI.GRM_MemberDetailMetaData.GRM_SetPromoDateButton:Show();
        else
            GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailRankDateTxt:Show();
        end

        -- Birthday Logic restoration
        if GRM.S().showBDay and not GRM_UI.GRM_MemberDetailMetaData.GRM_BirthdayText:IsVisible() and not GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailBirthdayButton:IsVisible() then
            if showBdayText then
                GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailBirthdayButton:Hide();
                GRM_UI.GRM_MemberDetailMetaData.GRM_BirthdayText:SetText ( formatBdayStamp );
                GRM_UI.GRM_MemberDetailMetaData.GRM_BirthdayText:Show();
            else
                GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailBirthdayButton:Show();
                GRM_UI.GRM_MemberDetailMetaData.GRM_BirthdayText:Hide();
            end
        end

        GRM_UI.Unpause();
        -- Update the Audit Frames!
        if GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame:IsVisible() then
            GRM.RefreshAuditFrames ( true , true );
        end
        
    end

    GRM_UI.GRM_MemberDetailMetaData.GRM_altDropDownOptions:Hide();
end

-- Method:          GRM.GetPlayerClass ( string )
-- What it Does:    Returns the string name of the class that is also region compatible
-- Purpose:         Useful in UI design to pull the class so you can pull the class RGB colors, but there can be other uses too.
GRM.GetPlayerClass = function ( playerName )
    local class = "";
    local player = GRM.GetPlayer ( playerName );

    if player then
        class = player.class;

    end

    return class;
end

-- Method:          GRM.GetPlayerClassByGUID ( string )
-- What it Does:    Returns the non-localized class name of the give player by GUID
-- Purpose:         In case of a failure in obtaining class in a sync, which has happened and data was lost, this can restore it.
GRM.GetPlayerClassByGUID = function ( guid )
    local class = "";

    if guid and guid ~= "" and C_PlayerInfo.GUIDIsPlayer ( guid ) then
        class = select ( 2 , GetPlayerInfoByGUID ( guid ) );
        if not class then
            -- try 2nd time
            class = select ( 2 , GetPlayerInfoByGUID ( guid ) );
        end
            
    end

    return class;
end
     
-- Method:          GRM.GetClassColorRGB ( string )
-- What it Does:    Returns the 0-1 RGB color scale for the player class
-- Purpose:         Easy class color tagging for UI feature.
GRM.GetClassColorRGB = function ( className , getHex )
    -- Defaults to color white if unable to identify.
    local result = { 1 , 1 , 1 };

    if not className then
        if getHex then
            return "";
        else
            return result;
        end
    end
    
    className = string.upper ( string.gsub ( className , " " , "" ) ); -- just to ensure formatting properly

    if getHex then
        result = "|c" .. RAID_CLASS_COLORS[className].colorStr
    else
        local colors = RAID_CLASS_COLORS[className]
        result = { colors.r , colors.g , colors.b }
    end

    return result;
end

-- Method:          GRM.GetStringClassColorByName ( string )
-- What it Does:    Returns the RGB Hex code of the given class of the player named
-- Purpose:         Useful for carrying over class name with tagged colors into a string, without needing to change the hwole string's color
GRM.GetStringClassColorByName = function ( name )
    local guildData = GRM.GetGuild();
    local hasAlts = false;
    local result = "";
    local player;

    -- Append the server name to it if necessary
    if string.find ( name , "-" ) == nil then
        name = name .. "-" .. GRM_G.realmName;
    end
    
    if guildData then

        player = guildData[name];

        if player then

            result = GRM.GetClassColorRGB ( player.class , true );
            if GRM.PlayerHasAlts ( player ) then
                hasAlts = true;
            end

        elseif GRM.GetFormerMembers()[name] then

            player = GRM.GetFormerMembers()[name];
            result = GRM.GetClassColorRGB ( player.class , true );

            if #player.altsAtTimeOfLeaving > 0 then
                hasAlts = true;
            end

        end
    end
    return result , hasAlts;
end

-- Method:          GRM.GetClassifiedName ( string , boolean )
-- What it Does:    Returns the player's name as a string, with the proper class coloring
-- Purpose:         Nice, simple UI feature for ease of knowing person's class by name color.
GRM.GetClassifiedName = function ( playerFullName , removeServer )
    local result = GRM.GetStringClassColorByName ( playerFullName );
    removeServer = removeServer or ( not GRM.S().useFullName );
    if result == "" then
        if removeServer then 
            result = GRM.SlimName ( playerFullName );
        else
            result = playerFullName;
        end
    else
        if removeServer then
            result = result .. GRM.SlimName ( playerFullName ) .. "|r";
        else
            result = result .. playerFullName .. "|r";
        end
    end
    return result
end

-- Method:          GRM.rgbToHex ( array )
-- What it Does:    Returns the hexadecimal code in modified string format for WOW addons to display the string that given rgb color
-- Purpose:         UI feature for easy fontstring coloring management.
GRM.rgbToHex = function ( rgbTable )
    local hexadec = ""
	for i = 1 , #rgbTable do
		local hex = "";

        -- Hexadecimal algorithm
		while ( rgbTable[i] > 0 ) do
			local index = math.fmod ( rgbTable[i] , 16 ) + 1;
			rgbTable[i] = math.floor ( rgbTable[i] / 16);
			hex = string.sub ( "0123456789ABCDEF" , index , index ) .. hex;	
		end

		if #hex == 0 then
			hex = "00";
        elseif #hex == 1 then
			hex = "0" .. hex;
		end

		hexadec = hexadec .. hex
    end
    -- add the |CFF so the warcraft game knows to acknowledge the hex code
    return "|CFF" .. hexadec;
end

-- Method:          ConvertRGBScale ( float , boolean )
-- What it Does:    Converts any RGB values on 1.0 scale to 255 scale, or the other way around
-- Purpose:         255 is standard RGB scaling, which I am personally comfortable with, but Blizz's internal system uses 1.0 scale. This is just QoL
GRM.ConvertRGBScale = function ( value , to255 )
    -- 1.0 scale to 255 scale
    if to255 then
        value = math.floor ( ( value * 255 ) + 0.5 );
    else
        value = value / 255;
    end
    return value
end

-----------------------------------
--- Player Window Edit Logic ------
-----------------------------------

-- Method:          GRM.IsMouseOverAltButton()
-- What it Does:    Returns true if players is over any of the alt listing names
-- Purpose:         So when a player right-clicks the mouseOver screen, it can either let you know you are already over an AltName Button, so no need to do more work
--                  Or, if you aren't, then you can check to see if you are moused over the other fontstrings.
GRM.IsMouseOverAltButton = function()
    local result = false;

    for i = 1 , #GRM_UI.GRM_MemberDetailMetaData.GRM_CoreAltFrame.GRM_CoreAltScrollFrame.GRM_CoreAltScrollChildFrame.allFrameButtons do
        if GRM_UI.GRM_MemberDetailMetaData.GRM_CoreAltFrame.GRM_CoreAltScrollFrame.GRM_CoreAltScrollChildFrame.allFrameButtons[i][1]:IsMouseOver() then
            result = true;
            break;
        end
    end
    return result;
end

-- Method:          GRM.GetSelectedName()
-- What it Does:    Returns a table with the name of the player, the altName, and the guild.
-- Puspose:         To easily pass the info on without having to use a global variable, and set one function to all right click logic on the main window.
GRM.GetSelectedName = function( name )
    local focusName , altName , isMain = nil , nil , false;

    if name then
        focusName = name;
        altName = name;

        if GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailMainText:IsVisible() then
            isMain = true;
        end
    end

    return { focusName , altName , isMain };
end

-- Method:          GRM.MouseOverClearAllTooltips()
-- What it Does:    Hides all GRM tooltips
-- Purpose:         When using right-click context menu it makes sense to clear any tooltip as window appears.
GRM.MouseOverClearAllTooltips = function()
    GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailRankToolTip:Hide();
    GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailJoinDateToolTip:Hide();
    GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailServerNameToolTip:Hide();
    GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailNotifyStatusChangeTooltip:Hide();
    GRM_UI.GRM_MemberDetailMetaData.GRM_BirthdayTooltip:Hide();
end

-- Method:          GRM.SetAltAsMainDropDownMenuLogic ( table )
-- What it Does:    using the right click dropdown menu, it sets the given chosen name as the main
-- Purpose:         Bring in customizability and flexibility and ease of configuration to the player
GRM.SetAltAsMainDropDownMenuLogic = function ( altDetails )
    if altDetails[1] ~= altDetails[2] then
        GRM.SetMain ( altDetails[2] , time() );

        -- Now send Comm to sync details.
        if GRM.S().syncEnabled then
            local syncRankFilter = GRM.S().syncRank;
            if GRM.S().exportAllRanks then
                syncRankFilter = GuildControlGetNumRanks() - 1;
            end
            GRMsync.SendMessage ( "GRM_SYNC" , GRM_G.PatchDayString .. "?GRM_MAIN?" .. syncRankFilter .. "?" .. altDetails[1] .. "?" .. altDetails[2] .. "?" .. tostring ( time() ) , "GUILD");
        end
    else
        -- No need to set as main yet... let's set player to main here.
        local player = GRM.GetPlayer ( altDetails[1] );
        if player then

            GRM.SetMain ( altDetails[1] , time() );
            if not GRM_UI.GRM_DropDownList1AttachmentFrame.pausedPreviously then
                GRM_UI.Unpause();
            end

            local alts = GRM.GetListOfAlts ( player );
            if #alts > 0 then
                
                if GRM.S().syncEnabled then
                    local syncRankFilter = GRM.S().syncRank;
                    if GRM.S().exportAllRanks then
                        syncRankFilter = GuildControlGetNumRanks() - 1;
                    end
                    GRMsync.SendMessage ( "GRM_SYNC" , GRM_G.PatchDayString .. "?GRM_MAIN?" .. syncRankFilter .. "?" .. alts[1][1] .. "?" .. altDetails[1] .. "?" .. tostring ( time() ) , "GUILD");
                end
            else

                if GRM.S().syncEnabled then
                    local syncRankFilter = GRM.S().syncRank;
                    if GRM.S().exportAllRanks then
                        syncRankFilter = GuildControlGetNumRanks() - 1;
                    end
                    GRMsync.SendMessage ( "GRM_SYNC" , GRM_G.PatchDayString .. "?GRM_MAIN?" .. syncRankFilter .. "?" .. altDetails[1] .. "?" .. altDetails[2] .. "?" .. tostring ( time() ) , "GUILD");
                end
            end
            -- Now send Comm to sync details.
            
            GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailMainText:Show();
            GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailAltText:Hide();
        end
    end
    if GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailMainText:IsVisible() and GRM_G.currentName ~= altDetails[2] then
        GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailMainText:Hide();
        GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailAltText:Show();
    end                
    if GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame:IsVisible() then
        GRM.RefreshAuditFrames ( true , true );
    end
    if GRM_UI.GRM_MemberDetailMetaData.GRM_AltGroupingScrollBorderFrame:IsVisible() then
        GRM.BuildAltGroupingScrollFrame( GRM_G.currentName );
    end
    GRM.Report ( GRM.L ( "{name} is now set as \"main\"" , GRM.GetClassifiedName ( altDetails[2] , true ) ) );
end

-- Method:          GRM.DemoteMainToAltDropDownMenuLogic ( table )
-- What it Does:    Demotes a player from main and sets them as alt and configures the UI to reflect it
-- Purpose:         Flexibility and quality of life for the player
GRM.DemoteMainToAltDropDownMenuLogic = function ( altDetails )
    if altDetails[1] ~= altDetails[2] then
        GRM.DemoteFromMain ( altDetails[2] , time() );

        if GRM.S().syncEnabled then
            local syncRankFilter = GRM.S().syncRank;
            if GRM.S().exportAllRanks then
                syncRankFilter = GuildControlGetNumRanks() - 1;
            end
            GRMsync.SendMessage ( "GRM_SYNC" , GRM_G.PatchDayString .. "?GRM_RMVMAIN?" .. syncRankFilter .. "?" .. altDetails[1] .. "?" .. altDetails[2] .. "?" .. tostring ( time() ) , "GUILD");
        end
    else
        -- No need to set as main yet... let's set player to main here.
        local player = GRM.GetPlayer ( altDetails[1] );
        if player then
            GRM.DemoteFromMain ( altDetails[1] , time() );
            if not GRM_UI.GRM_DropDownList1AttachmentFrame.pausedPreviously then
                GRM_UI.Unpause();
            end

            local alts = GRM.GetListOfAlts ( player );

            if #alts > 0 then
                
                if GRM.S().syncEnabled then
                    local syncRankFilter = GRM.S().syncRank;
                    if GRM.S().exportAllRanks then
                        syncRankFilter = GuildControlGetNumRanks() - 1;
                    end
                    GRMsync.SendMessage ( "GRM_SYNC" , GRM_G.PatchDayString .. "?GRM_RMVMAIN?" .. syncRankFilter .. "?" .. alts[1][1] .. "?" .. altDetails[1] .. "?" .. tostring ( time() ) , "GUILD");
                end
            else
                if GRM.S().syncEnabled then
                    local syncRankFilter = GRM.S().syncRank;
                    if GRM.S().exportAllRanks then
                        syncRankFilter = GuildControlGetNumRanks() - 1;
                    end
                    GRMsync.SendMessage ( "GRM_SYNC" , GRM_G.PatchDayString .. "?GRM_RMVMAIN?" .. syncRankFilter .. "?" .. altDetails[1] .. "?" .. altDetails[2] .. "?" .. tostring ( time() ) , "GUILD");        -- both alt details will be same name...
                end
            end
            GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailMainText:Hide();
        end
    end
    if GRM_G.currentName == altDetails[2] then
        GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailMainText:Hide();
        GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailAltText:Show();
    end        
    if GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame:IsVisible() then
        GRM.RefreshAuditFrames ( true , true );
    end
    if GRM_UI.GRM_MemberDetailMetaData.GRM_AltGroupingScrollBorderFrame:IsVisible() then
        GRM.BuildAltGroupingScrollFrame( GRM_G.currentName );
    end
    GRM.Report ( GRM.L ( "{name} is no longer set as \"main\"" , GRM.GetClassifiedName ( altDetails[2] , true ) ) );
end

-- Method:          GRM.KickAllBanned()
-- What it Does:    Triggers the frames to load in the macro tool to ban ALL the players currently still in the guild but are banned
-- Purpose:         Easy cleanup of removal of a player by manual banning, and all their alts.
GRM.KickAllBanned = function()
    GRM_G.KickAllBannedTable = {};

    local names = select ( 2 , GRM.GetNumberOfPlayerSBannedCurrentlyInGuild() );
    local c = 1;

    if names ~= nil then
        for i = 1 , #names do
            if names[i][1] ~= GRM_G.addonUser then
                GRM_G.KickAllBannedTable[c] = {};
                GRM_G.KickAllBannedTable[c].name = names[i][1];
                GRM_G.KickAllBannedTable[c].class = names[i][2];
                GRM_G.KickAllBannedTable[c].lastOnline = names[i][3];
                GRM_G.KickAllBannedTable[c].action = GRM.L ( "Kick" );
                GRM_G.KickAllBannedTable[c].macro = "/gremove";
                GRM_G.KickAllBannedTable[c].isHighlighted = false;
                GRM_G.KickAllBannedTable[c].mainName = GRM.GetMainName ( names[i][1] , true );
                GRM_G.KickAllBannedTable[c].customMsg = GRM.L ( "Kicking Banned Player" );
                c = c + 1;
            end
        end
    end

    if #GRM_G.KickAllBannedTable > 0 then
        -- Bring popup reminder to select it...
        GRM.Report ( GRM.L ( "GRM:" ) .. " " .. GRM.L ( "Kick macro created. Press Hotkey to Remove Banned Players Still in Guild" ) );
        GRM_G.kickBannedControl = true;
        GRM_UI.GRM_ToolCoreFrame.TabPosition = 1; -- Since we are removing players it will now function by setting it to default kick tab
        if not GRM_UI.GRM_ToolCoreFrame or ( GRM_UI.GRM_ToolCoreFrame and not GRM_UI.GRM_ToolCoreFrame:IsVisible() ) then
            GRM_UI.GRM_ToolCoreFrame:Show();
        elseif GRM_UI.GRM_ToolCoreFrame:IsVisible() then
            GRM_UI.RefreshManagementTool( false , GRM_G.kickBannedControl );
            GRM_G.kickBannedControl = false;
        end
        
    end

    -- Refresh the frames!
    GRM.RefreshSelectHybridFrames ( true , true , true , false );
end

-----------------------------------
--------- MACRO MANAGEMENT --------
-----------------------------------

-- Method:          GRM.CreateMacro ( string , string , string , string )
-- What it Does:    Builds a general non-character specific macro based on given arguments
-- Purpose:         To be able to auto-generate a macro, due to limitations of executing things in the code, we just create an in-game one-button to click
GRM.CreateMacro = function ( macroText , name , icon , keyBind , isLogOff )

    if GRM_G.MacroDelay and not GRM_G.inCombat then
        GRM_G.MacroDelay = false;
    end

    if not GRM_G.inCombat and not GRM_G.MacroDelay then
        -- First, let's check if the macro exists
        local index = GetMacroIndexByName ( name );
        local canBuild = false;

        if index == 0 and GetNumMacros() < MAX_ACCOUNT_MACROS then
            -- no macro yet created
            CreateMacro ( name , icon , macroText );
            canBuild = true;
        elseif index ~= 0 then
            -- edit the macro that already exists...
            EditMacro ( index , name , icon , macroText );
            canBuild = true;
        else
            -- Not enough macro slots...
            GRM.Report ( GRM.L ( "GRM:" ) .. " " .. GRM.L ( "Unable to create GRM hotkey macro. You currently are at the cap of {num} macros." , nil , nil , GetNumMacros() ) )
        end

        -- Set Keybind if not nil
        if canBuild and keyBind and keyBind ~= "" and not isLogOff then
            SetBindingMacro ( keyBind , name );
        end
    elseif not isLogOff and GRM_G.inCombat then
        if not GRM_G.MacroDelay then
            GRM.Report ( GRM.L ( "GRM:" ) .. " " .. GRM.L ( "Unable to create hotkey macro. Player is currently in combat and action is restricted. It will auto-build once out of combat." ) );
            GRM_G.MacroDelay = true;
        end

        -- Retry after 5 seconds.
        C_Timer.After ( 5 , function()
            GRM.CreateMacro ( macroText , name , icon , keyBind , isLogOff );
        end);
    end
end

-- Method:          GRM.CleanupMacros ( int )
-- What it Does:    Clears out known existing macros and keybinds used by this addon for temp abilities, like invite all to guild, or gkick all alts.
-- Purpose:         Prevent macro mess.
GRM.CleanupMacros = function( delay )
    local macros = { "GRM_Inv" , "GRM_Kick" };

    if not delay then
        delay = 0;
    else
        GRM.Report ( GRM.L ( "Macro will auto-remove after {num} seconds." , nil , nil , delay ) );
    end
    C_Timer.After ( delay , function()
        for i = 1 , #macros do
            DeleteMacro ( macros[i] );
        end
    end);
end

-- Method:          GRM.BuildMacroInviteAll ( string , array )
-- What it Does:    Creates a string to be used to set a macro for inviting all players.
-- Purpose:         Added functionality for the player of the addon
GRM.BuildMacroInviteAll = function ( slashCommand , listOfPlayers )
    local newMacroString = "";
    for i = 1 , #listOfPlayers do
        if i == 1 then
            newMacroString = slashCommand .. " " .. listOfPlayers[i][1];
        else
            local finalString = ( newMacroString .. "\n" .. slashCommand .. " " .. listOfPlayers[i][1] );
            if #finalString < 256 then
                newMacroString = finalString;
                -- ELSE - announce and que multiple macros?
            end
        end
    end
    return newMacroString;
end

-- Method:          GRM.BanSpecificPlayer ( string , boolean , string )
-- What it Does:    Bans just a specific player, either in the guild database, or the left player database
-- purpose:         To maintain exact function of banning a player without doing other tasks.
GRM.BanSpecificPlayer = function ( playerName , isAlt , banReason , personWhoBanned )
    local player = GRM.GetFormerMembers()[playerName];
    local isFoundInGuild = false;

    if not personWhoBanned then
        personWhoBanned = "";
    end

    if player then
        GRM_G.tempAddBanClass = player.class;
    else
        player = GRM.GetGuild()[playerName];
        if player then
            isFoundInGuild = true;
            GRM_G.tempAddBanClass = player.class;
        end
    end

    if player then
        if isFoundInGuild then
            if player.bannedInfo[1] then
                -- Player was previously banned! This is just an update!
                if not isAlt then
                    GRM.Report ( GRM.L ( "{name}'s Ban Info has Been Updated!" , GRM.GetClassifiedName ( playerName , false ) ) );
                end
            else
                player.bannedInfo[1] = true;
                player.bannedInfo[2] = time();
            end
        else
            if player.bannedInfo[1] then
                -- Player was previously banned! This is just an update!
                if not isAlt then
                    GRM.Report ( GRM.L ( "{name}'s Ban Info has Been Updated!" , GRM.GetStringClassColorByName ( playerName ) .. playerName .. "|r" ) );
                end
            else
                player.bannedInfo[1] = true;
                player.bannedInfo[2] = time();
            end
        end

        player.bannedInfo[3] = false;
        player.bannedInfo[4] = personWhoBanned;
        player.reasonBanned = banReason;
    end
end


------------------------------------
---- END OF ALT MANAGEMENT ---------
------------------------------------

------------------------------------
------ METADATA TRACKING LOGIC -----
--- Reporting, Live Tracking, Etc --
------------------------------------

-- Method:          GRM.AddMemberRecord( playerData , bool , playerData , bool , table , bool )
-- What it Does:    Builds Member Record into Guild History with various metadata
-- Purpose:         For reliable guild data tracking.
GRM.AddMemberRecord = function ( memberInfo , isReturningMember , oldMemberInfo , liveJDetected , logEntryMetaData , isTransfer )
    
    -- -- First things first... ensure the player is not already added...
    local guildData = GRM.GetGuild();

    if not guildData or ( guildData[memberInfo.name] ~= nil and guildData[memberInfo.name].GUID == memberInfo.GUID ) then
        return -- Already in the guild. Abort!!!
    end;
    
    local name = memberInfo.name;
    local timeSeconds = time();
    local liveJoinDetected = false;
    if liveJDetected ~= nil then
        liveJoinDetected = true;
    end

    if name == "" or name == nil then
        name = GRM.GetFullNameClubMember ( memberInfo.GUID );
    end
    if name == "" or name == nil then
        return;
    end
    -- Add index to guild table.
    guildData[name] = {};

    local oldMemberData = GRM.GetFormerMembers();
    -- This is for an edge case if a player namechanges a toon, then joins the guild with a new toon sharing the same old name. GRM will update the left database to the player's new name, even though they are no longer in the guild.
    if oldMemberData[name] then
        local updatedName = GRM.GetFullNameClubMember ( oldMemberData[name].GUID )
        if updatedName ~= "" and updatedName ~= name then
            oldMemberData[name].name = updatedName;
            oldMemberData[updatedName] = GRM.DeepCopyArray ( oldMemberData[name] );
            oldMemberData[updatedName].name = updatedName;
        end
        oldMemberData[name] = nil;
    end

    local member = guildData[name];
                                                            -- Old format table index number (if no number it is a post database overhaul variable)
    member["name"] = name;                       -- 1
    member["rankName"] = memberInfo.rankName;               -- 4
    member["rankIndex"] = memberInfo.rankIndex;             -- 5
    member["level"] = memberInfo.level;                     -- 6
    member["note"] = memberInfo.note;                       -- 7
    member["officerNote"] = memberInfo.officerNote;         -- 8
    member["class"] = memberInfo.class;                     -- 9
    member["isMain"] = false;                               -- 10
    member["altGroupModified"] = 0;                         -- For when alt or main status changes
    member["mainStatusChangeTime"] = 0;                       --
    member["altGroup"] = "";
    member["altsAtTimeOfLeaving"] = {};                     -- Variable used when a player leaves the guild
    member["mainAtTimeOfLeaving"] = {};                     -- Easy way to track who is their previous main when they returned to the guild.
    member["bannedInfo"] = { false , 0 , false , "" };      -- 17   {isBanned , epochStamp, unbanned , whoBanned }
    member["reasonBanned"] = "";                            -- 18
    member["rankHist"] = { { memberInfo.rankName , 0 , 0 , 0 , "0" , 0 , false , 1 } };      -- { rankName , day , month , year , timeInEpoch , timeChangedManually , isVerified , typeOfRankChange }   
    member["joinDateHist" ] = { { 0 , 0 , 0 , "0" , 0 , false , 1 } };                       -- { day , month , year , timeInEpoch , timeChangedManually , isVerified , join/leave } - 1 = join; 2 = leave;

    member["events"] = { { { 0 , 0 , 0 } , false , "" } , { { 0 , 0 , 0 } , false , "" , 0 } };                                 -- 22 Position 1 = anniversary , Position 2 = birthday = { { day , month , year } , reportedToCalendar , customDescription , timestamp }
    member["customNote"] = { true , 0 , "" , GRM.S().syncRankCustom , false , "" };    -- 23 { syncEnabled , epochStampOfEdit , "NameOfPlayerWhoEdited" , rankFilterIndex , rankModifiedAtleastOnce , "customNoteString" }
    
    if memberInfo.lastOnline then
        member["lastOnline"] = memberInfo.lastOnline
    else
        member["lastOnline"] = 0;                               -- 24
    end
    
    member["recommendToKick"] = false;                      -- 27
    member["recommendToDemote"] = false;
    member["recommendToPromote"] = false;
    member["zone"] = memberInfo.zone;                       -- 28
    member["achievementPoints"] = memberInfo.achievementPoints;  -- 29
    member["isMobile"] = memberInfo.isMobile;               -- 30
    member["guildRep"] = memberInfo.rep;                    -- 31
    member["timeEnteredZone"] = timeSeconds;                -- 32
    member["isOnline"] = memberInfo.isOnline;               -- 33
    member["status"] = memberInfo.status;                   -- 34 AFK, Active, Busy
    member["joinDateUnknown"] = false;                      -- 40
    member["promoteDateUnknown"] = false                    -- 41
    member["GUID"] = memberInfo.GUID;                       -- 42
    member["isUnknown"] = false;                            -- 43
    member["birthdayUnknown"] = false;                      -- 44
    member["safeList"] = {}                                 -- Updated R1.92    - Kick , promote , demote
    member.safeList["kick"] = { false , false , 0 , 0 };    -- Macro Tool monitoring protection
    member.safeList["promote"] = { false , false , 0 , 0 };
    member.safeList["demote"] = { false , false , 0 , 0 };
    member["race"] = memberInfo.race;                       -- 46
    member["sex"] = memberInfo.sex;                         -- 47                                             
    member.faction = memberInfo.faction;

    if GRM_G.BuildVersion >= 80000 then
        member["MythicScore"] = memberInfo.MythicScore;
    end

    -- HARDCORE MODE
    if GRM_G.HardcoreActive then
        member.HC = {};
        member.HC.isDead = false;
        member.HC.timeOfDeath = { 0 , 0 , 0 , 0 , 0 , false };
    end

    if isReturningMember then
        if oldMemberInfo.rankIndex ~= 99 then
            
            member.events = oldMemberInfo.events;
            member.customNote = oldMemberInfo.customNote;
            member.rankHist = oldMemberInfo.rankHist;
            member.joinDateHist = oldMemberInfo.joinDateHist;
            member.race = oldMemberInfo.race;
            member.sex = oldMemberInfo.sex;
            member.altsAtTimeOfLeaving = oldMemberInfo.altsAtTimeOfLeaving;

            if GRM_G.HardcoreActive then
                member.HC = oldMemberInfo.HC;
            end

            local dates = select ( 2 , GRM.GetTimestamp() );
            local standardDate = GRM.ConvertToStandardFormatDate ( dates[1] , dates[2] , dates[3] ); 

            -- Remove a rank and join date change
            if logEntryMetaData[1] then
                if logEntryMetaData[4][1] then
                    table.insert ( member.joinDateHist , 1 , { logEntryMetaData[4][3][1] , logEntryMetaData[4][3][2] , logEntryMetaData[4][3][3] , logEntryMetaData[4][2] , time() , true , 1 } );
                else
                    table.insert ( member.joinDateHist , 1 , { dates[1] , dates[2] , dates[3] , standardDate , 0 , liveJoinDetected , 1 } );
                end
            else
                table.insert ( member.joinDateHist , 1 , { dates[1] , dates[2] , dates[3] , standardDate , 0 , liveJoinDetected , 1 } );
            end

            table.insert ( member.rankHist , 1 , { memberInfo.rankName , dates[1] , dates[2] , dates[3] , standardDate , 0 , false , 1 } );      -- 3 means left guild
            
        end
        member.bannedInfo = oldMemberInfo.bannedInfo;
        member.reasonBanned = oldMemberInfo.reasonBanned;
    end
  
end

-- Method:          GRM.AddMemberToLeftPlayers ( array , table , int , int , string )
-- What it does:    First, it adds a new player to the saved list. This basically builds a metadata profile. Then, we add that player to players that left, then remove it from current guildies list.
-- Purpose:         If a player installs the addon AFTER people have left the guild, for example, you need to know their details to have them on the ban list. This builds a profile if another sync'd player has them banned
--                  as you cannot just add the name as banned, you literally have to build a full metadata file for them for it to work properly in the case that they return to the guild.
GRM.AddMemberToLeftPlayers = function ( memberInfo , timeArray , standardTime , dateOriginallyJoined , personWhoBanned )
    -- First things first, add them!
    GRM.AddMemberRecord( memberInfo , false , nil );

    if not personWhoBanned then
        personWhoBanned = "";
    end
    
    local player = GRM.GetPlayer ( memberInfo.name );

    -- Ok, now that it is added, what we need to do now is REMOVE the player from the GRM_GuildMemberHistory_Save and then add it to the end of the left player history.
    -- Some updates must be had, however.
    if player then

        table.insert ( player.rankHist , 1 , { player.rankName , timeArray[1] , timeArray[2] , timeArray[3] , standardTime , dateOriginallyJoined , true , 3 } );
        table.insert ( player.joinDateHist , 1 , { timeArray[1] , timeArray[2] , timeArray[3] , standardTime , dateOriginallyJoined , true , 2 } );
        
        -- Need an original date joined in the history tree if it doesn't exist, as this function is used in creation of banned player profiles.
        if #player.joinDateHist == 1 then
            local timeData = { 0 , 0 , 0 };

            if #standardTime > 0 then
                timeData = select ( 2 , GRM.EpochToDateFormat ( dateOriginallyJoined ) );
                table.insert ( player.joinDateHist , { timeData[1] , timeData[2] , timeData[3] , standardTime , 0  , false , 1 } );
            end
            
        end

        -- Update GUID
        player.GUID = memberInfo.GUID;

        -- If not banned, then let's ensure we reset his data.
        if not player.bannedInfo[1] then
            player.bannedInfo[1] = false;
            player.bannedInfo[2] = 0;
            player.bannedInfo[3] = false;
            player.bannedInfo[4] = personWhoBanned;
            player.reasonBanned = "";
        end

        player = GRM.JoinAndRankDataCleanup ( player );

        -- Adding to LeftGuild Player history library
        local oldMemberData = GRM.GetFormerMembers();
        oldMemberData[memberInfo.name] = {};
        oldMemberData[memberInfo.name] = GRM.DeepCopyArray ( player );

    end

    if player.GUID == "" or player.class == "UNKNOWN" then
        GRM_Patch.BuildGUIDProfilesForAllNoLongerInGuild();
    end

    -- Now need to remove it
    GRM_GuildMemberHistory_Save[GRM_G.guildName][memberInfo.name] = nil;
end

-- Method:          GRM.JoinAndRankDataCleanup ( playerTable )
-- What it Does:    Cleans up a possible extra empty add bug due to some old legacy code errors. 
-- Purpose:         Prevent downstream errors.
GRM.JoinAndRankDataCleanup = function ( player )

    if #player.joinDateHist > 1 then
        for i = #player.joinDateHist , 2 , -1 do
            if player.joinDateHist[i][1] == 0 then
                player.joinDateHist[i] = GRM.DeepCopyArray ( player.joinDateHist[i -1] )
                player.joinDateHist[i][6] = false;
            end
        end
    end

    if #player.rankHist > 1 then
        for i = #player.rankHist , 2 , -1 do
            if player.rankHist[i][2] == 0 then
                table.remove ( player.rankHist , i );
            end
        end
    end

    return player;
end

-- Method:          GRM.ImportJoinDate( string )
-- What it Does:    Sets the join date that is pulled from the server for the CURRENT player
-- Purpose:         With 8.0 changes the join date for the current player can be imported automatically.
GRM.ImportJoinDate = function ( gName )

    local name = gName or "";

    if GRM_G.BuildVersion >= 80000 and IsInGuild() then

        if name == "" then
            local guildName , _ , _ , server = GetGuildInfo ( "PLAYER" );

            if server ~= nil then
                name = guildName .. "-" .. string.gsub ( string.gsub ( server , "-" , "" ) , "%s+" , "" );
            else
                name = guildName .. "-" .. GRM_G.realmName;
            end
        end
        
        local clubID = C_Club.GetGuildClubId();
        local player = GRM.GetPlayer ( GRM_G.addonUser , false , name );

        if player and clubID and player.joinDateHist[#player.joinDateHist][1] == 0 then
            
            local epochTime = math.floor ( C_Club.GetClubInfo ( clubID ).joinTime ) / 1000000;
            local _ , timeS = GRM.EpochToDateFormat ( epochTime );

            GRM_PlayerListOfAlts_Save[name][GRM_G.addonUser][1] = true;

            if not ( timeS[3] == 2018 and timeS[2] == 7 and timeS[1] > 15 and timeS[1] < 19 ) then  -- Same date as patch 8.0 communities
                player.joinDateHist[#player.joinDateHist] = { timeS[1] , timeS[2] , timeS[3] , GRM.ConvertToStandardFormatDate ( timeS[1] , timeS[2] , timeS[3] ) , time() , true , 1 };
            end
        end
    end
end

----------------------------------
------ LOG FUNCTIONS -------------
----------------------------------


-- Method:          GRM.GetMessageRGB( int )
-- What it Does:    Returns the 3 RGB colors colors based on the given index on a 1.0 scale
-- Purpose:         Save on code when need color call. I also did this as a 3 argument return, rather than a single array, just as a proof of concept
--                  since this whole project was also a bit of a Lua learning moment.
GRM.GetMessageRGB = function ( index )
    local r = 0;
    local g = 0;
    local b = 0;

    if index == 1 then      -- Promotion 
        r = GRM.S().logColor[4][1];
        g = GRM.S().logColor[4][2];
        b = GRM.S().logColor[4][3];
    elseif index == 2 then  -- Demotion
        r = GRM.S().logColor[5][1];
        g = GRM.S().logColor[5][2];
        b = GRM.S().logColor[5][3];
    elseif index == 3 then  -- Leveled
        r = GRM.S().logColor[2][1];
        g = GRM.S().logColor[2][2];
        b = GRM.S().logColor[2][3];
    elseif index == 4 then  -- Note
        r = GRM.S().logColor[6][1];
        g = GRM.S().logColor[6][2];
        b = GRM.S().logColor[6][3];
    elseif index == 5 then  -- OfficerNote
        r = GRM.S().logColor[7][1];
        g = GRM.S().logColor[7][2];
        b = GRM.S().logColor[7][3];
    elseif index == 6 then  -- Rank Rename
        r = GRM.S().logColor[10][1];
        g = GRM.S().logColor[10][2];
        b = GRM.S().logColor[10][3];
    elseif index == 7 or index == 8 then  -- Join/Rejoin
        r = GRM.S().logColor[1][1];
        g = GRM.S().logColor[1][2];
        b = GRM.S().logColor[1][3];
    elseif index == 9 or index == 17 or index == 20 or index == 21 then -- Ban and Unbans
        r = GRM.S().logColor[14][1];
        g = GRM.S().logColor[14][2];
        b = GRM.S().logColor[14][3];
    elseif index == 10 then -- Left Guild
        r = GRM.S().logColor[12][1];
        g = GRM.S().logColor[12][2];
        b = GRM.S().logColor[12][3];
    elseif index == 11 then -- NameChange
        r = GRM.S().logColor[9][1];
        g = GRM.S().logColor[9][2];
        b = GRM.S().logColor[9][3];
    elseif index == 12 or index == 18 or index == 98 or index == 99 then -- WhiteText
        r = 1.0;
        g = 1.0;
        b = 1.0;
    elseif index == 13 then -- Rejoining Player Warning (RED)
        r = 0.4;
        g = 0.71;
        b = 0.9;
    elseif index == 14 then -- Return from inactivity
        r = GRM.S().logColor[3][1];
        g = GRM.S().logColor[3][2];
        b = GRM.S().logColor[3][3];
    elseif index == 15 then -- Event Announcement
        r = GRM.S().logColor[11][1];
        g = GRM.S().logColor[11][2];
        b = GRM.S().logColor[11][3];
    elseif index == 16 or index == 22 or index == 23 then -- Recommendations
        r = GRM.S().logColor[13][1];
        g = GRM.S().logColor[13][2];
        b = GRM.S().logColor[13][3];
    elseif index == 19 then  -- Custom Note
        r = GRM.S().logColor[8][1];
        g = GRM.S().logColor[8][2];
        b = GRM.S().logColor[8][3];
    elseif index == 24 then  -- Death Report
        r = GRM.S().logColor[15][1];
        g = GRM.S().logColor[15][2];
        b = GRM.S().logColor[15][3];
    end

    return r , g , b;
end

-- Method:          GRM.AddLog( array , string )
-- What it Does:    Adds a simple array to the Logreport that includes the indexcode for color, and the included changes as a string
-- Purpose:         For ease in adding to the core log.
GRM.AddLog = function ( logEntry , name )
    local guildName = name or GRM_G.guildName;
    if logEntry ~= nil then
        table.insert ( GRM_LogReport_Save[guildName] , logEntry );
    end
end

--------------------------
------ CHAT FUNCTIONS ----
--------------------------

-- Method:          GRM.PrintLog ( array )
-- What it Does:    Sets the color of the string to be reported to the frame (typically chat frame, or to the Log Report frame)
-- Purpose:         Color coding log and chat frame reporting.
GRM.PrintLog = function ( logReport )

    if logReport[2] ~= "" and logReport[2] ~= nil then
        GRM.ReportLocationCheck();

        for i = 1 , #GRM_G.Chat do
            if ( logReport[1] == 1 ) then -- Promoted
                GRM_G.Chat[i]:AddMessage( logReport[2] , GRM.S().logColor[4][1] , GRM.S().logColor[4][2] , GRM.S().logColor[4][3] );
            elseif ( logReport[1] == 2 ) then -- Demoted
                GRM_G.Chat[i]:AddMessage( logReport[2] , GRM.S().logColor[5][1] , GRM.S().logColor[5][2] , GRM.S().logColor[5][3] );
            elseif ( logReport[1] == 3 ) then -- Leveled
                GRM_G.Chat[i]:AddMessage( logReport[2] , GRM.S().logColor[2][1] , GRM.S().logColor[2][2] , GRM.S().logColor[2][3] );
            elseif ( logReport[1] == 4 ) then -- Note
                GRM_G.Chat[i]:AddMessage( logReport[2] , GRM.S().logColor[6][1] , GRM.S().logColor[6][2] , GRM.S().logColor[6][3] );
            elseif ( logReport[1] == 5 ) then -- Officer Note
                GRM_G.Chat[i]:AddMessage( logReport[2] , GRM.S().logColor[7][1] , GRM.S().logColor[7][2] , GRM.S().logColor[7][3] );
            elseif ( logReport[1] == 6 ) then -- Rank Renamed
                GRM_G.Chat[i]:AddMessage( logReport[2] , GRM.S().logColor[10][1] , GRM.S().logColor[10][2] , GRM.S().logColor[10][3] );
            elseif ( logReport[1] == 7 ) or ( logReport[1] == 8 ) then -- Join and Rejoin!
                GRM_G.Chat[i]:AddMessage( logReport[2] , GRM.S().logColor[1][1] , GRM.S().logColor[1][2] , GRM.S().logColor[1][3] );
            elseif ( logReport[1] == 9 ) or ( logReport[1] == 17 ) or ( logReport[1] == 20 ) or ( logReport[1] == 21 ) then -- WARNING BANNED PLAYER REJOIN!
                GRM_G.Chat[i]:AddMessage( logReport[2] , GRM.S().logColor[14][1] , GRM.S().logColor[14][2] , GRM.S().logColor[14][3] );
            elseif ( logReport[1] == 10 ) then -- Left the guild
                GRM_G.Chat[i]:AddMessage( logReport[2] , GRM.S().logColor[12][1] , GRM.S().logColor[12][2] , GRM.S().logColor[12][3] );
            elseif ( logReport[1] == 11 ) then -- Namechanged
                GRM_G.Chat[i]:AddMessage( logReport[2] , GRM.S().logColor[9][1] , GRM.S().logColor[9][2] , GRM.S().logColor[9][3] );
            elseif ( logReport[1] == 12 ) or ( logReport[1] == 18 ) or ( logReport[1] == 98 ) or ( logReport[1] == 99 ) then -- WHITE TEXT IGNORE RGB COLORING
                GRM_G.Chat[i]:AddMessage( logReport[2] , 1.0 , 1.0 , 1.0 );
            elseif ( logReport[1] == 13 ) then -- Rejoining PLayer Custom Note Report - returning player warning
                GRM_G.Chat[i]:AddMessage( logReport[2] , 0.4 , 0.71 , 0.9 );
            elseif ( logReport[1] == 14 ) then -- Player has returned from inactivity
                GRM_G.Chat[i]:AddMessage( logReport[2] , GRM.S().logColor[3][1] , GRM.S().logColor[3][2] , GRM.S().logColor[3][3] );
            elseif ( logReport[1] == 15 ) then -- For event notifications like upcoming anniversaries.
                GRM_G.Chat[i]:AddMessage( logReport[2] , GRM.S().logColor[11][1] , GRM.S().logColor[11][2] , GRM.S().logColor[11][3] );
            elseif ( logReport[1] == 16 ) or ( logReport[1] == 22 ) or ( logReport[1] == 23 ) then -- For Recommendations
                GRM_G.Chat[i]:AddMessage( logReport[2] , GRM.S().logColor[13][1] , GRM.S().logColor[13][2] , GRM.S().logColor[13][3] );
            elseif ( logReport[1] == 19 ) then -- For Custom Note
                GRM_G.Chat[i]:AddMessage ( logReport[2] , GRM.S().logColor[8][1] , GRM.S().logColor[8][2] , GRM.S().logColor[8][3] );
            elseif ( logReport[1] == 24 ) then -- For Custom Note
                GRM_G.Chat[i]:AddMessage ( logReport[2] , GRM.S().logColor[15][1] , GRM.S().logColor[15][2] , GRM.S().logColor[15][3] );
            end
        end
    end
end

-- Method:          GRM.Report ( string )
-- What it Does:    Sends to the main chat window messages on various events as deemed necessary to report on by addon creator.
-- Purpose:         To clean up the reporting and have a way to present the information blended into the default system UI
GRM.Report = function ( msg , R , G , B )

    local r = R or 1.0;
    local g = G or 0.84;
    local b = B or 0;

    if GRM_G.AddonIsFullyConfigured then
        GRM.ReportLocationCheck();
        for i = 1 , #GRM_G.Chat do
            GRM_G.Chat[i]:AddMessage ( msg , r , g , b );
        end
    
    else
        DEFAULT_CHAT_FRAME:AddMessage ( msg , r , g , b );
    end
    
end

-- Method:          GRM.ReportLocationCheck()
-- What it Does:    It checks if the window for the custom location to report is still open, and if it is not, it sets the addon to report back to default location if all the custom ones are closed.
-- Purpose:         Customization of note location and automation for good user experience to auto reset to defaults if player closes the window.
GRM.ReportLocationCheck = function()

    -- Validate the reporting windows
    -- Remove invalid - if you end up removing all, reset to the default.

    for i = #GRM_G.Chat , 1 , -1 do
        if not GetClickFrame ( GRM_G.Chat[i]:GetName() .. "Tab" ):IsVisible() then
            table.remove ( GRM_G.Chat , i );
        end
    end
    
    if #GRM_G.Chat == 0 then
        GRM_G.Chat = { DEFAULT_CHAT_FRAME };
    end

end

-----------------------------------
--------- SCROLL FRAME LOGIC ------
-----------------------------------

-- Method:          GRM.BuildEventCalendarManagerScrollFrame()
-- What it Does:    This populates properly the event ScrollFrame
-- Purpose:         Scroll Frame management for smoother User Experience
GRM.BuildEventCalendarManagerScrollFrame = function()
    -- SCRIPT LOGIC ON ADD EVENT SCROLLING FRAME
    local scrollHeight = 0;
    local scrollWidth = 561;
    local buffer = 13;

    GRM_UI.GRM_RosterChangeLogFrame.GRM_EventsFrame.GRM_AddEventScrollChildFrame.allFrameButtons = GRM_UI.GRM_RosterChangeLogFrame.GRM_EventsFrame.GRM_AddEventScrollChildFrame.allFrameButtons or {};  -- Create a table for the Buttons.
    -- populating the window correctly.
    local tempHeight = 0;
    local calendarQ = GRM.GetEvents();
    
    for i = 1 , #calendarQ do
        -- if font string is not created, do so.
        if not GRM_UI.GRM_RosterChangeLogFrame.GRM_EventsFrame.GRM_AddEventScrollChildFrame.allFrameButtons[i] then
            local tempButton = CreateFrame ( "Button" , "PlayerToAdd" .. i , GRM_UI.GRM_RosterChangeLogFrame.GRM_EventsFrame.GRM_AddEventScrollChildFrame ); -- Names each Button 1 increment up
            GRM_UI.GRM_RosterChangeLogFrame.GRM_EventsFrame.GRM_AddEventScrollChildFrame.allFrameButtons[i] = { tempButton , tempButton:CreateFontString ( nil , "OVERLAY" , "GameFontWhiteTiny" ) , tempButton:CreateFontString ( nil , "OVERLAY" , "GameFontWhiteTiny" ) , tempButton:CreateFontString ( nil , "OVERLAY" , "GameFontWhiteTiny" ) , tempButton:CreateFontString ( nil , "OVERLAY" , "GameFontWhiteTiny" ) };
        end
    
        GRM_UI.GRM_RosterChangeLogFrame.GRM_EventsFrame.GRM_AddEventScrollChildFrame.allFrameButtons[i][1].timer = 0;
        local EventButtons = GRM_UI.GRM_RosterChangeLogFrame.GRM_EventsFrame.GRM_AddEventScrollChildFrame.allFrameButtons[i][1];
        local EventButtonsText = GRM_UI.GRM_RosterChangeLogFrame.GRM_EventsFrame.GRM_AddEventScrollChildFrame.allFrameButtons[i][2];
        local EventButtonsDateText = GRM_UI.GRM_RosterChangeLogFrame.GRM_EventsFrame.GRM_AddEventScrollChildFrame.allFrameButtons[i][3];
        local EventButtonsText2 = GRM_UI.GRM_RosterChangeLogFrame.GRM_EventsFrame.GRM_AddEventScrollChildFrame.allFrameButtons[i][4];
        local EventButtonsText3 = GRM_UI.GRM_RosterChangeLogFrame.GRM_EventsFrame.GRM_AddEventScrollChildFrame.allFrameButtons[i][5];
        local classColorRGB = GRM.GetClassColorRGB ( GRM.GetPlayerClass ( calendarQ[i][1] ) , false );
    
        -- Set the values..
        EventButtons:SetPoint ( "TOP" , GRM_UI.GRM_RosterChangeLogFrame.GRM_EventsFrame.GRM_AddEventScrollChildFrame , 7 , -99 );
        EventButtons:SetWidth ( 558 );
        EventButtons:SetHeight ( 19 );
        EventButtons:SetHighlightTexture ( "Interface\\Buttons\\UI-Panel-Button-Highlight" );
        EventButtons:RegisterForDrag ( "LeftButton" );
        EventButtons:SetScript ( "OnDragStart" , function()
            GRM_UI.GRM_RosterChangeLogFrame:StartMoving();
        end);
        EventButtons:SetScript ( "OnDragStop" , function()
            GRM_UI.GRM_RosterChangeLogFrame:StopMovingOrSizing()
            GRM_UI.SaveCorePosition();
        end);
    
        EventButtonsText:SetText ( GRM.SlimName ( calendarQ[i][1] ) );
        EventButtonsText:SetTextColor ( classColorRGB[1] , classColorRGB[2] , classColorRGB[3] , 1 );
        EventButtonsText:SetFont ( GRM_G.FontChoice , GRM_G.FontModifier + 11 );
        EventButtonsText:SetJustifyH ( "LEFT" );
        EventButtonsText:SetWidth ( 90 );
    
        EventButtonsDateText:SetText ( GRM.FormatTimeStamp ( { calendarQ[i][4] , calendarQ[i][3] , calendarQ[i][5] } , false , true ) );
        EventButtonsDateText:SetFont ( GRM_G.FontChoice , GRM_G.FontModifier + 11 );
        EventButtonsDateText:SetJustifyH ( "LEFT" );
        EventButtonsDateText:SetWidth ( 62 );
    
        EventButtonsText2:SetText ( calendarQ[i][2] );
        EventButtonsText2:SetFont ( GRM_G.FontChoice , GRM_G.FontModifier + 11 );
        EventButtonsText2:SetJustifyH ( "LEFT" );
        EventButtonsText2:SetWordWrap ( false );
        EventButtonsText2:SetWidth ( 170 )
    
        EventButtonsText3:SetText ( calendarQ[i][6] );
        EventButtonsText3:SetWidth ( 210 );
        EventButtonsText3:SetWordWrap ( false );
        EventButtonsText3:SetFont ( GRM_G.FontChoice , GRM_G.FontModifier + 11 );
        EventButtonsText3:SetJustifyH ( "LEFT" );
    
        EventButtons:SetScript ( "OnLeave" , function()
            GRM.RestoreTooltip();
        end);
    
        EventButtons:SetScript ( "OnEnter" , function()
            if calendarQ[i] ~= nil and calendarQ[i][1] ~= nil then
                local player = GRM.GetPlayer ( calendarQ[i][1] );
    
                if player then
                    GameTooltip:SetOwner ( EventButtons  , "ANCHOR_CURSOR" );
                    GameTooltip:AddLine ( GRM.GetClassifiedName ( calendarQ[i][1] , false ) );
                    GameTooltip:AddDoubleLine ( GRM.L ( "Last Online" ) , GRM.HoursReport ( player.lastOnline ) , 1 , 0 , 0 , 1 , 0.84 , 0 );
                    GameTooltip:AddDoubleLine ( " " , " " );
    
                    GameTooltip:AddLine ( GRM.L ( "|CFFE6CC7FClick|r to select player event" ) );
    
                    GameTooltip:AddLine ( GRM.L ( "{custom1} to open Player Window" , nil , nil , nil , "|CFFE6CC7F" .. GRM.L ( "Ctrl-Click" ) .. "|r" ) );
    
                    GameTooltip:AddLine ( GRM.L ( "{custom1} to Search the Log for Player" , nil , nil , nil , "|CFFE6CC7F" .. GRM.L ( "Ctrl-Shift-Click" ) .. "|r" ) );
                    GameTooltip:Show();
                end
            end
        end);
    
        EventButtons:SetScript ( "OnUpdate" , function( self , elapsed )
            self.timer = self.timer + elapsed;
            if self.timer > 0.1 then
                if self:IsMouseOver() and calendarQ[i] ~= nil then
    
                    if EventButtonsText3:IsMouseOver( 9 , -9 , -9 , 9 ) then            -- Since the button is large, the text needs to compensate.
    
                        GRM.RestoreTooltip();
                        GRM_UI.SetTooltipScale();
                        GameTooltip:SetOwner( self , "ANCHOR_CURSOR"  );
                        GameTooltip:AddLine( "|cFFFFFFFF" .. string.upper ( GRM.L ( "Full Description:" ) ) );
                        GameTooltip:AddLine( calendarQ[i][6] , 1.0 , 0.84 , 0 , true );
                        GameTooltip:Show();
    
                    elseif GameTooltip:IsVisible() then
                        local player = GRM.GetPlayer ( calendarQ[i][1] );
    
                        if player then
                            GRM.RestoreTooltip();
                            GRM_UI.SetTooltipScale();
                            GameTooltip:SetOwner ( EventButtons  , "ANCHOR_CURSOR" );
                            GameTooltip:AddLine ( GRM.GetClassifiedName ( calendarQ[i][1] , false ) );
                            GameTooltip:AddDoubleLine ( GRM.L ( "Last Online" ) , GRM.HoursReport ( player.lastOnline ) , 1 , 0 , 0 , 1 , 0.84 , 0 );
                            GameTooltip:AddDoubleLine ( " " , " " );
    
                            GameTooltip:AddLine ( GRM.L ( "|CFFE6CC7FClick|r to select player event" ) );
                            GameTooltip:AddLine ( GRM.L ( "{custom1} to open Player Window" , nil , nil , nil , "|CFFE6CC7F" .. GRM.L ( "Ctrl-Click" ) .. "|r" ) );
                            GameTooltip:AddLine ( GRM.L ( "{custom1} to Search the Log for Player" , nil , nil , nil , "|CFFE6CC7F" .. GRM.L ( "Ctrl-Shift-Click" ) .. "|r" ) );
                            GameTooltip:Show();
                        end
                    end
    
                end
                self.timer = 0;
            end
        end);
    
        -- Logic
        EventButtons:SetScript ( "OnClick" , function ( self , button )
            if button == "LeftButton" then
                -- For highlighting purposes
                -- parse out the button number, which will correlate with addonque frame...
                local index = tonumber ( string.match ( self:GetName() , "%d+" ) );
    
                if IsShiftKeyDown() and IsControlKeyDown() then
                    GRM.RestoreTooltip();
                    GRM_UI.GRM_RosterChangeLogFrame.GRM_LogTab:Click();
                    GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_LogEditBox:SetText( GRM.SlimName ( calendarQ[index][1] ) );
                elseif IsControlKeyDown() then
                    GRM.OpenPlayerWindow( calendarQ[index][1] );
                else
    
                    -- Deal with the highlights
                    for j = 1 , #GRM_UI.GRM_RosterChangeLogFrame.GRM_EventsFrame.GRM_AddEventScrollChildFrame.allFrameButtons do
                        if EventButtons ~= GRM_UI.GRM_RosterChangeLogFrame.GRM_EventsFrame.GRM_AddEventScrollChildFrame.allFrameButtons[j][1] then
                            GRM_UI.GRM_RosterChangeLogFrame.GRM_EventsFrame.GRM_AddEventScrollChildFrame.allFrameButtons[j][1]:UnlockHighlight();
                        else
                            GRM_UI.GRM_RosterChangeLogFrame.GRM_EventsFrame.GRM_AddEventScrollChildFrame.allFrameButtons[j][1]:LockHighlight();
                        end
                    end
                    
                    if ( GRM_UI.GRM_RosterChangeLogFrame.GRM_EventsFrame.GRM_EventsFrameNameToAddText:GetText() == nil ) or ( GRM_UI.GRM_RosterChangeLogFrame.GRM_EventsFrame.GRM_EventsFrameNameToAddText:GetText() ~= nil and ( GRM_UI.GRM_RosterChangeLogFrame.GRM_EventsFrame.GRM_EventsFrameNameToAddText:GetText() ~= EventButtonsText2:GetText() or not GRM_UI.GRM_RosterChangeLogFrame.GRM_EventsFrame.GRM_EventsFrameNameToAddText:IsVisible() ) ) then
                        GRM_UI.GRM_RosterChangeLogFrame.GRM_EventsFrame.GRM_EventsFrameNameToAddText:SetText ( EventButtonsText2:GetText() );
                        GRM_UI.GRM_RosterChangeLogFrame.GRM_EventsFrame.GRM_EventsFrameNameToAddTitleText:SetText ( EventButtonsText: GetText() );
                        GRM_UI.GRM_RosterChangeLogFrame.GRM_EventsFrame.GRM_EventsFrameNameDateText:SetText(  GRM.FormatTimeStamp ( { calendarQ[index][4] , calendarQ[index][3] , calendarQ[index][5] } , false , true ) );
    
                        if GRM_UI.GRM_RosterChangeLogFrame.GRM_EventsFrame.GRM_EventsFrameStatusMessageText:IsVisible() then
                            GRM_UI.GRM_RosterChangeLogFrame.GRM_EventsFrame.GRM_EventsFrameStatusMessageText:Hide();
                            GRM_UI.GRM_RosterChangeLogFrame.GRM_EventsFrame.GRM_EventsFrameNameToAddText:Show();
                            GRM_UI.GRM_RosterChangeLogFrame.GRM_EventsFrame.GRM_EventsFrameNameDateText:Show();
                        end
                    end
                end
            end
    
        end);
        
        -- Now let's pin it!
        if i == 1 then
            EventButtons:SetPoint ( "TOPLEFT" , GRM_UI.GRM_RosterChangeLogFrame.GRM_EventsFrame.GRM_AddEventScrollChildFrame , "TOPLEFT" , 3 , -12 );
            EventButtonsText:SetPoint ( "TOPLEFT" , GRM_UI.GRM_RosterChangeLogFrame.GRM_EventsFrame.GRM_AddEventScrollChildFrame , "TOPLEFT" , 3 , -12 );
            EventButtonsDateText:SetPoint ( "LEFT" , EventButtonsText , "RIGHT" , 3 , 0 );
            EventButtonsText2:SetPoint ( "LEFT" , EventButtonsDateText , "RIGHT" , 3 , 0 );
            EventButtonsText3:SetPoint ( "LEFT" , EventButtonsText2 , "RIGHT" , 3 , 0 );
            scrollHeight = scrollHeight + EventButtons:GetHeight();
        else
            EventButtons:SetPoint( "TOPLEFT" , GRM_UI.GRM_RosterChangeLogFrame.GRM_EventsFrame.GRM_AddEventScrollChildFrame.allFrameButtons[i - 1][1] , "BOTTOMLEFT" , 0 , - buffer );
            EventButtonsText:SetPoint ( "TOPLEFT" , GRM_UI.GRM_RosterChangeLogFrame.GRM_EventsFrame.GRM_AddEventScrollChildFrame.allFrameButtons[i - 1][2] , "BOTTOMLEFT" , 0 , - ( buffer + tempHeight ) );
            EventButtonsDateText:SetPoint ( "TOPLEFT" , GRM_UI.GRM_RosterChangeLogFrame.GRM_EventsFrame.GRM_AddEventScrollChildFrame.allFrameButtons[i - 1][3] , "BOTTOMLEFT" , 0 , - ( buffer + tempHeight ) );
            EventButtonsText2:SetPoint ( "TOPLEFT" , GRM_UI.GRM_RosterChangeLogFrame.GRM_EventsFrame.GRM_AddEventScrollChildFrame.allFrameButtons[i - 1][4] , "BOTTOMLEFT" , 0 , - ( buffer + tempHeight ) );
            EventButtonsText3:SetPoint ( "TOPLEFT" , GRM_UI.GRM_RosterChangeLogFrame.GRM_EventsFrame.GRM_AddEventScrollChildFrame.allFrameButtons[i - 1][5] , "BOTTOMLEFT" , 0 , - ( buffer + tempHeight ) );
            scrollHeight = scrollHeight + EventButtons:GetHeight() + buffer;
        end
        EventButtons:Show();
        tempHeight = ( EventButtons:GetHeight() - EventButtonsText2:GetHeight() );
    end
    -- Update the size -- it either grows or it shrinks!
    GRM_UI.GRM_RosterChangeLogFrame.GRM_EventsFrame.GRM_AddEventScrollChildFrame:SetSize ( scrollWidth , scrollHeight );

    --Set Slider Parameters ( has to be done after the above details are placed )
    local scrollMax = ( scrollHeight - GRM_UI.GRM_RosterChangeLogFrame.GRM_EventsFrame.GRM_AddEventScrollFrame:GetHeight() ) + ( buffer * 1.5 );
    if scrollMax < 0 then
        scrollMax = 0;
    end
    GRM_UI.GRM_RosterChangeLogFrame.GRM_EventsFrame.GRM_AddEventScrollFrameSlider:SetMinMaxValues ( 0 , scrollMax );
    -- Mousewheel Scrolling Logic
    GRM_UI.GRM_RosterChangeLogFrame.GRM_EventsFrame.GRM_AddEventScrollFrame:EnableMouseWheel( true );
    GRM_UI.GRM_RosterChangeLogFrame.GRM_EventsFrame.GRM_AddEventScrollFrame:SetScript( "OnMouseWheel" , function( _ , delta )
        local current = GRM_UI.GRM_RosterChangeLogFrame.GRM_EventsFrame.GRM_AddEventScrollFrameSlider:GetValue();
        
        if IsShiftKeyDown() and delta > 0 then
            GRM_UI.GRM_RosterChangeLogFrame.GRM_EventsFrame.GRM_AddEventScrollFrameSlider:SetValue ( 0 );
        elseif IsShiftKeyDown() and delta < 0 then
            GRM_UI.GRM_RosterChangeLogFrame.GRM_EventsFrame.GRM_AddEventScrollFrameSlider:SetValue ( scrollMax );
        elseif delta < 0 and current < scrollMax then
            if IsControlKeyDown() then
                GRM_UI.GRM_RosterChangeLogFrame.GRM_EventsFrame.GRM_AddEventScrollFrameSlider:SetValue ( current + 60 );
            else
                GRM_UI.GRM_RosterChangeLogFrame.GRM_EventsFrame.GRM_AddEventScrollFrameSlider:SetValue ( current + 20 );
            end
        elseif delta > 0 and current > 1 then
            if IsControlKeyDown() then
                GRM_UI.GRM_RosterChangeLogFrame.GRM_EventsFrame.GRM_AddEventScrollFrameSlider:SetValue ( current - 60 );
            else
                GRM_UI.GRM_RosterChangeLogFrame.GRM_EventsFrame.GRM_AddEventScrollFrameSlider:SetValue ( current - 20 );
            end
        end
    end);
end


-- Method:          GRM.BuildAddonUserScrollFrame()
-- What it Does:    Builds the potential scroll frame to house the entire list of all guildies who have addon installed and enabled
-- Purpose:         Much better and cleaner UI to have a scroll window, imo.
GRM.BuildAddonUserScrollFrame = function()
    local scrollHeight = 0;
    local scrollWidth = 561;
    local buffer = 15;
    local okWord = GRM.L ( "Ok!" );

    GRM_UI.GRM_RosterChangeLogFrame.GRM_AddonUsersFrame.GRM_AddonUsersScrollChildFrame.AllFrameFontstrings = GRM_UI.GRM_RosterChangeLogFrame.GRM_AddonUsersFrame.GRM_AddonUsersScrollChildFrame.AllFrameFontstrings or {};  -- Create a table for the Buttons.
    -- Building all the fontstrings.
    for i = 1 , #GRM_G.currentAddonUsers do
        -- We know there is at least one, so let's hide the warning string...
        GRM_UI.GRM_RosterChangeLogFrame.GRM_AddonUsersFrame.GRM_AddonUsersScrollChildFrame.GRM_AddonUsersCoreFrameTitleText2:Hide();
        -- if font string is not created, do so.
        if not GRM_UI.GRM_RosterChangeLogFrame.GRM_AddonUsersFrame.GRM_AddonUsersScrollChildFrame.AllFrameFontstrings[i] then
            GRM_UI.GRM_RosterChangeLogFrame.GRM_AddonUsersFrame.GRM_AddonUsersScrollChildFrame.AllFrameFontstrings[i] = { GRM_UI.GRM_RosterChangeLogFrame.GRM_AddonUsersFrame.GRM_AddonUsersScrollChildFrame:CreateFontString ( nil , "OVERLAY" , "GameFontWhiteTiny" ) , GRM_UI.GRM_RosterChangeLogFrame.GRM_AddonUsersFrame.GRM_AddonUsersScrollChildFrame:CreateFontString ( nil , "OVERLAY" , "GameFontWhiteTiny" ) , GRM_UI.GRM_RosterChangeLogFrame.GRM_AddonUsersFrame.GRM_AddonUsersScrollChildFrame:CreateFontString ( nil , "OVERLAY" , "GameFontWhiteTiny" ) , GRM_UI.GRM_RosterChangeLogFrame.GRM_AddonUsersFrame.GRM_AddonUsersScrollChildFrame:CreateFontString ( nil , "OVERLAY" , "GameFontWhiteTiny" ) , GRM_UI.GRM_RosterChangeLogFrame.GRM_AddonUsersFrame.GRM_AddonUsersScrollChildFrame:CreateFontString ( nil , "OVERLAY" , "GameFontWhiteTiny" ) };
        end

        local AddonUserText1 = GRM_UI.GRM_RosterChangeLogFrame.GRM_AddonUsersFrame.GRM_AddonUsersScrollChildFrame.AllFrameFontstrings[i][1];
        local AddonUserText2 = GRM_UI.GRM_RosterChangeLogFrame.GRM_AddonUsersFrame.GRM_AddonUsersScrollChildFrame.AllFrameFontstrings[i][2];
        local AddonUserText3 = GRM_UI.GRM_RosterChangeLogFrame.GRM_AddonUsersFrame.GRM_AddonUsersScrollChildFrame.AllFrameFontstrings[i][3];
        local AddonUserText4 = GRM_UI.GRM_RosterChangeLogFrame.GRM_AddonUsersFrame.GRM_AddonUsersScrollChildFrame.AllFrameFontstrings[i][4];
        local AddonUserText5 = GRM_UI.GRM_RosterChangeLogFrame.GRM_AddonUsersFrame.GRM_AddonUsersScrollChildFrame.AllFrameFontstrings[i][5];
        local classColorRGB = GRM.GetClassColorRGB ( GRM.GetPlayerClass ( GRM_G.currentAddonUsers[i][1] ) );

        AddonUserText1:SetText ( GRM.FormatName ( GRM_G.currentAddonUsers[i][1] ) );
        if classColorRGB ~= nil then
            AddonUserText1:SetTextColor ( classColorRGB[1] , classColorRGB[2] , classColorRGB[3] );
        end
        AddonUserText1:SetWidth ( 100 );
        AddonUserText1:SetFont ( GRM_G.FontChoice , GRM_G.FontModifier + 13 );
        AddonUserText1:SetJustifyH ( "LEFT" );

        -- Get the right RGB coloring for the text.
        local r , g , b;
        local greenColor = { 0 , 0.77 , 0.063 };
        local redColor = { 0.64 , 0.102 , 0.102 };

        if GRM_G.currentAddonUsers[i][9] then

            AddonUserText2:SetTextColor ( greenColor[1] , greenColor[2] , greenColor[3] , 1.0 );
            AddonUserText2:SetText ( okWord );

            AddonUserText3:SetTextColor ( greenColor[1] , greenColor[2] , greenColor[3] , 1.0 );
            AddonUserText3:SetText ( okWord );

            if GRM_G.currentAddonUsers[i][8] == 1 then
                AddonUserText4:SetTextColor ( greenColor[1] , greenColor[2] , greenColor[3] , 1.0 );
                AddonUserText4:SetText ( okWord );
            else
                AddonUserText4:SetTextColor ( redColor[1] , redColor[2] , redColor[3] , 1.0 );
                AddonUserText4:SetText ( "X" );
            end
            
        else
            AddonUserText2:SetTextColor ( redColor[1] , redColor[2] , redColor[3] , 1.0 );
            AddonUserText2:SetText ( "X" );

            AddonUserText3:SetTextColor ( redColor[1] , redColor[2] , redColor[3] , 1.0 );
            AddonUserText3:SetText ( "X" );

            AddonUserText4:SetTextColor ( redColor[1] , redColor[2] , redColor[3] , 1.0 );
            AddonUserText4:SetText ( "X" );

        end

        AddonUserText2:SetWidth ( 75 );
        AddonUserText2:SetWordWrap ( false );
        AddonUserText2:SetFont ( GRM_G.FontChoice , GRM_G.FontModifier + 12 );
        AddonUserText2:SetJustifyH ( "CENTER" );

        AddonUserText3:SetWidth ( 60 );
        AddonUserText3:SetWordWrap ( false );
        AddonUserText3:SetFont ( GRM_G.FontChoice , GRM_G.FontModifier + 12 );
        AddonUserText3:SetJustifyH ( "CENTER" );

        AddonUserText4:SetWidth ( 60 );
        AddonUserText4:SetWordWrap ( false );
        AddonUserText4:SetFont ( GRM_G.FontChoice , GRM_G.FontModifier + 12 );
        AddonUserText4:SetJustifyH ( "CENTER" );

        if GRM_G.currentAddonUsers[i][2] == "Outdated Version" then
            AddonUserText5:SetText ( GRM.L ( GRM_G.currentAddonUsers[i][2] ) .. ": " .. GRM_G.currentAddonUsers[i][3] );
        else
            AddonUserText5:SetText ( GRM.L ( GRM_G.currentAddonUsers[i][2] ) );
        end

        AddonUserText5:SetWidth ( 245 );
        AddonUserText5:SetWordWrap ( true );
        AddonUserText5:SetSpacing ( 1 );
        AddonUserText5:SetFont ( GRM_G.FontChoice , GRM_G.FontModifier + 12 );
        AddonUserText5:SetJustifyH ( "LEFT" );
        
        local stringHeight = AddonUserText5:GetStringHeight();

        -- Now let's pin it!
        if i == 1 then
            AddonUserText1:SetPoint( "TOPLEFT" , GRM_UI.GRM_RosterChangeLogFrame.GRM_AddonUsersFrame.GRM_AddonUsersScrollChildFrame , "TOPLEFT" , 5 , - 15 );
            scrollHeight = scrollHeight + stringHeight;
        else
            AddonUserText1:SetPoint( "TOPLEFT" , GRM_UI.GRM_RosterChangeLogFrame.GRM_AddonUsersFrame.GRM_AddonUsersScrollChildFrame.AllFrameFontstrings[i - 1][1] , "BOTTOMLEFT" , 0 , - buffer );
            scrollHeight = scrollHeight + stringHeight + buffer;
        end
        AddonUserText2:SetPoint( "LEFT" , AddonUserText1 , "RIGHT" , 2 , 0 );
        AddonUserText3:SetPoint( "LEFT" , AddonUserText2 , "RIGHT" , 2 , 0 );
        AddonUserText4:SetPoint( "LEFT" , AddonUserText3 , "RIGHT" , 2 , 0 );
        AddonUserText5:SetPoint( "LEFT" , AddonUserText4 , "RIGHT" , 5 , 0 );

        AddonUserText1:Show();
        AddonUserText2:Show();
        AddonUserText3:Show();
        AddonUserText4:Show();
        AddonUserText5:Show();
    end
            
    -- Hides all the additional strings... if necessary ( necessary because some people may have logged off thus you need to hide those frames)
    for i = #GRM_G.currentAddonUsers + 1 , #GRM_UI.GRM_RosterChangeLogFrame.GRM_AddonUsersFrame.GRM_AddonUsersScrollChildFrame.AllFrameFontstrings do
        GRM_UI.GRM_RosterChangeLogFrame.GRM_AddonUsersFrame.GRM_AddonUsersScrollChildFrame.AllFrameFontstrings[i][1]:Hide();
        GRM_UI.GRM_RosterChangeLogFrame.GRM_AddonUsersFrame.GRM_AddonUsersScrollChildFrame.AllFrameFontstrings[i][2]:Hide();
        GRM_UI.GRM_RosterChangeLogFrame.GRM_AddonUsersFrame.GRM_AddonUsersScrollChildFrame.AllFrameFontstrings[i][3]:Hide();
        GRM_UI.GRM_RosterChangeLogFrame.GRM_AddonUsersFrame.GRM_AddonUsersScrollChildFrame.AllFrameFontstrings[i][4]:Hide();
        GRM_UI.GRM_RosterChangeLogFrame.GRM_AddonUsersFrame.GRM_AddonUsersScrollChildFrame.AllFrameFontstrings[i][5]:Hide();
    end 

    -- Update the size -- it either grows or it shrinks!
    GRM_UI.GRM_RosterChangeLogFrame.GRM_AddonUsersFrame.GRM_AddonUsersScrollChildFrame:SetSize ( scrollWidth , scrollHeight );

    --Set Slider Parameters ( has to be done after the above details are placed )
    local scrollMax = ( scrollHeight - GRM_UI.GRM_RosterChangeLogFrame.GRM_AddonUsersFrame.GRM_AddonUsersScrollFrame:GetSize() ) + ( buffer * .5 );  -- 18 comes from fontSize (11) + buffer (7);
    if scrollMax < 0 then
        scrollMax = 0;
    end
    GRM_UI.GRM_RosterChangeLogFrame.GRM_AddonUsersFrame.GRM_AddonUsersScrollFrameSlider:SetMinMaxValues ( 0 , scrollMax );
    -- Mousewheel Scrolling Logic
    GRM_UI.GRM_RosterChangeLogFrame.GRM_AddonUsersFrame.GRM_AddonUsersScrollFrame:EnableMouseWheel( true );
    GRM_UI.GRM_RosterChangeLogFrame.GRM_AddonUsersFrame.GRM_AddonUsersScrollFrame:SetScript( "OnMouseWheel" , function( _ , delta )
        local current = GRM_UI.GRM_RosterChangeLogFrame.GRM_AddonUsersFrame.GRM_AddonUsersScrollFrameSlider:GetValue();
        
        if IsShiftKeyDown() and delta > 0 then
            GRM_UI.GRM_RosterChangeLogFrame.GRM_AddonUsersFrame.GRM_AddonUsersScrollFrameSlider:SetValue ( 0 );
        elseif IsShiftKeyDown() and delta < 0 then
            GRM_UI.GRM_RosterChangeLogFrame.GRM_AddonUsersFrame.GRM_AddonUsersScrollFrameSlider:SetValue ( scrollMax );
        elseif delta < 0 and current < scrollMax then
            if IsControlKeyDown() then
                GRM_UI.GRM_RosterChangeLogFrame.GRM_AddonUsersFrame.GRM_AddonUsersScrollFrameSlider:SetValue ( current + 60 );
            else
                GRM_UI.GRM_RosterChangeLogFrame.GRM_AddonUsersFrame.GRM_AddonUsersScrollFrameSlider:SetValue ( current + 20 );
            end
        elseif delta > 0 and current > 1 then
            if IsControlKeyDown() then
                GRM_UI.GRM_RosterChangeLogFrame.GRM_AddonUsersFrame.GRM_AddonUsersScrollFrameSlider:SetValue ( current - 60 );
            else
                GRM_UI.GRM_RosterChangeLogFrame.GRM_AddonUsersFrame.GRM_AddonUsersScrollFrameSlider:SetValue ( current - 20 );
            end
        end
    end);

    -- Statement on who is using the addon!
    if #GRM_G.currentAddonUsers == 0 then
        local numGuildiesOnline = GRM.GetNumGuildiesOnline() - 1; -- Don't include yourself!
        local result = GRM.L ( "No Guildie Online With Addon." );
        if numGuildiesOnline == 1 then
            result = result .. "\n" .. GRM.L ( "ONE Person is Online. Recommend It!" );
        elseif numGuildiesOnline > 1 then
            result = result .. "\n" .. GRM.L ( "{num} others are Online! Recommend It!" , nil , nil , numGuildiesOnline );
        end
        GRM_UI.GRM_RosterChangeLogFrame.GRM_AddonUsersFrame.GRM_AddonUsersScrollChildFrame.GRM_AddonUsersCoreFrameTitleText2:SetText ( result );
        GRM_UI.GRM_RosterChangeLogFrame.GRM_AddonUsersFrame.GRM_AddonUsersScrollChildFrame.GRM_AddonUsersCoreFrameTitleText2:Show();
    end
end

-- Method:          GRM.BuildAltGroupingScrollFrame( string )
-- What it Does:    It builds the alt groupings info on mouseover with shift pressed
-- Purpose:         For quick look at the alt info...
GRM.BuildAltGroupingScrollFrame = function( currentName )
    local scrollHeight = 0;
    local scrollWidth = 315;
    local buffer = 9;
    GRM_UI.GRM_MemberDetailMetaData.GRM_AltGroupingScrollBorderFrame.GRM_AltGroupingScrollChildFrame.GRM_AltGroupingScrollFrameSlider:SetValue(0);

    GRM_UI.GRM_MemberDetailMetaData.GRM_AltGroupingScrollBorderFrame.GRM_AltGroupingScrollChildFrame.AllFrameFontstrings = GRM_UI.GRM_MemberDetailMetaData.GRM_AltGroupingScrollBorderFrame.GRM_AltGroupingScrollChildFrame.AllFrameFontstrings or {};  -- Create a table for the Buttons.
    -- Building all the fontstrings.
    GRM_UI.GRM_MemberDetailMetaData.GRM_AltGroupingScrollBorderFrameTitle:SetText ( GRM_G.CurrentCalendarHexCode .. GRM.L ( "{name}'s Alts" , GRM.SlimName ( currentName ) ) );

    if GRM.GetPlayer ( currentName ) then

        -- Collect all the alt names and sort them.
        local listOfAlts = GRM.GetSortedAltNamesWithDetails ( currentName );
        local mainFound = false;
        for i = 1 , #listOfAlts do  -- The +1 is for the player so they can count themselves too...
            -- if font string is not created, do so.
            if not GRM_UI.GRM_MemberDetailMetaData.GRM_AltGroupingScrollBorderFrame.GRM_AltGroupingScrollChildFrame.AllFrameFontstrings[i] then
                GRM_UI.GRM_MemberDetailMetaData.GRM_AltGroupingScrollBorderFrame.GRM_AltGroupingScrollChildFrame.AllFrameFontstrings[i] = { GRM_UI.GRM_MemberDetailMetaData.GRM_AltGroupingScrollBorderFrame.GRM_AltGroupingScrollChildFrame:CreateFontString ( nil , "OVERLAY" , "GameFontWhiteTiny" ) , GRM_UI.GRM_MemberDetailMetaData.GRM_AltGroupingScrollBorderFrame.GRM_AltGroupingScrollChildFrame:CreateFontString ( nil , "OVERLAY" , "GameFontWhiteTiny" ) , GRM_UI.GRM_MemberDetailMetaData.GRM_AltGroupingScrollBorderFrame.GRM_AltGroupingScrollChildFrame:CreateFontString ( nil , "OVERLAY" , "GameFontWhiteTiny" ) , GRM_UI.GRM_MemberDetailMetaData.GRM_AltGroupingScrollBorderFrame.GRM_AltGroupingScrollChildFrame:CreateFontString ( nil , "OVERLAY" , "GameFontWhiteTiny" ) };
            end
    
            local AltName = GRM_UI.GRM_MemberDetailMetaData.GRM_AltGroupingScrollBorderFrame.GRM_AltGroupingScrollChildFrame.AllFrameFontstrings[i][1];
            local AltLvl = GRM_UI.GRM_MemberDetailMetaData.GRM_AltGroupingScrollBorderFrame.GRM_AltGroupingScrollChildFrame.AllFrameFontstrings[i][2];
            local AltRank = GRM_UI.GRM_MemberDetailMetaData.GRM_AltGroupingScrollBorderFrame.GRM_AltGroupingScrollChildFrame.AllFrameFontstrings[i][3];
            local AltLastOnline = GRM_UI.GRM_MemberDetailMetaData.GRM_AltGroupingScrollBorderFrame.GRM_AltGroupingScrollChildFrame.AllFrameFontstrings[i][4];
            
            local altClassRGB = GRM.GetClassColorRGB ( listOfAlts[i][3] , false );

            AltName:SetText ( GRM.SlimName ( listOfAlts[i][1] ) );
            AltName:SetFont ( GRM_G.FontChoice , GRM_G.FontModifier + 9 );
            AltName:SetJustifyH ( "LEFT" );
            AltName:SetTextColor ( altClassRGB[1] , altClassRGB[2] , altClassRGB[3] , 1 );
    
            AltLvl:SetText ( listOfAlts[i][2] );
            AltLvl:SetWidth ( 75 );
            AltLvl:SetWordWrap ( false );
            AltLvl:SetFont ( GRM_G.FontChoice , GRM_G.FontModifier + 9 );
            AltLvl:SetJustifyH ( "CENTER" );

            AltRank:SetText ( GuildControlGetRankName( listOfAlts[i][4] + 1 ) );
            AltRank:SetWidth ( 75 );
            AltRank:SetWordWrap ( false );
            AltRank:SetFont ( GRM_G.FontChoice , GRM_G.FontModifier + 9 );
            AltRank:SetJustifyH ( "CENTER" );

            AltLastOnline:SetWidth ( 100 );
            AltLastOnline:SetWordWrap ( false );
            AltLastOnline:SetFont ( GRM_G.FontChoice , GRM_G.FontModifier + 9 );

            -- Last Online
            if listOfAlts[i][9] then
                AltLastOnline:SetText ( GRM.L ( "Online" ) );
                AltLastOnline:SetTextColor ( 0.12 , 1.0 , 0.0 , 1.0 );
            else
                AltLastOnline:SetText ( GRM.HoursReport ( listOfAlts[i][6] ) );
                AltLastOnline:SetTextColor ( 1 , 1 , 1 , 1.0 );
            end
    
            local stringHeight = AltLastOnline:GetStringHeight();
    
            -- Now let's pin it!
            if i == 1 then
                AltName:SetPoint( "TOPLEFT" , GRM_UI.GRM_MemberDetailMetaData.GRM_AltGroupingScrollBorderFrame.GRM_AltGroupingScrollChildFrame , "TOPLEFT" , 14 , -5 );
                AltLvl:SetPoint( "TOP" , GRM_UI.GRM_MemberDetailMetaData.GRM_AltGroupingScrollBorderFrame.GRM_AltGroupingScrollChildFrame , "TOP" , -60 , -5 );
                AltRank:SetPoint( "TOP" , GRM_UI.GRM_MemberDetailMetaData.GRM_AltGroupingScrollBorderFrame.GRM_AltGroupingScrollChildFrame , "TOP" , 10 , -5 );
                AltLastOnline:SetPoint( "TOP" , GRM_UI.GRM_MemberDetailMetaData.GRM_AltGroupingScrollBorderFrame.GRM_AltGroupingScrollChildFrame , "TOP" , 98 , -5 );

                scrollHeight = scrollHeight + stringHeight;
            else
                AltName:SetPoint( "TOPLEFT" , GRM_UI.GRM_MemberDetailMetaData.GRM_AltGroupingScrollBorderFrame.GRM_AltGroupingScrollChildFrame.AllFrameFontstrings[i - 1][1] , "BOTTOMLEFT" , 0 , - buffer );
                AltLvl:SetPoint( "TOP" , GRM_UI.GRM_MemberDetailMetaData.GRM_AltGroupingScrollBorderFrame.GRM_AltGroupingScrollChildFrame.AllFrameFontstrings[i - 1][2] , "BOTTOM" , 0 , - buffer );
                AltRank:SetPoint( "TOP" , GRM_UI.GRM_MemberDetailMetaData.GRM_AltGroupingScrollBorderFrame.GRM_AltGroupingScrollChildFrame.AllFrameFontstrings[i - 1][3] , "BOTTOM" , 0 , - buffer );
                AltLastOnline:SetPoint( "TOP" , GRM_UI.GRM_MemberDetailMetaData.GRM_AltGroupingScrollBorderFrame.GRM_AltGroupingScrollChildFrame.AllFrameFontstrings[i - 1][4] , "BOTTOM" , 0 , - buffer );
                scrollHeight = scrollHeight + stringHeight + buffer;
            end
            -- Main tag
            if listOfAlts[i][5] then
                GRM_UI.GRM_MemberDetailMetaData.GRM_AltGroupingScrollBorderFrame.GRM_AltGroupingScrollChildFrame.GRM_MainTag:SetPoint ( "TOP" , AltName , "BOTTOM" );
                GRM_UI.GRM_MemberDetailMetaData.GRM_AltGroupingScrollBorderFrame.GRM_AltGroupingScrollChildFrame.GRM_MainTag:Show();
                mainFound = true;
            end
            
            AltName:Show();
            AltLvl:Show();
            AltRank:Show();
            AltLastOnline:Show();
        end

        if not mainFound then
            GRM_UI.GRM_MemberDetailMetaData.GRM_AltGroupingScrollBorderFrame.GRM_AltGroupingScrollChildFrame.GRM_MainTag:Hide();
        end
                
        -- Hides all the additional strings... if necessary
        for i = #listOfAlts + 1 , #GRM_UI.GRM_MemberDetailMetaData.GRM_AltGroupingScrollBorderFrame.GRM_AltGroupingScrollChildFrame.AllFrameFontstrings do
            GRM_UI.GRM_MemberDetailMetaData.GRM_AltGroupingScrollBorderFrame.GRM_AltGroupingScrollChildFrame.AllFrameFontstrings[i][1]:Hide();
            GRM_UI.GRM_MemberDetailMetaData.GRM_AltGroupingScrollBorderFrame.GRM_AltGroupingScrollChildFrame.AllFrameFontstrings[i][2]:Hide();
            GRM_UI.GRM_MemberDetailMetaData.GRM_AltGroupingScrollBorderFrame.GRM_AltGroupingScrollChildFrame.AllFrameFontstrings[i][3]:Hide();
            GRM_UI.GRM_MemberDetailMetaData.GRM_AltGroupingScrollBorderFrame.GRM_AltGroupingScrollChildFrame.AllFrameFontstrings[i][4]:Hide();
        end 
    
        -- Update the size -- it either grows or it shrinks!
        GRM_UI.GRM_MemberDetailMetaData.GRM_AltGroupingScrollBorderFrame.GRM_AltGroupingScrollChildFrame:SetSize ( scrollWidth , scrollHeight );
    
        --Set Slider Parameters ( has to be done after the above details are placed )
        local scrollMax = ( scrollHeight - 105 ) + ( buffer ); 
        if scrollMax < 0 then
            scrollMax = 0;
            GRM_UI.GRM_MemberDetailMetaData.GRM_AltGroupingScrollBorderFrame.GRM_AltGroupingScrollChildFrame.GRM_AltGroupingScrollFrameSlider:Hide();
            GRM_UI.GRM_MemberDetailMetaData.GRM_AltGroupingScrollBorderFrame.GRM_AltGroupingScrollFrame:EnableMouseWheel( false );
        else
            GRM_UI.GRM_MemberDetailMetaData.GRM_AltGroupingScrollBorderFrame.GRM_AltGroupingScrollChildFrame.GRM_AltGroupingScrollFrameSlider:SetMinMaxValues ( 0 , scrollMax );
            -- Mousewheel Scrolling Logic
            GRM_UI.GRM_MemberDetailMetaData.GRM_AltGroupingScrollBorderFrame.GRM_AltGroupingScrollFrame:EnableMouseWheel( true );
            GRM_UI.GRM_MemberDetailMetaData.GRM_AltGroupingScrollBorderFrame.GRM_AltGroupingScrollFrame:SetScript( "OnMouseWheel" , function( _ , delta )
                local current = GRM_UI.GRM_MemberDetailMetaData.GRM_AltGroupingScrollBorderFrame.GRM_AltGroupingScrollChildFrame.GRM_AltGroupingScrollFrameSlider:GetValue();
                
                if delta < 0 and current < scrollMax then
                    if IsControlKeyDown() then
                        GRM_UI.GRM_MemberDetailMetaData.GRM_AltGroupingScrollBorderFrame.GRM_AltGroupingScrollChildFrame.GRM_AltGroupingScrollFrameSlider:SetValue ( current + 60 );
                    else
                        GRM_UI.GRM_MemberDetailMetaData.GRM_AltGroupingScrollBorderFrame.GRM_AltGroupingScrollChildFrame.GRM_AltGroupingScrollFrameSlider:SetValue ( current + 20 );
                    end
                elseif delta > 0 and current > 1 then
                    if IsControlKeyDown() then
                        GRM_UI.GRM_MemberDetailMetaData.GRM_AltGroupingScrollBorderFrame.GRM_AltGroupingScrollChildFrame.GRM_AltGroupingScrollFrameSlider:SetValue ( current - 60 );
                    else
                        GRM_UI.GRM_MemberDetailMetaData.GRM_AltGroupingScrollBorderFrame.GRM_AltGroupingScrollChildFrame.GRM_AltGroupingScrollFrameSlider:SetValue ( current - 20 );
                    end
                end
            end);
            GRM_UI.GRM_MemberDetailMetaData.GRM_AltGroupingScrollBorderFrame.GRM_AltGroupingScrollChildFrame.GRM_AltGroupingScrollFrameSlider:Show();
        end
    end 
end

-- Method:          GRM.BuildAutoCompleteAltSelectionScrollFrame ( table )
-- What it Does:    The add alt list is now a scroll frame rather than 6 static choices...
-- Purpose:         Quality of life improvement on selecting players to add to alt. Just makes it easier to find matches.
GRM.BuildAutoCompleteAltSelectionScrollFrame = function ( listOfAlts )
    local buttonCap = GRM_G.MaxAltAutoCompleteList;
    local numButtons = #listOfAlts;
    if numButtons > buttonCap then
        numButtons = buttonCap;
    end
    GRM_G.NumberAltInSelection = numButtons;

    local scrollHeight = 0;
    local scrollWidth = GRM_UI.GRM_MemberDetailMetaData.GRM_CoreAltFrame.GRM_AddAltEditFrame:GetWidth() - 10;

    GRM_UI.GRM_MemberDetailMetaData.GRM_CoreAltFrame.GRM_AddAltEditFrame.GRM_AddAltScrollChildFrame.AllButtons = GRM_UI.GRM_MemberDetailMetaData.GRM_CoreAltFrame.GRM_AddAltEditFrame.GRM_AddAltScrollChildFrame.AllButtons or {};  -- Create a table for the Buttons.
    for i = 1 , numButtons do  -- The +1 is for the player so they can count themselves too...
        -- if font string is not created, do so.
        if not GRM_UI.GRM_MemberDetailMetaData.GRM_CoreAltFrame.GRM_AddAltEditFrame.GRM_AddAltScrollChildFrame.AllButtons[i] then
            local tempButton = CreateFrame ( "Button" , "AltSelection" .. i , GRM_UI.GRM_MemberDetailMetaData.GRM_CoreAltFrame.GRM_AddAltEditFrame.GRM_AddAltScrollChildFrame ); -- Names each Button 1 increment up
            GRM_UI.GRM_MemberDetailMetaData.GRM_CoreAltFrame.GRM_AddAltEditFrame.GRM_AddAltScrollChildFrame.AllButtons[i] = { tempButton , tempButton:CreateFontString ( nil , "OVERLAY" , "GameFontWhiteTiny" )  };
        end

        local button = GRM_UI.GRM_MemberDetailMetaData.GRM_CoreAltFrame.GRM_AddAltEditFrame.GRM_AddAltScrollChildFrame.AllButtons[i][1];
        local buttonText = GRM_UI.GRM_MemberDetailMetaData.GRM_CoreAltFrame.GRM_AddAltEditFrame.GRM_AddAltScrollChildFrame.AllButtons[i][2];

        button:SetSize ( 149 , 18.5 );
        button:SetHighlightTexture ( "Interface\\Buttons\\UI-Panel-Button-Highlight" );

        local classColor = GRM.GetClassColorRGB ( listOfAlts[i][2] , false );
        buttonText:SetTextColor ( classColor[1] , classColor[2] , classColor[3] );
        buttonText:SetFont ( GRM_G.FontChoice , GRM_G.FontModifier + 11 );
        buttonText:SetJustifyH ( "LEFT" );
        buttonText:SetText ( listOfAlts[i][1] .. GRM.GetAltTag ( listOfAlts[i][3] ) );
        buttonText:SetPoint ( "LEFT" , button );

        if i == 1 then
            button:SetPoint ( "TOP" , GRM_UI.GRM_MemberDetailMetaData.GRM_CoreAltFrame.GRM_AddAltEditFrame.GRM_AddAltScrollChildFrame , "TOP" , 0 , 0 );
        else 
            button:SetPoint ( "TOPLEFT" , GRM_UI.GRM_MemberDetailMetaData.GRM_CoreAltFrame.GRM_AddAltEditFrame.GRM_AddAltScrollChildFrame.AllButtons[i-1][1] , "BOTTOMLEFT" , 0 , 0 );
        end
        -- Build height
        scrollHeight = scrollHeight + button:GetHeight();
        -- Set button logic...
        button:SetScript ( "OnClick" , function ( self , key )
            if key == "LeftButton" then

                local result = GRM.RemoveMainAltTags ( GRM_UI.GRM_MemberDetailMetaData.GRM_CoreAltFrame.GRM_AddAltEditFrame.GRM_AddAltScrollChildFrame.AllButtons[i][2]:GetText() )

                if GRM_UI.GRM_MemberDetailMetaData.GRM_CoreAltFrame.GRM_AddAltEditFrame.GRM_AddAltEditBox:GetText() == result then

                    GRM_UI.AddAltSideFrameLogic ( GRM_UI.GRM_MemberDetailMetaData.GRM_CoreAltFrame.GRM_AddAltEditFrame.GRM_AddAltEditBox );

                else
                    GRM_G.currentHighlightIndex = i;
                    result = GRM.RemoveMainAltTags ( result );
                    GRM_UI.GRM_MemberDetailMetaData.GRM_CoreAltFrame.GRM_AddAltEditFrame.GRM_AddAltEditBox:SetText ( result );
                    GRM_UI.GRM_MemberDetailMetaData.GRM_CoreAltFrame.GRM_AddAltEditFrame.GRM_AddAltEditBox:SetFocus();
                    GRM_UI.GRM_MemberDetailMetaData.GRM_CoreAltFrame.GRM_AddAltEditFrame.GRM_AddAltEditBox:SetCursorPosition ( #GRM_UI.GRM_MemberDetailMetaData.GRM_CoreAltFrame.GRM_AddAltEditFrame.GRM_AddAltEditBox:GetText() );
                    GRM_UI.GRM_MemberDetailMetaData.GRM_CoreAltFrame.GRM_AddAltEditFrame.GRM_AddAltEditBox:HighlightText ( #GRM_UI.GRM_MemberDetailMetaData.GRM_CoreAltFrame.GRM_AddAltEditFrame.GRM_AddAltEditBox:GetText() + 1 );
                    GRM.AddAltAutoComplete();
                end

            end
        end);
        button:Show();
    end
    -- Hide unused buttons...
    for i = numButtons + 1 , #GRM_UI.GRM_MemberDetailMetaData.GRM_CoreAltFrame.GRM_AddAltEditFrame.GRM_AddAltScrollChildFrame.AllButtons do
        GRM_UI.GRM_MemberDetailMetaData.GRM_CoreAltFrame.GRM_AddAltEditFrame.GRM_AddAltScrollChildFrame.AllButtons[i][1]:Hide();
    end
    -- Reset the highlight...

    -- Configure Slider
    GRM.ConfigureSlider ( GRM_UI.GRM_MemberDetailMetaData.GRM_CoreAltFrame.GRM_AddAltEditFrame.GRM_AddAltScrollFrame , GRM_UI.GRM_MemberDetailMetaData.GRM_CoreAltFrame.GRM_AddAltEditFrame.GRM_AddAltScrollChildFrame , GRM_UI.GRM_MemberDetailMetaData.GRM_CoreAltFrame.GRM_AddAltEditFrame.GRM_AddAltScrollFrameSlider , scrollWidth , scrollHeight , 84 , true )
end

-- Method:          GRM.BuildAutoCompleteBanNames ( table )
-- What it Does:    When cycling ban names, this provides an auto-complete list
-- Purpose:         Quality of life improvement on selecting players to add as a ban. Just makes it easier to find matches.
GRM.BuildAutoCompleteBanNames = function ( listOfAlts )
    local buttonCap = GRM_G.MaxAltAutoCompleteList;
    local numButtons = #listOfAlts;
    if numButtons > buttonCap then
        numButtons = buttonCap;
    end

    local scrollHeight = 0;
    local scrollWidth = GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_AddBanFrame.GRM_AddBanScrollFrame:GetWidth() - 5;

    GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_AddBanFrame.GRM_AddBanScrollChildFrame.AllButtons = GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_AddBanFrame.GRM_AddBanScrollChildFrame.AllButtons or {};  -- Create a table for the Buttons.
    for i = 1 , numButtons do  -- The +1 is for the player so they can count themselves too...
        -- if font string is not created, do so.
        if not GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_AddBanFrame.GRM_AddBanScrollChildFrame.AllButtons[i] then
            local tempButton = CreateFrame ( "Button" , "BanButton" .. i , GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_AddBanFrame.GRM_AddBanScrollChildFrame ); -- Names each Button 1 increment up
            GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_AddBanFrame.GRM_AddBanScrollChildFrame.AllButtons[i] = { tempButton , tempButton:CreateFontString ( nil , "OVERLAY" , "GameFontWhiteTiny" )  };
        end

        local button = GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_AddBanFrame.GRM_AddBanScrollChildFrame.AllButtons[i][1];
        local buttonText = GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_AddBanFrame.GRM_AddBanScrollChildFrame.AllButtons[i][2];

        button:SetSize ( 112 , 14 );
        button:SetHighlightTexture ( "Interface\\Buttons\\UI-Panel-Button-Highlight" );

        local classColor = GRM.GetClassColorRGB ( listOfAlts[i][2] , false );
        buttonText:SetTextColor ( classColor[1] , classColor[2] , classColor[3] );
        buttonText:SetFont ( GRM_G.FontChoice , GRM_G.FontModifier + 8 );
        buttonText:SetJustifyH ( "LEFT" );
        buttonText:SetText ( listOfAlts[i][1] );
        buttonText:SetPoint ( "LEFT" , button );

        if i == 1 then
            button:SetPoint ( "TOP" , GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_AddBanFrame.GRM_AddBanScrollChildFrame , "TOP" , 0 , 0 );
            GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_AddBanFrame.GRM_AddBanScrollFrame:Show();
        else 
            button:SetPoint ( "TOPLEFT" , GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_AddBanFrame.GRM_AddBanScrollChildFrame.AllButtons[i-1][1] , "BOTTOMLEFT" , 0 , 0 );
        end
        -- Build height
        scrollHeight = scrollHeight + button:GetHeight();
        -- Set button logic...
        button:SetScript ( "OnClick" , function ( _ , key )
            if key == "LeftButton" then
                GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_AddBanFrame.GRM_AddBanNameSelectionEditBox.clickControl = true;
                local indexOfClass = 1
                local result = GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_AddBanFrame.GRM_AddBanScrollChildFrame.AllButtons[i][2]:GetText();
                local class = "";

                for i = 1 , #GRM_G.autoCompleteBanList do
                    if GRM_G.autoCompleteBanList[i][1] == result then
                        class = GRM_G.autoCompleteBanList[i][2];
                    end
                end

                -- Set the index                
                for j = 1 , #AllClasses do
                    if string.lower ( AllClasses[j] ) == string.lower ( class ) then
                        indexOfClass = j;
                        break;
                    end
                end

                GRM_G.tempAddBanClass = string.upper ( AllClasses[indexOfClass] );
                local colors = GRM.GetClassColorRGB ( GRM_G.tempAddBanClass );

                -- Now, update the targets
                local tempName = GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_AddBanFrame.GRM_AddBanNameSelectionEditBox:GetText() .. "-" .. GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_AddBanFrame.GRM_BanServerSelected.GRM_BanServerSelectedText:GetText();
                local tempClass = GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_AddBanFrame.GRM_AddBanDropDownClassSelectedText:GetText();

                GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_AddBanFrame.GRM_AddBanNameSelectionEditBox:SetText ( GRM.SlimName ( result ) );
                GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_AddBanFrame.GRM_BanServerSelected.GRM_BanServerSelectedText:SetText ( string.sub ( result , string.find ( result , "-" ) + 1 ) );
                GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_AddBanFrame.GRM_AddBanDropDownClassSelectedText:SetText ( GRM.L ( GRM.Capitalize ( GRM_G.tempAddBanClass ) ) );
                GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_AddBanFrame.GRM_AddBanDropDownClassSelectedText:SetTextColor ( colors[1] , colors[2] , colors[3] );

                if tempName == result and tempClass == GRM.L ( GRM.Capitalize ( GRM_G.tempAddBanClass ) ) then
                    GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_AddBanFrame.GRM_AddBanNameSelectionEditBox:ClearFocus();
                end
            end
        end);
        button:Show();
    end
    -- Hide unused buttons...
    for i = numButtons + 1 , #GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_AddBanFrame.GRM_AddBanScrollChildFrame.AllButtons do
        GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_AddBanFrame.GRM_AddBanScrollChildFrame.AllButtons[i][1]:Hide();
    end
    if numButtons == 0 then
        GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_AddBanFrame.GRM_AddBanScrollFrame.GRM_BanFrameHelperText:SetText ( GRM.L ( "No Matches Found. Add a Custom New Player or Match" ) );
    else
        GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_AddBanFrame.GRM_AddBanScrollFrame.GRM_BanFrameHelperText:SetText ( GRM.L ( "Former and Current Members" ) );
    end
    -- Reset the highlight...

    -- Configure Slider
    GRM.ConfigureSlider ( GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_AddBanFrame.GRM_AddBanScrollFrame , GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_AddBanFrame.GRM_AddBanScrollChildFrame , GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_AddBanFrame.GRM_AddBanScrollFrame.GRM_AddBanScrollFrameSlider , scrollWidth , scrollHeight , 98 , true )
end

-- Method:          GRM.ResetAutoCompleteHighlights()
-- What it Does:    Resets all highlights and disables except for the one selected
-- Purpose:         Quality of life visual controls...
GRM.ResetAutoCompleteHighlights = function ()
    for i = 1 , #GRM_UI.GRM_MemberDetailMetaData.GRM_CoreAltFrame.GRM_AddAltEditFrame.GRM_AddAltScrollChildFrame.AllButtons do
        if i ~= GRM_G.currentHighlightIndex then
            GRM_UI.GRM_MemberDetailMetaData.GRM_CoreAltFrame.GRM_AddAltEditFrame.GRM_AddAltScrollChildFrame.AllButtons[i][1]:UnlockHighlight();
        end
    end
end

-- Method:          GRM.ConfigureSlider ( scrollFrameObject , frameObject , sliderFrameObject , int , int , int )
-- What it Does:    Configures any scrollframes variables to a consistent setting for the addon given the inputs.
-- Purpose:         Keep down on code bloat for each scrollframe.
GRM.ConfigureSlider = function ( scrollFrame , childFrame , slider , scrollWidth , scrollHeight , staticFrameSize , hideSliderIfNotNeeded )
    --Set Slider Parameters ( has to be done after the above details are placed )
    childFrame:SetSize ( scrollWidth , scrollHeight );
    local scrollMax = ( scrollHeight - staticFrameSize );
    if scrollMax < 0 then
        scrollMax = 0;
    end

    -- Mousewheel Scrolling Logic
    slider:SetMinMaxValues ( 0 , scrollMax );
    scrollFrame:EnableMouseWheel( true );
    scrollFrame:SetScript( "OnMouseWheel" , function( _ , delta )
        local current = slider:GetValue();

        if IsShiftKeyDown() and delta > 0 then
            slider:SetValue ( 0 );
        elseif IsShiftKeyDown() and delta < 0 then
            slider:SetValue ( scrollMax );
        elseif delta < 0 and current < scrollMax then
            if IsControlKeyDown() then
                slider:SetValue ( current + 60 );
            else
                slider:SetValue ( current + 20 );
            end
        elseif delta > 0 and current > 1 then
            if IsControlKeyDown() then
                slider:SetValue ( current - 60 );
            else
                slider:SetValue ( current - 20 );
            end
        end
    end);

    if hideSliderIfNotNeeded and scrollMax == 0 then
        slider:Hide();
    else
        slider:Show();
    end
end


-- Method:          GRM.GetBackupEntries ()
-- What it Does:    Gets all of the guild information for all guilds' saved data.
-- Purpose:         Hybrid scrollframe load of the backup features.
GRM.GetBackupEntries = function ()
    local result = {};
    local guildCreationDate = "";
    local numGuildies = 0;
    local date = "";

    for guildName in pairs ( GRM_GuildDataBackup_Save ) do

        numGuildies = GRM_GuildDataBackup_Save[guildName].numGuildies;

        if GRM_GuildDataBackup_Save[guildName].guildCreationDate ~= "" then
            local day , month , year = string.match ( GRM_GuildDataBackup_Save[guildName].guildCreationDate , "(%d+)-(%d+)-(%d+)" );
            guildCreationDate = GRM.FormatTimeStamp ( { tonumber ( day ) , tonumber ( month ) , tonumber ( year ) } );
        else
            guildCreationDate = "";
        end

        if GRM_GuildDataBackup_Save[guildName].date ~= "" then
            date = GRM.FormatTimeStamp ( GRM_GuildDataBackup_Save[guildName].date );
        else
            date = "";
        end

        -- Set the current guild you are in as first entries.
        if guildName == GRM_G.guildName then
            table.insert ( result , 1 , { 1 , guildName } );
            table.insert ( result , 2 , { 2 , GRM.L ( "Restore Date:" ) , date , guildCreationDate , numGuildies } );
            table.insert ( result , 3 , { 3 } );
        else
            table.insert ( result , { 1 , guildName } );
            table.insert ( result , { 2 , GRM.L ( "Restore Date:" ) , date , guildCreationDate , numGuildies } );
            table.insert ( result , { 3 } );
        end

    end

    return result;
end

-- Method:          GRM.BackupHybridShiftDown()
-- What it Does:    Shifts the values down by 1 when using the mousewheel
-- Purpose:         Hybrid Scroll frame capabilities on the backup window.
GRM.BackupHybridShiftDown = function()
    local buttons = GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_UIOptionsFrame.GRM_CoreBackupScrollChildFrame.AllBackupButtons;
    local MouseOverButton = 0;

    -- Shift them down...
    for i = 1 , #buttons - 1 do

        -- Header Line
        if buttons[i+1][2]:IsVisible() then
            -- Values shift
            buttons[i][2]:SetText( buttons[i+1][2]:GetText() );
            buttons[i][2]:SetTextColor ( buttons[i+1][2]:GetTextColor ( buttons[i+1][2]:GetText() ) );

            buttons[i][2]:Show();
            buttons[i][3]:Hide();
            buttons[i][4]:Hide();
            buttons[i][5]:Hide();
            buttons[i][6]:Hide();

            if buttons[i+1][7]:IsVisible() then
                buttons[i][7]:SetText( buttons[i+1][7]:GetText() );
                buttons[i][7]:Show();
            else
                buttons[i][7]:Hide();
            end
            if buttons[i+1][8]:IsVisible() then
                buttons[i][8]:Show();
            else
                buttons[i][8]:Hide();
            end

        elseif buttons[i+1][3]:IsVisible() then
            -- Values Shift
            buttons[i][3]:SetText( buttons[i+1][3]:GetText() );
            buttons[i][4]:SetText( buttons[i+1][4]:GetText() );
            buttons[i][5]:SetText( buttons[i+1][5]:GetText() );
            buttons[i][6]:SetText( buttons[i+1][6]:GetText() );
            
            -- Appearance
            buttons[i][2]:Hide();
            buttons[i][3]:Show();
            buttons[i][4]:Show();
            buttons[i][5]:Show();
            buttons[i][6]:Show();
            buttons[i][7]:Hide();
            buttons[i][8]:Hide();

        else

            buttons[i][2]:Hide()
            buttons[i][3]:Hide(); 
            buttons[i][4]:Hide();
            buttons[i][5]:Hide();
            buttons[i][6]:Hide();
            buttons[i][7]:Hide();
            buttons[i][8]:Hide();
        end

        if MouseOverButton == 0 and buttons[i][1]:IsMouseOver() then
            MouseOverButton = i;
        end
    end

    GRM.BackupSetLastValue();

    if MouseOverButton > 0 then
        GRM.UpdateBackupTooltip( MouseOverButton );
    end
end

-- Method:          GRM.BackupHybridShiftUp()
-- What it Does:    Shifts the values up by 1 when using the mousewheel
-- Purpose:         Hybrid Scroll frame capabilities on the backup window.
GRM.BackupHybridShiftUp = function()
    local buttons = GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_UIOptionsFrame.GRM_CoreBackupScrollChildFrame.AllBackupButtons;
    local MouseOverButton = 0;

    -- Shift them down...
    for i = #buttons , 2 , -1 do

        -- Header Line
        if buttons[i-1][2]:IsVisible() then
            -- Values shift
            buttons[i][2]:SetText( buttons[i-1][2]:GetText() );
            buttons[i][2]:SetTextColor ( buttons[i-1][2]:GetTextColor ( buttons[i-1][2]:GetText() ) );

            buttons[i][2]:Show();
            buttons[i][3]:Hide();
            buttons[i][4]:Hide();
            buttons[i][5]:Hide();
            buttons[i][6]:Hide();

            if buttons[i-1][7]:IsVisible() then
                buttons[i][7]:SetText( buttons[i-1][7]:GetText() );
                buttons[i][7]:Show();
            else
                buttons[i][7]:Hide();
            end
            if buttons[i-1][8]:IsVisible() then
                buttons[i][8]:Show();
            else
                buttons[i][8]:Hide();
            end

        elseif buttons[i-1][3]:IsVisible() then
            -- Values Shift
            buttons[i][3]:SetText( buttons[i-1][3]:GetText() );
            buttons[i][4]:SetText( buttons[i-1][4]:GetText() );
            buttons[i][5]:SetText( buttons[i-1][5]:GetText() );
            buttons[i][6]:SetText( buttons[i-1][6]:GetText() );
            
            -- Appearance
            buttons[i][2]:Hide();
            buttons[i][3]:Show();
            buttons[i][4]:Show();
            buttons[i][5]:Show();
            buttons[i][6]:Show();
            buttons[i][7]:Hide();
            buttons[i][8]:Hide();
            
        else

            buttons[i][2]:Hide()
            buttons[i][3]:Hide(); 
            buttons[i][4]:Hide();
            buttons[i][5]:Hide();
            buttons[i][6]:Hide();
            buttons[i][7]:Hide();
            buttons[i][8]:Hide();
        end

        if MouseOverButton == 0 and buttons[i][1]:IsMouseOver() then
            MouseOverButton = i;
        end
    end
    GRM.BackupSetFirstValue();
    if MouseOverButton > 0 then
        GRM.UpdateBackupTooltip( MouseOverButton );
    end
end

-- Method:          GRM.BackupSetLastValue()
-- What it Does:    Sets the last value of the hybridscrollframe backups at position 12
-- Purpose:         Clean scrolling
GRM.BackupSetLastValue = function()
    GRM.SetBackupValues ( #GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_UIOptionsFrame.GRM_CoreBackupScrollChildFrame.AllBackupButtons , GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_UIOptionsFrame.GRM_CoreBackupScrollChildFrame.Offset );
end

-- Method:          GRM.BackupSetFirstValue()
-- What it Does:    Sets the first value of the hybridscrollframe backups at position 1
-- Purpose:         Clean scrolling
GRM.BackupSetFirstValue = function()
    GRM.SetBackupValues ( 1 , GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_UIOptionsFrame.GRM_CoreBackupScrollChildFrame.Offset - #GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_UIOptionsFrame.GRM_CoreBackupScrollChildFrame.AllBackupButtons + 1 );
end

-- Method:          GRM.UpdateBackupTooltip ( int )
-- What it Does:    Builds the tooltip for the backup window
-- Purpose:         Quality of life feature
GRM.UpdateBackupTooltip = function( ind )
    if not GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_UIOptionsFrame.GRM_BackupPurgeGuildOption:IsVisible() and GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_UIOptionsFrame.GRM_CoreBackupScrollChildFrame.AllBackupButtons[ind][2]:IsVisible() and GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_UIOptionsFrame.GRM_CoreBackupScrollChildFrame.AllBackupButtons[ind][1]:IsMouseOver() then
        GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_UIOptionsFrame.GRM_GuildNameTooltip:SetOwner( GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_UIOptionsFrame.GRM_CoreBackupScrollChildFrame.AllBackupButtons[ind][1] , "ANCHOR_CURSOR" );
        GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_UIOptionsFrame.GRM_GuildNameTooltip:AddLine ( GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_UIOptionsFrame.GRM_CoreBackupScrollChildFrame.AllBackupButtons[ind][2]:GetText() , 0.64 , 0.102 , 0.102 );
        GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_UIOptionsFrame.GRM_GuildNameTooltip:AddLine ( GRM.L ( "Right-Click for options to remove this guild from the addon database completely" ) , 1 , 0.84 , 0 , true );

        if GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_UIOptionsFrame.GRM_CoreBackupScrollChildFrame.AllBackupButtons[ind][5]:GetText() == GRM.L ( "Unknown" ) and GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_UIOptionsFrame.GRM_CoreBackupScrollChildFrame.AllBackupButtons[ind][6]:GetText() == GRM.L ( "Unknown" ) then
            GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_UIOptionsFrame.GRM_GuildNameTooltip:AddLine ( GRM.L ( "No player data found, recommend full removal." ) , 1 , 0 , 0 , true );
        end

        GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_UIOptionsFrame.GRM_GuildNameTooltip:Show();
    elseif not GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_UIOptionsFrame.GRM_CoreBackupScrollChildFrame.AllBackupButtons[ind][2]:IsVisible() or not GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_UIOptionsFrame.GRM_CoreBackupScrollChildFrame.AllBackupButtons[ind][1]:IsMouseOver() then
        GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_UIOptionsFrame.GRM_GuildNameTooltip:Hide();
    end
end

-- Method:          GRM.SetBackupValues ( int , int )
-- What it Does:    Builds the values of the hybrid scroll frame given button
-- Purpose:         Establish the values for the backup window
GRM.SetBackupValues = function ( ind , ind2 )
    local line = GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_UIOptionsFrame.GRM_CoreBackupScrollChildFrame.AllBackupButtons[ind];

    -- Main top Line
    if GRM_G.BackupEntries[ind2][1] == 1 then

        line[2]:SetText ( GRM_G.BackupEntries[ind2][2] );
        line[2]:SetTextColor ( 0.64 , 0.102 , 0.102 );
        
        line[2]:Show(); -- GuildName
        line[3]:Hide(); -- "Restore Date: "
        line[4]:Hide(); -- Date of backup
        line[5]:Hide(); -- CreationDate
        line[6]:Hide(); -- NumGUildies

        if GRM_G.BackupEntries[ind2+1][3] == "" then

            line[7]:SetText ( GRM.L ( "Set Restore Point" ) );
            line[7]:Show();
            line[8]:Hide();
        else

            if GRM_G.BackupEntries[ind2][2] == GRM_G.guildName then
                line[7]:SetText ( GRM.L ( "Restore" ) );
            else
                line[7]:SetText ( GRM.L ( "Transfer Data" ) );
            end
            line[7]:Show();
            line[8]:Show();
        end
        
    elseif GRM_G.BackupEntries[ind2][1] == 2 then

        line[3]:SetText ( GRM_G.BackupEntries[ind2][2] )

        if GRM_G.BackupEntries[ind2][3] == "" then
            line[4]:SetText ( " < " .. GRM.L ( "None" ) .. " > " );
        else
            line[4]:SetText ( GRM_G.BackupEntries[ind2][3] );
        end

        if GRM_G.BackupEntries[ind2][4] == "" then
            line[5]:SetText ( GRM.L ( "Unknown" ) );
        else
            line[5]:SetText ( GRM_G.BackupEntries[ind2][4] );
        end

        line[6]:SetText ( GRM_G.BackupEntries[ind2][5] );

        line[2]:Hide();
        line[3]:Show();
        line[4]:Show();
        line[5]:Show();
        line[6]:Show();
        line[7]:Hide();
        line[8]:Hide();

    elseif GRM_G.BackupEntries[ind2][1] == 3 then
        line[2]:Hide()
        line[3]:Hide(); 
        line[4]:Hide();
        line[5]:Hide();
        line[6]:Hide();
        line[7]:Hide();
        line[8]:Hide();
    end

    -- Update the tooltip if underlying data changes
    if GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_UIOptionsFrame.GRM_GuildNameTooltip:IsVisible() and GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_UIOptionsFrame.GRM_CoreBackupScrollChildFrame.AllBackupButtons[ind][1]:IsMouseOver() then 
        GRM.UpdateBackupTooltip ( ind );
    end

    GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_UIOptionsFrame.GRM_BackupPurgeGuildOption:Hide();
end

-- Method:          GRM.BuildBackupScrollFrame ( bool , bool )
-- What it Does:    Builds the backup hybdrid scrollframe and initializes the buttons properly
-- Purpose:         Backup optional functionality
GRM.BuildBackupScrollFrame = function ( showAll , fullRefresh )
    local hybridScrollFrameButtonCount = 15;
    local buttonHeight = 26.6;
    local scrollHeight = 0;
    local buttonWidth = 278;

    if showAll and fullRefresh then
        GRM_G.BackupEntries = GRM.GetBackupEntries();
        -- Establish the memory use...
        UpdateAddOnMemoryUsage();

        GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_UIOptionsFrame.GRM_MemoryUsageText:SetText ( 
            GRM.L ( "Memory Usage: {num} MB" , nil , nil , GRM.Round ( GetAddOnMemoryUsage ( GRM_G.addonName ) / 1000 , 2 ) )
        );

    end

    GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_UIOptionsFrame.GRM_BackupPurgeGuildOption:Hide();

    GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_UIOptionsFrame.GRM_CoreBackupScrollChildFrame.AllBackupButtons = GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_UIOptionsFrame.GRM_CoreBackupScrollChildFrame.AllBackupButtons or {};
    GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_UIOptionsFrame.GRM_CoreBackupScrollChildFrame.Offset = GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_UIOptionsFrame.GRM_CoreBackupScrollChildFrame.Offset or ( hybridScrollFrameButtonCount );

    if GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_UIOptionsFrame.GRM_CoreBackupScrollChildFrame.Offset < hybridScrollFrameButtonCount then
        GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_UIOptionsFrame.GRM_CoreBackupScrollChildFrame.Offset = hybridScrollFrameButtonCount;
    elseif GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_UIOptionsFrame.GRM_CoreBackupScrollChildFrame.Offset > hybridScrollFrameButtonCount and GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_UIOptionsFrame.GRM_CoreBackupScrollChildFrame.Offset > #GRM_G.BackupEntries then
        GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_UIOptionsFrame.GRM_CoreBackupScrollChildFrame.Offset = #GRM_G.BackupEntries;
    end

    for i = 1 , #GRM_G.BackupEntries do
        -- Build HybridScrollFrame Buttons
        if i <= hybridScrollFrameButtonCount then
            if not GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_UIOptionsFrame.GRM_CoreBackupScrollChildFrame.AllBackupButtons[i] then

                local button = CreateFrame ( "Button" , "GRMBackupCoreButton_" .. i , GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_UIOptionsFrame.GRM_CoreBackupScrollChildFrame );
                GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_UIOptionsFrame.GRM_CoreBackupScrollChildFrame.AllBackupButtons[i] = {
                    button ,
                    button:CreateFontString ( nil , "OVERLAY" , "GameFontWhiteTiny" ) ,
                    button:CreateFontString ( nil , "OVERLAY" , "GameFontWhiteTiny" ) ,
                    button:CreateFontString ( nil , "OVERLAY" , "GameFontWhiteTiny" ) ,
                    button:CreateFontString ( nil , "OVERLAY" , "GameFontWhiteTiny" ) ,
                    button:CreateFontString ( nil , "OVERLAY" , "GameFontWhiteTiny" ) ,
                    CreateFrame ( "Button" , "GuildBackup1_" .. i , button , "UIPanelButtonTemplate" ) ,
                    CreateFrame ( "Button" , "GuildBackup2_" .. i , button , "UIPanelButtonTemplate" )
                };

                GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_UIOptionsFrame.GRM_CoreBackupScrollChildFrame.AllBackupButtons[i][8]:SetText ( GRM.L ( "Remove" ) );   -- all of these will be the same

                button = GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_UIOptionsFrame.GRM_CoreBackupScrollChildFrame.AllBackupButtons[i][1];
                if i == 1 then
                    button:SetPoint ( "TOP" , GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_UIOptionsFrame.GRM_CoreBackupScrollChildFrame , "TOP" , 12 , 0 );
                else 
                    button:SetPoint ( "TOPLEFT" , GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_UIOptionsFrame.GRM_CoreBackupScrollChildFrame.AllBackupButtons[i-1][1] , "BOTTOMLEFT" , 0 , 0 );
                end

                -- button:SetHighlightTexture ( "Interface\\Buttons\\UI-Panel-Button-Highlight" );
                button:SetSize ( buttonWidth , buttonHeight );
                GRM.BuildBackupHybridButtons ( i , false , hybridScrollFrameButtonCount );
                
            end
        end

        if i >= ( GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_UIOptionsFrame.GRM_CoreBackupScrollChildFrame.Offset - hybridScrollFrameButtonCount + 1 ) and i <= GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_UIOptionsFrame.GRM_CoreBackupScrollChildFrame.Offset then
            GRM.SetBackupValues ( i - ( GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_UIOptionsFrame.GRM_CoreBackupScrollChildFrame.Offset - hybridScrollFrameButtonCount ) , i );
            GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_UIOptionsFrame.GRM_CoreBackupScrollChildFrame.AllBackupButtons[i - ( GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_UIOptionsFrame.GRM_CoreBackupScrollChildFrame.Offset - hybridScrollFrameButtonCount )][1]:Show();
        end
        
        -- Slider Height is controlled by tallying how many of these are necessary
        scrollHeight = scrollHeight + buttonHeight;
    end
    -- Hide unused buttons...
    for i = #GRM_G.BackupEntries + 1 , #GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_UIOptionsFrame.GRM_CoreBackupScrollChildFrame.AllBackupButtons do
        GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_UIOptionsFrame.GRM_CoreBackupScrollChildFrame.AllBackupButtons[i][1]:Hide();
    end

    GRM.SetHybridScrollFrameSliderParameters ( 
        GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_UIOptionsFrame.GRM_CoreBackupScrollChildFrame , GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_UIOptionsFrame.GRM_CoreBackupScrollFrame , GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_UIOptionsFrame.GRM_CoreBackupScrollFrameSlider , 
        buttonWidth , buttonHeight , scrollHeight , #GRM_G.BackupEntries , GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_UIOptionsFrame.GRM_CoreBackupScrollChildFrame.AllBackupButtons , 
        GRM.BackupHybridShiftDown , GRM.BackupHybridShiftUp , hybridScrollFrameButtonCount
    );
end
 
-- Method:          GRM.BuildBackupHybridButtons ( int , boolean , int )
-- What it Does:    Initiates the buttons and logic for the Backup buttons
-- Purpose:         Compartmentalize the code for easier call back to.
GRM.BuildBackupHybridButtons = function ( ind , isResizeAction , numButtons )

    local coreButton = GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_UIOptionsFrame.GRM_CoreBackupScrollChildFrame.AllBackupButtons[ind][1];
    local buttonText1 = GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_UIOptionsFrame.GRM_CoreBackupScrollChildFrame.AllBackupButtons[ind][2];
    local buttonText2 = GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_UIOptionsFrame.GRM_CoreBackupScrollChildFrame.AllBackupButtons[ind][3];
    local buttonText3 = GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_UIOptionsFrame.GRM_CoreBackupScrollChildFrame.AllBackupButtons[ind][4];
    local buttonText4 = GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_UIOptionsFrame.GRM_CoreBackupScrollChildFrame.AllBackupButtons[ind][5];
    local buttonText5 = GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_UIOptionsFrame.GRM_CoreBackupScrollChildFrame.AllBackupButtons[ind][6];
    local button1 = GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_UIOptionsFrame.GRM_CoreBackupScrollChildFrame.AllBackupButtons[ind][7];
    local button2 = GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_UIOptionsFrame.GRM_CoreBackupScrollChildFrame.AllBackupButtons[ind][8];

    -- Guild Name
    buttonText1:SetPoint ( "LEFT" , coreButton , "LEFT" , 5 , 0 );
    buttonText1:SetFont ( GRM_G.FontChoice , GRM_G.FontModifier + 16 );
    buttonText1:SetJustifyH ( "LEFT" );
    buttonText1:SetWidth ( 278 )
    buttonText1:SetWordWrap ( false );

    -- Backup Header manual or auto
    buttonText2:SetPoint ( "LEFT" , coreButton , "LEFT" , 5 , 0 );
    buttonText2:SetFont ( GRM_G.FontChoice , GRM_G.FontModifier + 14 );
    buttonText2:SetWidth ( 100 );
    buttonText2:SetJustifyH ( "LEFT" );
    buttonText2:SetWordWrap ( false );

    -- Backup date of save
    buttonText3:SetPoint ( "LEFT" , buttonText2 , "RIGHT" , 10 , 0 );
    buttonText3:SetFont ( GRM_G.FontChoice , GRM_G.FontModifier + 14 );
    buttonText3:SetWidth ( 160 );
    buttonText3:SetJustifyH ( "CENTER" );
    buttonText3:SetWordWrap ( false );

    -- Creation Date
    buttonText4:SetPoint ( "LEFT" , buttonText1 , "RIGHT" , 12 , 0 );
    buttonText4:SetFont ( GRM_G.FontChoice , GRM_G.FontModifier + 16 );
    buttonText4:SetWidth ( 130 );
    buttonText4:SetJustifyH ( "CENTER" );
    buttonText4:SetWordWrap ( false );

    -- Num Guildies
    buttonText5:SetPoint ( "LEFT" , buttonText4 , "RIGHT" , 22 , 0 );
    buttonText5:SetFont ( GRM_G.FontChoice , GRM_G.FontModifier + 16 );
    buttonText5:SetWidth ( 110 );
    buttonText5:SetJustifyH ( "CENTER" );
    buttonText5:SetWordWrap ( false );

    
    if not isResizeAction then

        button1:SetSize ( 130 , 21 );
        button1:SetPoint ( "CENTER" , buttonText4 );

        button2:SetSize ( 110 , 21 );
        button2:SetPoint ( "CENTER" , buttonText5 );
        button2:SetText ( GRM.L ( "Remove" ) );         -- This will always be remove.

        coreButton:EnableMouse ( true );
        coreButton:RegisterForDrag ( "LeftButton" );
        button1:EnableMouse ( true );
        button1:RegisterForDrag ( "LeftButton" );
        button2:EnableMouse ( true );
        button2:RegisterForDrag ( "LeftButton" );

        -- Setup draggable conditions
        coreButton:SetScript ( "OnDragStart" , function()
            GRM_UI.GRM_RosterChangeLogFrame:StartMoving();
        end);
        coreButton:SetScript ( "OnDragStop" , function()
            GRM_UI.GRM_RosterChangeLogFrame:StopMovingOrSizing();
            GRM_UI.SaveCorePosition();
        end);

        -- Restore or Set Backup
        button1:SetScript ( "OnClick" , function ( self , buttonClicked )
            if buttonClicked == "LeftButton" then

                local guildName = buttonText1:GetText();

                -- For retore
                if self:GetText() == GRM.L ( "Restore" ) then
                    GRM_UI.GRM_RosterConfirmFrameText:SetText( GRM.L ( "Really restore {name} Backup Point?" , guildName ) );
                    GRM_UI.GRM_RosterConfirmYesButtonText:SetText ( GRM.L ( "Yes!" ) );

                    -- Popup window logic control
                    GRM_UI.GRM_RosterConfirmYesButton:SetScript ( "OnClick" , function( _ , button )
                        if button == "LeftButton" then
                            local gName = string.gsub ( guildName , "\"" , "" ); -- I only want to pass 1 value not 2
                            GRM.LoadRestorePoint ( gName );
                            GRM.BuildBackupScrollFrame ( true , true );
                            GRM_UI.GRM_RosterConfirmFrame:Hide();
                        end
                    end);
                    GRM_UI.GRM_RosterConfirmFrame:Show();

                elseif self:GetText() == GRM.L ( "Transfer Data" ) then
                    -- Not my guild
                    
                    local buttonLogic = function()

                        if not GRMsyncGlobals.currentlySyncing and not GRMsyncGlobals.LeadSyncProcessing then
                            -- Let's disable scan and sync during.
                            GRM_G.CurrentlyScanning = true;
                            local value = GRM.S().syncEnabled;
                            GRM.S().syncEnabled = false;

                            local gName = string.gsub ( guildName , "\"" , "" );
                            GRM.LoadRestorePoint ( GRM_G.guildName , true , gName  );
                            GRM.BuildBackupScrollFrame ( true , true );
                            GRM_UI.GRM_RosterConfirmFrame:Hide();

                            -- Need to trigger scan for changes.
                            C_Timer.After ( 3 , function()
                                GRM_G.CurrentlyScanning = false;
                                GRM.SlashCommandScan()
                                C_Timer.After ( 2 , function()
                                    GRM.S().syncEnabled = value;
                                end);
                            end);

                        else
                            GRM.Report ( GRM.L ( "You are currently syncing. Please wait until sync completes to transfer the guild data." ) );
                        end
                    end

                    GRM.InitiateConfirmFrame( GRM.L ( "Please confirm that \"{name}\" has transferred. Clicking YES will import all guild data." , guildName ) , buttonLogic , nil , nil , nil , nil , 300 , 120 )

                -- For manually setting the backup
                elseif self:GetText() == GRM.L ( "Set Restore Point" ) then

                    if guildName and guildName ~= "" then
                        local gName = string.gsub ( guildName , "\"" , "" );
                        GRM.AddGuildBackup ( gName , buttonText4:GetText() );
                        GRM.BuildBackupScrollFrame ( true , true );
                    else
                        GRM.Report ( GRM.L ( "Unable to properly locate guild for backup" ) );
                    end
                end
            end
        end);

        -- Remove a Backup
        button2:SetScript ( "OnClick" , function ( self , buttonClicked )
            if buttonClicked == "LeftButton" then
                local guildName = buttonText1:GetText();

                GRM_UI.GRM_RosterConfirmFrameText:SetText( GRM.L ( "Really remove {name} Backup Point?" , guildName ) );
                GRM_UI.GRM_RosterConfirmYesButtonText:SetText ( GRM.L ( "Yes!" ) );
                GRM_UI.GRM_RosterConfirmYesButton:SetScript ( "OnClick" , function( _ , button )
                    if button == "LeftButton" then
                        local gName = string.gsub ( guildName , "\"" , "" );
                        GRM.RemoveGuildBackup ( gName );
                        GRM.BuildBackupScrollFrame ( true , true );
                        GRM_UI.GRM_RosterConfirmFrame:Hide();
                    end
                end);
                GRM_UI.GRM_RosterConfirmFrame:Show();
            end
        end);

        coreButton:SetScript ( "OnMouseDown" , function ( self , button )
            if button == "RightButton" then
                

                if buttonText1:IsVisible() and self:IsMouseOver() then
                    local guildName = buttonText1:GetText();

                    GRM_G.BackupFrameSelectDetails = { guildName , buttonText4:GetText() };
                    GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_UIOptionsFrame.GRM_BackupPurgeGuildOption:ClearAllPoints();
                    GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_UIOptionsFrame.GRM_BackupPurgeGuildOption:SetPoint( "TOPRIGHT" , self , "TOPLEFT" , -12 , -5 );
                    GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_UIOptionsFrame.GRM_BackupPurgeGuildOption:Show();
                    GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_UIOptionsFrame.GRM_GuildNameTooltip:Hide();
                end
            end
        end);

        coreButton:SetScript ( "OnEnter" , function ( self )
            GRM.UpdateBackupTooltip ( tonumber ( string.sub ( self:GetName() , string.find ( self:GetName() , "_" ) + 1 ) ) );
        end);
        coreButton:SetScript ( "OnLeave" , function()
            GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_UIOptionsFrame.GRM_GuildNameTooltip:Hide();
        end);
    end
end

-- Method:          GRM.GetAuditEntries ()
-- What it Does:    Determines which grouping to import for sorted Audit list
-- Purpose:         Audit UX feature controls for sorting.
GRM.GetAuditEntries = function ()
    local typeOfSort = GRM_G.AuditSortType;
    local result = {};
    if typeOfSort == nil or typeOfSort == 1 then
        result =  GRM.GetAllGuildiesInOrder ( true , true );
    elseif typeOfSort == 2 then
        result =  GRM.GetAllGuildiesInOrder ( true , false );
    elseif typeOfSort == 3 then
        result = GRM.GetAllGuildiesInJoinDateOrder ( true , true );
    elseif typeOfSort == 4 then
        result = GRM.GetAllGuildiesInJoinDateOrder ( true , false );
    elseif typeOfSort == 5 then
        result = GRM.GetAllGuildiesInPromoDateOrder ( true , true );
    elseif typeOfSort == 6 then
        result = GRM.GetAllGuildiesInPromoDateOrder ( true , false );
    elseif typeOfSort == 7 then
        result = GRM.GetAllMainsAndAltsInOrder ( true );
    elseif typeOfSort == 8 then
        result = GRM.GetAllMainsAndAltsInOrder ( false );
    elseif typeOfSort == 9 then
        result = GRM.GetAllGuildiesByBirthdayDateOrder ( true , true );
    elseif typeOfSort == 10 then
        result = GRM.GetAllGuildiesByBirthdayDateOrder ( true , false );
    end
    return result;
end

-- Method:          GRM.GetAutoCompleteNamesForAudit ( string )
-- What it Does:    Updates the audit list to be shown as those to match the search box
-- Purpose:         Search for guildies
GRM.GetAutoCompleteNamesForAudit = function ( searchString )
    local matches = GRM.GetAutoCompleteMatches ( GRM.GetAllCurrentAndFormerGuildies ( true , false ) , searchString )
    local listOfGuildies = {};
    local isComplete = true;
    local joinDate = "";
    local promoDate = "";
    local mainStatus = "";
    local classColors = {};
    local birthDate = "";

    for i = 1 , #matches do
            -- proper name format
        joinDate , promoDate , mainStatus , isComplete , classColors , birthDate = GRM.GetAuditLinePlayervalues ( matches[i][1] , isComplete );

        table.insert ( listOfGuildies , { matches[i][1] , joinDate , promoDate , mainStatus , classColors , birthDate } );
    end

    sort ( listOfGuildies , function ( a , b ) return a[1] < b[1] end );

    return listOfGuildies
end

-- Method:          GRM.SetAuditValues ( int , int )
-- What it Does:    Builds the values of the given line in the audit window
-- Purpose:         Quality of life feature.
GRM.SetAuditValues = function ( ind , ind2 )
    local line = GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_AuditScrollChildFrame.AllAuditButtons[ind];
    local ok = { 0 , 0.77 , 0.063 };
    local notOk = { 0.64 , 0.102 , 0.102 };
    local unknown = { 1.0 , 0.647 , 0 };
    local color = {};

    local getColor = function ( text )
        local result = {};
        if text == GRM.L ( "No Date Set" ) or text == GRM.L ( "Main or Alt?" ) then
            result = notOk;
        elseif text == GRM.L ( "Unknown" ) then
            result = unknown;
        else
            result = ok;
        end
        return result;
    end

    -- Player Name
    line[2]:SetText ( GRM_G.AuditEntries[ind2][1] );
    line[2]:SetTextColor ( GRM_G.AuditEntries[ind2][5][1] , GRM_G.AuditEntries[ind2][5][2] , GRM_G.AuditEntries[ind2][5][3] , 1 );

    -- Join Date
    line[3]:SetText ( GRM_G.AuditEntries[ind2][2] );
    color = getColor ( GRM_G.AuditEntries[ind2][2] );
    line[3]:SetTextColor ( color[1] , color[2] , color[3] );

    -- Promotion Date
    line[4]:SetText ( GRM_G.AuditEntries[ind2][3] );
    color = getColor ( GRM_G.AuditEntries[ind2][3] );
    line[4]:SetTextColor ( color[1] , color[2] , color[3] );

    -- Birthdate
    line[5]:SetText ( GRM_G.AuditEntries[ind2][6] );
    color = getColor ( GRM_G.AuditEntries[ind2][6] );
    line[5]:SetTextColor ( color[1] , color[2] , color[3] );

    -- Main/Alt Status
    line[6]:SetText ( GRM_G.AuditEntries[ind2][4] );
    color = getColor ( GRM_G.AuditEntries[ind2][4] );
    line[6]:SetTextColor ( color[1] , color[2] , color[3] );

    -- Update the tooltip if underlying data changes
    if GameTooltip:IsVisible() and GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_AuditScrollChildFrame.AllAuditButtons[ind][1]:IsMouseOver() then 
        GRM.UpdateAuditTooltip ( ind );
    end
end

-- Method:          GRM.AuditHybridShiftDown()
-- What it Does:    Shifts all the values DOWN one line to give the illusion of scrolling when in reality this is just a hybrid scrollframe
-- Purpose:         Clean scrolling
GRM.AuditHybridShiftDown = function()
    if #GRM_G.AuditEntries > 16 then
        local buttons = GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_AuditScrollChildFrame.AllAuditButtons;
        local MouseOverButton = 0;

        -- Shift them down...
        for i = 1 , #buttons - 1 do

            -- Header Line
            buttons[i][2]:SetText( buttons[i+1][2]:GetText() );
            buttons[i][2]:SetTextColor ( buttons[i+1][2]:GetTextColor ( buttons[i+1][2]:GetText() ) );
            buttons[i][3]:SetText( buttons[i+1][3]:GetText() );
            buttons[i][3]:SetTextColor ( buttons[i+1][3]:GetTextColor ( buttons[i+1][3]:GetText() ) );
            buttons[i][4]:SetText( buttons[i+1][4]:GetText() );
            buttons[i][4]:SetTextColor ( buttons[i+1][4]:GetTextColor ( buttons[i+1][4]:GetText() ) );
            buttons[i][5]:SetText( buttons[i+1][5]:GetText() );
            buttons[i][5]:SetTextColor ( buttons[i+1][5]:GetTextColor ( buttons[i+1][5]:GetText() ) );
            buttons[i][6]:SetText( buttons[i+1][6]:GetText() );
            buttons[i][6]:SetTextColor ( buttons[i+1][6]:GetTextColor ( buttons[i+1][6]:GetText() ) );

            if MouseOverButton == 0 and buttons[i][1]:IsMouseOver() then
                MouseOverButton = i;
            end
        end

        GRM.AuditSetLastValue();
        if MouseOverButton > 0 then
            GRM.UpdateAuditTooltip ( MouseOverButton );
        end
    end
end

-- Method:          GRM.AuditHybridShiftUp()
-- What it Does:    Shifts all the values up one line to give the illusion of scrolling when in reality this is just a hybrid scrollframe
-- Purpose:         Clean scrolling
GRM.AuditHybridShiftUp = function()
    if #GRM_G.AuditEntries > 16 then
        local buttons = GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_AuditScrollChildFrame.AllAuditButtons;
        local MouseOverButton = 0;

        for i = #buttons , 2 , -1 do

            buttons[i][2]:SetText( buttons[i-1][2]:GetText() );
            buttons[i][2]:SetTextColor ( buttons[i-1][2]:GetTextColor ( buttons[i-1][2]:GetText() ) );
            buttons[i][3]:SetText( buttons[i-1][3]:GetText() );
            buttons[i][3]:SetTextColor ( buttons[i-1][3]:GetTextColor ( buttons[i-1][3]:GetText() ) );
            buttons[i][4]:SetText( buttons[i-1][4]:GetText() );
            buttons[i][4]:SetTextColor ( buttons[i-1][4]:GetTextColor ( buttons[i-1][4]:GetText() ) );
            buttons[i][5]:SetText( buttons[i-1][5]:GetText() );
            buttons[i][5]:SetTextColor ( buttons[i-1][5]:GetTextColor ( buttons[i-1][5]:GetText() ) );
            buttons[i][6]:SetText( buttons[i-1][6]:GetText() );
            buttons[i][6]:SetTextColor ( buttons[i-1][6]:GetTextColor ( buttons[i-1][6]:GetText() ) );

            if MouseOverButton == 0 and buttons[i][1]:IsMouseOver() then
                MouseOverButton = i;
            end
        end

        GRM.AuditSetFirstValue();
        if MouseOverButton > 0 then
            GRM.UpdateAuditTooltip ( MouseOverButton );
        end
    end
end

-- Method:          GRM.AuditSetLastValue()
-- What it Does:    Sets the last value of the hybridscrollframe backups at position 16
-- Purpose:         Clean scrolling
GRM.AuditSetLastValue = function()
    GRM.SetAuditValues ( #GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_AuditScrollChildFrame.AllAuditButtons , GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_AuditScrollChildFrame.Offset );
end

-- Method:          GRM.AuditSetFirstValue()
-- What it Does:    Sets the first value of the hybridscrollframe backups at position 1
-- Purpose:         Clean scrolling
GRM.AuditSetFirstValue = function()
    GRM.SetAuditValues ( 1 , GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_AuditScrollChildFrame.Offset - #GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_AuditScrollChildFrame.AllAuditButtons + 1 );
end

-- Method:          GRM.UpdateAuditTooltip()
-- What it Does:    Sets the tooltip for the audit window
-- Purpose:         Make it clear the QoL controls.
GRM.UpdateAuditTooltip = function ( ind )
    GRM_UI.SetTooltipScale();
    GameTooltip:SetOwner ( GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_AuditScrollChildFrame.AllAuditButtons[ind][1] , "ANCHOR_CURSOR" );
    GameTooltip:AddLine ( GRM.GetClassifiedName ( GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_AuditScrollChildFrame.AllAuditButtons[ind][2]:GetText() , false ) );

    GameTooltip:AddLine ( GRM.L ( "{custom1} to open Player Window" , nil , nil , nil , "|CFFE6CC7F" .. GRM.L ( "Ctrl-Click" ) .. "|r" ) );
    GameTooltip:AddLine( GRM.L ( "{custom1} to Search the Log for Player" , nil , nil , nil , "|CFFE6CC7F" .. GRM.L ( "Ctrl-Shift-Click" ) .. "|r" ) );
    GameTooltip:AddLine ( GRM.L ( "{custom1} for Additional Options" , nil , nil , nil , "|CFFE6CC7F" .. GRM.L ( "Right-Click" ) .. "|r" ) );

    -- Check for the tag
    if string.find ( GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_AuditScrollChildFrame.AllAuditButtons[ind][3]:GetText() , "!!" , 1 , true ) ~= nil or
        string.find ( GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_AuditScrollChildFrame.AllAuditButtons[ind][4]:GetText() , "!!" , 1 , true ) ~= nil then
        GameTooltip:AddLine ( " " );
        GameTooltip:AddLine ( GRM.L ( "The {name} tag indicates a date must be verified to sync" , "|CFFFF0000!!|r" ) );
        GameTooltip:AddLine ( GRM.L ( "To confirm or edit the date, open the player window, right click the date, edit, and submit" ) );
    end
    GameTooltip:Show();
end

-- Method:          GRM.TriggerRefreshAuditReset()
-- What it Does:    Refreshes the audit frames after hiding the tooltip
-- Purpose:         Prevent code bloat for something with repeated use.
GRM.TriggerRefreshAuditReset = function()
    GRM.RestoreTooltip()
    GRM.RefreshAuditFrames ( true , true );
end

-- Method:          GRM.RefreshAuditFrames( bool , bool )
-- What it Does:    Updates the audit frames when called
-- Purpose:         Audit frames are useful so the leader or player can do an easy visual check of the entire guild on what is needed.
GRM.RefreshAuditFrames = function ( showAll , fullRefresh , searchString )
    local hybridScrollFrameButtonCount = 17;
    local buttonHeight = GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_AuditScrollFrame:GetHeight() / 17;
    local scrollHeight = 0;
    local buttonWidth = GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_AuditScrollFrame:GetWidth() - 5;

    if showAll and fullRefresh then
        GRM_G.AuditEntries = GRM.GetAuditEntries();
        GRM_G.AuditEntryTotals = GRM.GetIncompleteGuildDataCounts();
        -- numBdayUnknown , numBdayNoDate

        -- Only show the "complete" guildies in the list.
        if GRM.S().onlyShowIncomplete then
            local isFound;
            for i = #GRM_G.AuditEntries , 1 , -1 do
                isFound = false;
                for j = 1 , #GRM_G.AuditEntryTotals[6] do
                    if GRM_G.AuditEntryTotals[6][j] == GRM_G.AuditEntries[i][1] then
                        isFound = true;
                        break;
                    end
                end
                if not isFound then
                    table.remove ( GRM_G.AuditEntries , i );
                end
            end
        end
    elseif not showAll then
        GRM_G.AuditEntries = GRM.GetAutoCompleteNamesForAudit ( searchString );
    end

    GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_AuditScrollChildFrame.AllAuditButtons = GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_AuditScrollChildFrame.AllAuditButtons or {};
    GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_AuditScrollChildFrame.Offset = GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_AuditScrollChildFrame.Offset or ( hybridScrollFrameButtonCount );

    if GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_AuditScrollChildFrame.Offset < hybridScrollFrameButtonCount then
        GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_AuditScrollChildFrame.Offset = hybridScrollFrameButtonCount;
    elseif GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_AuditScrollChildFrame.Offset > hybridScrollFrameButtonCount and GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_AuditScrollChildFrame.Offset > #GRM_G.AuditEntries then
        GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_AuditScrollChildFrame.Offset = #GRM_G.AuditEntries;
    end

    for i = 1 , #GRM_G.AuditEntries do
        -- Build HybridScrollFrame Buttons
        if i <= hybridScrollFrameButtonCount then
            if not GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_AuditScrollChildFrame.AllAuditButtons[i] then

                local button = CreateFrame ( "Button" , "GRMAuditCoreButton_" .. i , GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_AuditScrollChildFrame );
                GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_AuditScrollChildFrame.AllAuditButtons[i] = {
                    button ,
                    button:CreateFontString ( nil , "OVERLAY" , "GameFontWhiteTiny" ) ,
                    button:CreateFontString ( nil , "OVERLAY" , "GameFontWhiteTiny" ) ,
                    button:CreateFontString ( nil , "OVERLAY" , "GameFontWhiteTiny" ) ,
                    button:CreateFontString ( nil , "OVERLAY" , "GameFontWhiteTiny" ) ,
                    button:CreateFontString ( nil , "OVERLAY" , "GameFontWhiteTiny" ) ,
                };

                button = GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_AuditScrollChildFrame.AllAuditButtons[i][1];
                if i == 1 then
                    button:SetPoint ( "TOP" , GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_AuditScrollChildFrame , "TOP" , 0 , 0 );
                else 
                    button:SetPoint ( "TOPLEFT" , GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_AuditScrollChildFrame.AllAuditButtons[i-1][1] , "BOTTOMLEFT" , 0 , 0 );
                end

                button:SetHighlightTexture ( "Interface\\Buttons\\UI-Panel-Button-Highlight" );
                button:SetSize ( buttonWidth , buttonHeight );
                GRM.BuildAuditScrollButtons ( i );
                
            end
        end

        if i >= ( GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_AuditScrollChildFrame.Offset - hybridScrollFrameButtonCount + 1 ) and i <= GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_AuditScrollChildFrame.Offset then
            GRM.SetAuditValues ( i - ( GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_AuditScrollChildFrame.Offset - hybridScrollFrameButtonCount ) , i );
            GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_AuditScrollChildFrame.AllAuditButtons[i - ( GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_AuditScrollChildFrame.Offset - hybridScrollFrameButtonCount )][1]:Show();
        end
        
        -- Slider Height is controlled by tallying how many of these are necessary
        scrollHeight = scrollHeight + buttonHeight;
    end

    -- Hide unused buttons...
    for i = #GRM_G.AuditEntries + 1 , #GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_AuditScrollChildFrame.AllAuditButtons do
        GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_AuditScrollChildFrame.AllAuditButtons[i][1]:Hide();
    end

    GRM.SetHybridScrollFrameSliderParameters ( 
        GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_AuditScrollChildFrame , GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_AuditScrollFrame , GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_AuditScrollFrameSlider, 
        buttonWidth , buttonHeight , scrollHeight , #GRM_G.AuditEntries , GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_AuditScrollChildFrame.AllAuditButtons , 
        GRM.AuditHybridShiftDown , GRM.AuditHybridShiftUp , hybridScrollFrameButtonCount
    );

    GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_AuditFrameText5:SetText ( GRM.L ( "Total Incomplete: {num} / {custom1}" , nil , nil , GRM_G.AuditEntryTotals[5] , GRM.GetNumGuildies() ) );
    GRM_UI.ScaleFontStringToObjectSize ( true , 190 , GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_AuditFrameText5 , 2 );
    GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_AuditFrameText5:Show();
    GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_AuditFrameText8:SetText ( GRM.L ( "Mains:\n{num}" , nil , nil , GRM.GetNumMains() ) );
    GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_AuditFrameText8:Show();
    GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_AuditFrameText7:SetText ( GRM.L ( "Unique Accounts:\n{num}" , nil , nil , GRM_G.numAccounts ) );
    GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_AuditFrameText7:Show();
    if ( GRM_G.AuditEntryTotals[1] + GRM_G.AuditEntryTotals[2] ) == 0 then
        GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_SetJoinUnkownButton.GRM_SetJoinUnkownButtonText:SetText ( GRM.L ( "All Complete" ) );
    elseif GRM_G.AuditEntryTotals[2] > 0 then
        GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_SetJoinUnkownButton.GRM_SetJoinUnkownButtonText:SetText ( GRM.L ( "Set Incomplete to Unknown" ) );
    else
        GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_SetJoinUnkownButton.GRM_SetJoinUnkownButtonText:SetText ( GRM.L ( "Clear All Unknown" ) );
    end

    if ( GRM_G.AuditEntryTotals[3] + GRM_G.AuditEntryTotals[4] ) == 0 then
        GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_SetPromoUnkownButton.GRM_SetPromoUnkownButtonText:SetText ( GRM.L ( "All Complete" ) );
    elseif GRM_G.AuditEntryTotals[4] > 0 then
        GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_SetPromoUnkownButton.GRM_SetPromoUnkownButtonText:SetText ( GRM.L ( "Set Incomplete to Unknown" ) );
    else
        GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_SetPromoUnkownButton.GRM_SetPromoUnkownButtonText:SetText ( GRM.L ( "Clear All Unknown" ) );
    end

    if ( GRM_G.AuditEntryTotals[7] + GRM_G.AuditEntryTotals[8] ) == 0 then
        GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_SetBdayUnkownButton.GRM_SetBdayUnkownButtonText:SetText ( GRM.L ( "All Complete" ) );
    elseif GRM_G.AuditEntryTotals[8] > 0 then
        GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_SetBdayUnkownButton.GRM_SetBdayUnkownButtonText:SetText ( GRM.L ( "Set Incomplete to Unknown" ) );
    else
        GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_SetBdayUnkownButton.GRM_SetBdayUnkownButtonText:SetText ( GRM.L ( "Clear All Unknown" ) );
    end

    if GRM.S().includeBirthdaysInAudit then
        GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_AuditBirthdayToggleButton:SetChecked ( true );
    end

    if GRM.GetNumUnverifiedJoinDates() > 0 and GRM.CanEditOfficerNote() then
        GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_VerifyAllJoinButton:Show();
    else
        GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_VerifyAllJoinButton:Hide();
    end

    if GRM.GetNumUnverifiedPromoDates() > 0 and GRM.CanEditOfficerNote() then
        GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_VerifyAllRankButton:Show();
    else
        GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_VerifyAllRankButton:Hide();
    end

    GRM_UI.RefreshAuditTab ( GRM_UI.GRM_RosterChangeLogFrame.GRM_GuildAuditTab );
end

-- Method:          GRM.UnlockAuditButtonHighlights ( object )
-- What it Does:    Unlocks all button highlights not clicked
-- Purpose:         UX
GRM.UnlockAuditButtonHighlights = function()
    for i = 1 , #GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_AuditScrollChildFrame.AllAuditButtons do
        GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_AuditScrollChildFrame.AllAuditButtons[i][1]:UnlockHighlight();
    end
end

-- Method:          GRM.BuildAuditScrollButtons ( int )
-- What it Does:    Initiates the buttons and their values for each line of the audit hybridscrollframe
-- Purpose:         Create a smooth scrolling experience in the audit window
GRM.BuildAuditScrollButtons = function ( ind , isResizeAction )
    local coreButton = GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_AuditScrollChildFrame.AllAuditButtons[ind][1];
    local buttonText1 = GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_AuditScrollChildFrame.AllAuditButtons[ind][2];
    local buttonText2 = GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_AuditScrollChildFrame.AllAuditButtons[ind][3];
    local buttonText3 = GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_AuditScrollChildFrame.AllAuditButtons[ind][4];
    local buttonText4 = GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_AuditScrollChildFrame.AllAuditButtons[ind][5];
    local buttonText5 = GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_AuditScrollChildFrame.AllAuditButtons[ind][6];

    -- 566 width

    -- Name
    buttonText1:SetPoint ( "LEFT" , coreButton , "LEFT" , 5 , 0 );
    buttonText1:SetFont ( GRM_G.FontChoice , GRM_G.FontModifier + 11 );
    buttonText1:SetJustifyH ( "LEFT" );
    buttonText1:SetWidth ( 142 )
    buttonText1:SetWordWrap ( false );

     -- Join Date
     buttonText2:SetPoint ( "LEFT" , buttonText1 , "RIGHT" , 0 , 0 );
     buttonText2:SetFont ( GRM_G.FontChoice , GRM_G.FontModifier + 11 );
     buttonText2:SetWidth ( 105 );
     buttonText2:SetJustifyH ( "CENTER" );
     buttonText2:SetWordWrap ( false );
     
      -- Promo Date
    buttonText3:SetPoint ( "LEFT" , buttonText2 , "RIGHT" , 0 , 0 );
    buttonText3:SetFont ( GRM_G.FontChoice , GRM_G.FontModifier + 11 );
    buttonText3:SetWidth ( 105 );
    buttonText3:SetJustifyH ( "CENTER" );
    buttonText3:SetWordWrap ( false );

    -- Birthday
    buttonText4:SetPoint ( "LEFT" , buttonText3 , "RIGHT" , 0 , 0 );
    buttonText4:SetFont ( GRM_G.FontChoice , GRM_G.FontModifier + 11 );
    buttonText4:SetWidth ( 105 );
    buttonText4:SetJustifyH ( "CENTER" );
    buttonText4:SetWordWrap ( false );

    -- Main/Alt
    buttonText5:SetPoint ( "LEFT" , buttonText4 , "RIGHT" , -10 , 0 );
    buttonText5:SetFont ( GRM_G.FontChoice , GRM_G.FontModifier + 11 );
    buttonText5:SetWidth ( 105 );
    buttonText5:SetJustifyH ( "CENTER" );
    buttonText5:SetWordWrap ( false );

    if not isResizeAction then

        coreButton:EnableMouse ( true );
        coreButton:RegisterForDrag ( "LeftButton" );

        -- Setup draggable conditions
        coreButton:SetScript ( "OnDragStart" , function()
            GRM_UI.GRM_RosterChangeLogFrame:StartMoving();
        end);
        coreButton:SetScript ( "OnDragStop" , function()
            GRM_UI.GRM_RosterChangeLogFrame:StopMovingOrSizing();
            GRM_UI.SaveCorePosition();
        end);

        coreButton:SetScript ( "OnMouseDown" , function ( self , button )
            local playerName = GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_AuditScrollChildFrame.AllAuditButtons[ind][2]:GetText();

            if button == "LeftButton" then
                if IsControlKeyDown() then
                    if IsShiftKeyDown() then
                        GRM.RestoreTooltip();
                        GRM_UI.GRM_RosterChangeLogFrame.GRM_LogTab:Click();
                        GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_LogEditBox:SetText( GRM.SlimName ( playerName ) );
                    else
                        GRM.OpenPlayerWindow( playerName );        
                    end
                end

            elseif button == "RightButton" then
                GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_AuditWindowDropDownFrame.name = playerName;
                GRM.RestoreTooltip();

                local buttonMsg = "";

                local player = GRM.GetPlayer ( playerName );
                if player then
                    if not player.isMain then
                        buttonMsg = GRM.L ( "Set as Main" );
                    else
                        buttonMsg = GRM.L ( "Set as Alt" );
                    end
                end

                GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_AuditWindowDropDownFrame.GRM_AuditWindowDropDownFrameText:SetText ( GRM.GetClassifiedName ( playerName , false ) );
                GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_AuditWindowDropDownFrame.GRM_AuditWindowDropDownAltMainButton.GRM_AuditWindowDropDownAltMainButtonText:SetText ( buttonMsg );
                local size = GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_AuditWindowDropDownFrame.GRM_AuditWindowDropDownFrameText:GetWidth() + 25;

                if size < 110 then
                    size = 110;
                end

                GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_AuditWindowDropDownFrame:SetWidth ( size );
                GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_AuditWindowDropDownFrame:ClearAllPoints();
                GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_AuditWindowDropDownFrame:SetPoint ( "LEFT" , self , "RIGHT" , -15 , 0 );

                size = GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_AuditWindowDropDownFrame:GetWidth();
                GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_AuditWindowDropDownFrame.GRM_AuditWindowDropDownAltMainButton:SetWidth( GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_AuditWindowDropDownFrame:GetWidth() - 15 );
                GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_AuditWindowDropDownFrame.GRM_AuditWindowDropDownCancelButton:SetWidth ( size - 5 );
                GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_AuditWindowDropDownFrame:Show();

                GRM.UnlockAuditButtonHighlights();
                self:LockHighlight();
                GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_AuditWindowDropDownFrame:SetScript ( "OnHide" , function()
                    self:UnlockHighlight();
                end);
                
            end
        end);            

        coreButton:SetScript ( "OnEnter" , function ()
            GRM.UpdateAuditTooltip( ind );
        end);

        coreButton:SetScript ( "OnLeave" , function()
            GRM.RestoreTooltip();
        end);
    end
end

-- Method:          GRM.GetIncompleteGuildDataCounts()
-- What it Does:    Scans over the guild for audit and retrieves the data on what is and is not missing. This is to be used for audit reporting
-- Purpose:         For player info and better control over their guild's data completeness...
GRM.GetIncompleteGuildDataCounts = function()
    local numJoinUnknown = 0;
    local numJoinNoDate = 0;
    local numPromoUnknown = 0;
    local numPromoNoDate = 0;
    local numBdayNoDate , numBdayUnknown = 0 , 0;
    local count2 = 0;                   -- This is the overall count of how many "incomplete"
    local isComplete = true;
    local listOfIncompleteNames = {};

    for _ , player in pairs ( GRM.GetGuild() ) do
        if type ( player ) == "table" then
            isComplete = true;

            if not player.joinDateHist[1][6] then
                if player.joinDateUnknown then
                    numJoinUnknown = numJoinUnknown + 1;
                    if GRM.S().unknownIsComplete then
                        isComplete = false;
                    end
                else
                    numJoinNoDate = numJoinNoDate + 1;
                    isComplete = false;
                end
            end

            -- Promo Date
            if not player.rankHist[1][7] then
                if player.promoteDateUnknown then
                    numPromoUnknown = numPromoUnknown + 1;
                    if GRM.S().unknownIsComplete then
                        isComplete = false;
                    end
                else
                    numPromoNoDate = numPromoNoDate + 1;
                    isComplete = false;
                end
            end

            -- Birthdays
            if player.events[2][1][1] == 0 then
                if player.birthdayUnknown then
                    numBdayUnknown = numBdayUnknown + 1;
                    if GRM.S().unknownIsComplete and GRM.S().includeBirthdaysInAudit then
                        isComplete = false;
                    end
                else
                    numBdayNoDate = numBdayNoDate + 1;
                    if GRM.S().includeBirthdaysInAudit then
                        isComplete = false;
                    end
                end
            end

            if ( not player.isMain and player.altGroup == "" ) or ( player.altGroup ~= "" and GRM_Alts[GRM_G.guildName][player.altGroup].main == "" ) then
                isComplete = false;
            end

            if not isComplete or not GRM.S().onlyShowIncomplete then
                if not isComplete then
                    count2 = count2 + 1;
                    table.insert ( listOfIncompleteNames , player.name );
                end
            end
        end
    end
    return { numJoinUnknown , numJoinNoDate , numPromoUnknown , numPromoNoDate , count2 , listOfIncompleteNames , numBdayUnknown , numBdayNoDate };
end

-- Method:          RefreshAddonUserFrames()
-- What it Does:    It Initializes and rebuilds the frames to see who you are syncing with in the guild and if not, why not.
-- Purpose:         Purely quality of life information.
GRM.RefreshAddonUserFrames = function()
    -- To prevent double spam...
    GRM_UI.GRM_RosterChangeLogFrame.GRM_AddonUsersFrame.Timer = 0;

    -- Notification that player has sync disabled themselves.
    if GRM.S().syncEnabled then
        GRM_UI.GRM_RosterChangeLogFrame.GRM_AddonUsersFrame.GRM_AddonUsersSyncEnabledText:Hide();
    else
        GRM_UI.GRM_RosterChangeLogFrame.GRM_AddonUsersFrame.GRM_AddonUsersSyncEnabledText:Show();
    end

    -- Now, let's load and refresh the data!
    GRM.RegisterGuildAddonUsersRefresh ();
    GRM.BuildAddonUserScrollFrame();
end

-- Method:          GRM.RefreshAddEventFrame();
-- What it Does:    Refreshes the details, in case an event happes WHILE the window is open
-- Purpose:         QOL - Clean user experience. User it not forced to close window and reopen it to trigger updates. This will be used on the fly.
GRM.RefreshAddEventFrame = function()

    GRM.CleanupEventsFromplayers(); -- This is in case someone has left the guild right before eventFrame is refreshed

    -- Clear the buttons first
    if GRM_UI.GRM_RosterChangeLogFrame.GRM_EventsFrame.GRM_AddEventScrollChildFrame.allFrameButtons ~= nil then
        for i = 1 , #GRM_UI.GRM_RosterChangeLogFrame.GRM_EventsFrame.GRM_AddEventScrollChildFrame.allFrameButtons do
            GRM_UI.GRM_RosterChangeLogFrame.GRM_EventsFrame.GRM_AddEventScrollChildFrame.allFrameButtons[i][1]:Hide();
            GRM_UI.GRM_RosterChangeLogFrame.GRM_EventsFrame.GRM_AddEventScrollChildFrame.allFrameButtons[i][1]:UnlockHighlight();
        end
    end
    -- Status Notification logic
    -- remember, position 1 is the guild name, so players start at index 2
    if #GRM.GetEvents() > 0 then
        GRM_UI.GRM_RosterChangeLogFrame.GRM_EventsFrame.GRM_EventsFrameStatusMessageText:SetText ( GRM.L ( "Please Select Event to Add to Calendar" ) );
        GRM_UI.GRM_RosterChangeLogFrame.GRM_EventsFrame.GRM_EventsFrameStatusMessageText:Show();
        GRM_UI.GRM_RosterChangeLogFrame.GRM_EventsFrame.GRM_EventsFrameNameToAddText:Hide();
        GRM_UI.GRM_RosterChangeLogFrame.GRM_EventsFrame.GRM_EventsFrameNameDateText:Hide();
    else
        GRM_UI.GRM_RosterChangeLogFrame.GRM_EventsFrame.GRM_EventsFrameStatusMessageText:SetText ( GRM.L ( "No Calendar Events to Add" ) );
        GRM_UI.GRM_RosterChangeLogFrame.GRM_EventsFrame.GRM_EventsFrameStatusMessageText:Show();
        GRM_UI.GRM_RosterChangeLogFrame.GRM_EventsFrame.GRM_EventsFrameNameToAddText:Hide();
        GRM_UI.GRM_RosterChangeLogFrame.GRM_EventsFrame.GRM_EventsFrameNameDateText:Hide();
    end

    if GRM_G.BuildVersion >= 30000 and CanEditGuildEvent() then
        if not GRM.S().allowEventsToCalendar then
            GRM_UI.GRM_RosterChangeLogFrame.GRM_EventsFrame.GRM_EventsFrameStatusMessageText2:SetText ( GRM.L ( "You Currently Have Disabled Adding Events to Calendar" ) );
            GRM_UI.GRM_RosterChangeLogFrame.GRM_EventsFrame.GRM_EventsFrameStatusMessageText2:Show();
        else
            GRM_UI.GRM_RosterChangeLogFrame.GRM_EventsFrame.GRM_EventsFrameStatusMessageText2:Hide();
        end
    else
        if GRM_G.BuildVersion >= 30000 then
            GRM_UI.GRM_RosterChangeLogFrame.GRM_EventsFrame.GRM_EventsFrameStatusMessageText2:SetText ( GRM.L ( "You Do Not Have Permission to Add Events to Calendar" ) );
        else
            GRM_UI.GRM_RosterChangeLogFrame.GRM_EventsFrame.GRM_EventsFrameStatusMessageText2:SetText ( GRM.L ( "Limited Features. There is no Calendar in Classic" ) );
        end
        GRM_UI.GRM_RosterChangeLogFrame.GRM_EventsFrame.GRM_EventsFrameStatusMessageText2:Show();
    end
    -- Ok Building Frame!
    GRM.BuildEventCalendarManagerScrollFrame();
end

-------------------------------
----- BUILD LOG STRINGS -------
-------------------------------

-- Let's create a parsing tool

-- Method:          GRM.Next ( string )
-- What it Does:    Parses a string and goes to the next parsing input
-- Purpose:         For sync purposes
GRM.Next = function ( msg )
    return string.match ( msg , "?(.+)" );
end

-- Method:          GRM.NoteFormatParsingProtection ( string )
-- What it Does:    Changes any "%" to be "%%" before passing through strings in custom notes as the % is a regex indicator of an escape capture index. So, if a player has % in their note it will disappear, If it has %% it will show. It also will convert any URL code to the char, like the %20 = a space.
-- Purpose:         Prevent any conflicts on player's own note, officer note, custom note.
GRM.NoteFormatParsingProtection = function ( note )

    local function urlCodeToChar ( x )
        return string.char ( tonumber ( x , 16 ) );
    end
    return string.gsub ( string.gsub ( note , "%%(%x%x)" , urlCodeToChar ) , "%%" , "%%%%" );

end

-- Method:          GRM.GetPromotionLogString ( bool , string , string , string , string , array )
-- What it Does:    Builds the string on the fly of when someone is promoted in the guild for the log
-- Purpose:         Ease of reusing this code and ease of reading it.
GRM.GetPromotionLogString = function ( foundInLog , player1 , player2 , initRank , finRank , date )
    local result = "";

    if foundInLog and ( initRank ~= finRank ) then
        result = GRM.L ( "{name} PROMOTED {name2} from {custom1} to {custom2}" , player1 , player2 , nil , initRank , finRank );
    else
        if initRank == finRank then

            for i = 1 ,  GuildControlGetNumRanks() do
                if GuildControlGetRankName ( i ) == initRank then
                    finRank = finRank .. " (" .. ( tostring ( i ) ) .. ")"   -- new rank index
                    initRank = initRank .. " (" .. ( tostring ( i + 1 ) ) .. ")"; -- Old rank index
                    break;
                end
            end
        end

        result = GRM.L ( "{name} has been PROMOTED from {custom1} to {custom2}" , player2 , nil , nil , initRank , finRank );
    end

    return GRM.GetLogFormattedTimestamp ( date , result ) , result;
end

-- Method:          GRM.GetDemotionLogString ( bool , string , string , string , string , array )
-- What it Does:    Builds the string on the fly of when someone is demoted in the guild for the log
-- Purpose:         Ease of reusing this code and ease of reading it.
GRM.GetDemotionLogString = function ( foundInLog , player1 , player2 , initRank , finRank , date )
    local result = "";

    if foundInLog then
        result = GRM.L ( "{name} DEMOTED {name2} from {custom1} to {custom2}" , player1 , player2 , nil , initRank , finRank );
    else
        result = GRM.L ( "{name} has been DEMOTED from {custom1} to {custom2}" , player2 , nil , nil , initRank , finRank );
    end

    return GRM.GetLogFormattedTimestamp ( date , result ) , result;
end

-- Method:          GRM.GetLeveledString ( string , int , int , int , array )
-- What it Does:    Builds the string on the fly of when someone has leveled and reached configured milestones.
-- Purpose:         Ease of reusing this code and ease of reading it.
GRM.GetLeveledString = function ( simpleName , milestoneLevel , level , numGained , date , atLevelCap , fullName )
    local result = "";

    if GRM.S().useMainTag and fullName then
        local player = GRM.GetPlayer ( fullName );

        if player then

            local mainDisplay = GRM.GetMainTags ( false , GRM.S().mainTagIndex );
            if player.isMain then
                simpleName = simpleName .. " " .. GRM_G.MainTagHexCode .. mainDisplay .. "|r";
            else
                if GRM.PlayerHasAlts ( player ) and GRM_Alts[GRM_G.guildName][player.altGroup].main ~= "" then
                    simpleName = simpleName .. " " .. GRM_G.MainTagHexCode .. mainDisplay .. "|r (" .. GRM.GetStringClassColorByName ( GRM_Alts[GRM_G.guildName][player.altGroup].main ) .. GRM.SlimName ( GRM_Alts[GRM_G.guildName][player.altGroup].main ) .. "|r)";
                end
            end
        end
    end

    if milestoneLevel == 0 or atLevelCap then
        if atLevelCap then
            result = GRM.L ( "{name} has Reached the {num} Level Cap! {custom1}" , simpleName , nil , "|cffafffdc"  .. tostring ( level ).. "|r" , "|cffffd600***|r |cffafffdc" .. GRM.L ( "Hurray!" ) .. "|r|cffffd600***|r" );
        else
            result = GRM.L ( "{name} has Leveled to {num}" , simpleName , nil , level );
        end
    else
        if milestoneLevel ~= level then
            result = GRM.L ( "{name} has Surpassed their Level {num} Milestone and is Now {custom1}" , simpleName , nil , milestoneLevel , level );
        else
            result = GRM.L ( "{name} has Reached their Level {num} Milestone" , simpleName , nil , level );
        end
    end
    if numGained > 1 then
        result = result .. " " .. GRM.L ( "(+{num} levels)" , nil , nil , numGained );
    else
        result = result .. " " .. GRM.L ( "(+{num} level)" , nil , nil , numGained );
    end
    result = GRM.GetLogFormattedTimestamp ( date , result );

    return result;
end

-- Method:          GRM.GetNoteChangeString ( string , string , string , array )
-- What it Does:    Builds the string on the fly of when someone's public note has changed
-- Purpose:         Ease of reusing this code and ease of reading it.
GRM.GetNoteChangeString = function ( simpleName , oldNote , newNote , date )
    local result = "";

    oldNote = GRM.NoteFormatParsingProtection ( oldNote );
    newNote = GRM.NoteFormatParsingProtection ( newNote );

    if oldNote == "" then
        result = GRM.L ( "{name}'s PUBLIC Note: \"{custom1}\" was Added" , simpleName , nil , nil , newNote );
    elseif newNote == "" then
        result = GRM.L ( "{name}'s PUBLIC Note: \"{custom1}\" was Removed" , simpleName , nil , nil , oldNote );
    else
        result = GRM.L ( "{name}'s PUBLIC Note: \"{custom1}\" to \"{custom2}\"" , simpleName , nil , nil , oldNote , newNote );
    end
    
    return GRM.GetLogFormattedTimestamp ( date , result ) , result;
end

-- Method:          GRM.GetOfficerNoteChangeString ( string , string , string , array )
-- What it Does:    Builds the string on the fly of when someone's public note has changed
-- Purpose:         Ease of reusing this code and ease of reading it.
GRM.GetOfficerNoteChangeString = function ( simpleName , oldNote , newNote , date )
    local result = "";

    oldNote = GRM.NoteFormatParsingProtection ( oldNote );
    newNote = GRM.NoteFormatParsingProtection ( newNote );

    if oldNote == "" then
        result = GRM.L ( "{name}'s OFFICER Note: \"{custom1}\" was Added" , simpleName , nil , nil , newNote );
    elseif newNote == "" then
        result = GRM.L ( "{name}'s OFFICER Note: \"{custom1}\" was Removed" , simpleName , nil , nil , oldNote );
    else
        result = GRM.L ( "{name}'s OFFICER Note: \"{custom1}\" to \"{custom2}\"" , simpleName , nil , nil , oldNote , newNote );
    end
    return  GRM.GetLogFormattedTimestamp ( date , result ) , result;
end

-- Method:          GRM.GetRankRenamedString ( int , string , string , array )
-- What it Does:    Builds the string on the fly of when rank is changed or added or removed
-- Purpose:         Ease of reusing this code and ease of reading it.
GRM.GetRankRenamedString = function ( rankNum , oldRank , newRank , date )
    local result = "";

    if rankNum == nil then
        result = GRM.L ( "Guild Rank Renamed from {custom1} to {custom2}" , nil , nil , nil , oldRank , newRank );
    else
        if rankNum > 0 then
            if rankNum == 1 then
                result = GRM.L ( "A new rank has been added to the guild!" );
            else
                result = GRM.L ( "{num} new ranks have been added to the guild!" , nil , nil , rankNum );
            end
        else
            if rankNum == -1 then
                result = GRM.L ( "The guild has removed a rank!" );
            else
                result = GRM.L ( "{num} guild ranks have been removed!" , nil , nil , ( rankNum * -1 ) );
            end
        end
    end

    result = GRM.GetLogFormattedTimestamp ( date , result );

    return result;
end

-- Method:          GRM.GetInactiveReturnString ( string , int , array )
-- What it Does:    Builds the string for report on inactive player coming back online after absence.
-- Purpose:         Ease of reusing this code and ease of reading it.
GRM.GetInactiveReturnString = function ( simpleName , hoursReport , date )
    local result = "";

    result = GRM.L ( "{name} has Come ONLINE after being INACTIVE for {num}" , simpleName , nil , hoursReport );
    result = GRM.GetLogFormattedTimestamp ( date , result );

    return result;
end

-- Method:          GRM.GetRecommendKickString ( string , int , array , array )
-- What it Does:    Builds the string for report recommending a kick
-- Purpose:         Ease of reusing this code and ease of reading it.
GRM.GetRecommendKickString = function ( name , numRules , date , ruleNames )
    local result = "";

    -- Original formatting
    if type ( numRules ) == "string" then
        result = GRM.L ( "{name} has been OFFLINE for {num}. Kick Recommended!" , name , nil , numRules );
    else

        -- TOP line
        if numRules > 1 then
            result = GRM.L ( "{name} matches {num} macro tool rules. Kick Recommended!" , GRM.SlimName ( name ) , nil , numRules );
        else
            result = GRM.L ( "{name} matches {num} macro tool rule. Kick Recommended!" , GRM.SlimName ( name ) , nil , numRules );
        end

        if ruleNames then
            for i = 1 , #ruleNames do
                if GRM.S().kickRules[ruleNames[i]] and GRM.S().kickRules[ruleNames[i]].customLog and #GRM.S().kickRules[ruleNames[i]].customLogMsg > 0 then
                    result = result .. "\n|CFFFFFFFF\"" .. ruleNames[i] .. "\"|r - " .. GRM.S().kickRules[ruleNames[i]].customLogMsg;
                end
            end
        end
    end
    
    result = GRM.GetLogFormattedTimestamp ( date , result );

    return result;
end

-- Method:          GRM.GetPromotionRecommendString ( string , int , array , array )
-- What it Does:    Builds the string for report recommending a promotion
-- Purpose:         Ease of reusing this code and ease of reading it.
GRM.GetPromotionRecommendString = function ( name , numRules , date , ruleNames )
    local result = "";

     -- TOP line
     if numRules > 1 then
        result = GRM.L ( "{name} matches {num} macro tool rules. Promotion Recommended!" , GRM.SlimName ( name ) , nil , numRules );
    else
        result = GRM.L ( "{name} matches {num} macro tool rule. Promotion Recommended!" , GRM.SlimName ( name ) , nil , numRules );
    end

    if ruleNames then
        for i = 1 , #ruleNames do
            if GRM.S().promoteRules[ruleNames[i]] and GRM.S().promoteRules[ruleNames[i]].customLog and #GRM.S().promoteRules[ruleNames[i]].customLogMsg > 0 then
                result = result .. "\n|CFFFFFFFF\"" .. ruleNames[i] .. "\"|r - " .. GRM.S().promoteRules[ruleNames[i]].customLogMsg;
            end
        end
    end
    
    result = GRM.GetLogFormattedTimestamp ( date , result );

    return result;
end

-- Method:          GRM.GetDemotionRecommendString ( string , int , array , array )
-- What it Does:    Builds the string for report recommending a Demotion
-- Purpose:         Ease of reusing this code and ease of reading it.
GRM.GetDemotionRecommendString = function ( name , numRules , date , ruleNames )
    local result = "";

     -- TOP line
     if numRules > 1 then
        result = GRM.L ( "{name} matches {num} macro tool rules. Demotion Recommended!" , GRM.SlimName ( name ) , nil , numRules );
    else
        result = GRM.L ( "{name} matches {num} macro tool rule. Demotion Recommended!" , GRM.SlimName ( name ) , nil , numRules );
    end

    if ruleNames then
        for i = 1 , #ruleNames do
            if GRM.S().demoteRules[ruleNames[i]] and GRM.S().demoteRules[ruleNames[i]].customLog and #GRM.S().demoteRules[ruleNames[i]].customLogMsg > 0 then
                result = result .. "\n|CFFFFFFFF\"" .. ruleNames[i] .. "\"|r - " .. GRM.S().demoteRules[ruleNames[i]].customLogMsg;
            end
        end
    end
    
    result = GRM.GetLogFormattedTimestamp ( date , result );

    return result;
end

-- Method:          GRM.GetNameChangeString ( string , int , array )
-- What it Does:    Builds the string for report recommending a kick
-- Purpose:         Ease of reusing this code and ease of reading it.
GRM.GetNameChangeString = function ( simpleNewName , oldName , date )
    local result = "";

    result = GRM.L ( "{name} has Name-Changed to {name2}" , oldName , simpleNewName );
    result = GRM.GetLogFormattedTimestamp ( date , result );
    return result;
end

-- Method:          GRM.GetLeftOrKickString ( string , bool , string , array , array , string , string , string , array , bool , bool , string )
-- What it Does:    Builds the string for players left or kicked from guild
-- Purpose:         Ease of reusing this code and ease of reading it.
GRM.GetLeftOrKickString = function ( unitName , playerWasKicked , timePassed , logEntryMetaData , listOfAlts , mainName , publicNote , officerNote , date , isFoundInEventLog , isNoLongerOnServer , isLiveDetection , playerLevel , customNote )
    local result = "";
    local level = "";

    if playerLevel ~= nil and playerLevel > 0 then
        level = ( " " .. GRM.L ( "(LVL: {num})" , nil , nil , playerLevel ) );
    end

    if timePassed ~= "" then
        timePassed = ( "\n|cFFFFFFFF" .. GRM.L ( "Time as Member:" ) .. " " .. timePassed .. "|r" );
    end

    if not playerWasKicked then

        -- Found in log OR Live
        if logEntryMetaData[1] and logEntryMetaData[2] ~= nil and logEntryMetaData[3] == nil then
            result = GRM.L ( "{name} has Left the guild" , GRM.SlimName ( logEntryMetaData[2] ) .. "|r" ) .. level;

        elseif isFoundInEventLog and not isLiveDetection and GRM.SlimName ( unitName ) ~= "" then
            result = GRM.L ( "{name} has Left the guild" , GRM.SlimName ( unitName ) .. "|r" ) .. level;
            
        else
            result = GRM.L ( "{name} is no longer in the Guild!" , GRM.SlimName ( unitName ) .. "|r" ) .. level;
        end

    else
        -- Log Entry found OR live kick/leave detected and successfully parsed the message
        if logEntryMetaData[1] and logEntryMetaData[2] ~= nil and logEntryMetaData[3] ~= nil then
            result = GRM.L ( "{name} KICKED {name2} from the Guild!" , GRM.SlimName ( logEntryMetaData[2] ) , GRM.SlimName ( logEntryMetaData[3] ) .. "|r" ) .. level;
            
        else
            result = GRM.L ( "{name} is no longer in the Guild!" , GRM.SlimName ( unitName ) .. "|r" ) .. level;
        end
    end

    if isNoLongerOnServer then
        result = result .. " |CFFFF0000(" .. GRM.L ( "Player no longer on Server" ) .. ")|r";
    end

    for i = 1 , #listOfAlts do
        if i == 1 then
            result = result .. "\n|CFFFFFFFF" .. GRM.L ( "ALTS IN GUILD:" ) .. " " .. listOfAlts[i];
        else
            result = result .. GRM.L ( "," ) .. " " .. listOfAlts[i];
        end

        if i == 5 and i < #listOfAlts then
            result = result .. " |r|CFF7F7F7F" .. GRM.L ( "(+ {num} More)" , nil , nil , ( #listOfAlts - i ) .. "|r" );
            break;
        end
    end

    if mainName ~= "" and mainName ~= unitName then
        -- Ok, if they have no mainName, let's check the left player's list for matches..
        result = result .. "\n|CFFFFFFFF" .. GRM.L ( "Player's Main: {name}" , GRM.GetClassifiedName ( mainName , true ) .. "|r" );
    elseif mainName == unitName then

        local name = "";
        

        -- Found in log OR Live
        if logEntryMetaData[1] and logEntryMetaData[2] ~= nil and logEntryMetaData[3] == nil then
            name = GRM.SlimName ( logEntryMetaData[2] ) .. "|r";

        elseif isFoundInEventLog and not isLiveDetection and GRM.SlimName ( unitName ) ~= "" then
            name = GRM.SlimName ( unitName ) .. "|r";
            
        else
            name = GRM.SlimName ( unitName );
        end

        result = result .. "\n|CFFFFFFFF" .. GRM.L ( "{name} is listed as the Main" , name .. " " .. GRM_G.MainTagHexCode .. GRM.GetMainTags ( false , GRM.S().mainTagIndex ) .. "|r" );
    end

    if timePassed ~= "" then
        result = result .. timePassed;
    end

    if publicNote ~= "" then
        result = result .. "\n|CFFFFFFFF" .. GRM.L ( "Public Note:" ) .. " " .. publicNote .. "|r";
    end
    if officerNote ~= "" then
        result = result .. "\n|CFFFFFFFF" .. GRM.L ( "Officer Note:" ) .. " " .. officerNote .. "|r";
    end
    if customNote ~= nil and customNote ~= "" then
        result = result .. "\n|CFFFFFFFF" .. GRM.L ( "Custom Notes:" ) .. "\n" .. customNote .. "|r";
    end

    return GRM.GetLogFormattedTimestamp ( date , result ) , result;
end

-- Method:          GRM.GetCustomNoteChangeString ( string , string , string , array )
-- What it Does:    Builds the string on the fly of when someone's public note has changed
-- Purpose:         Ease of reusing this code and ease of reading it.
GRM.GetCustomNoteChangeString = function ( newNote , oldNote , editorName , editedName , date )
    local result = "";

    oldNote = GRM.NoteFormatParsingProtection ( oldNote );
    newNote = GRM.NoteFormatParsingProtection ( newNote );

    if oldNote == "" then
        result = GRM.L ( "{name} modified {name2}'s CUSTOM Note: \"{custom1}\" was Added" , GRM.GetClassifiedName ( editorName , true ) , GRM.GetClassifiedName ( editedName , true ) , nil , newNote );
    elseif newNote == "" then
        result = GRM.L ( "{name} modified {name2}'s CUSTOM Note: \"{custom1}\" was Removed" , GRM.GetClassifiedName ( editorName , true ) , GRM.GetClassifiedName ( editedName , true ) , nil , oldNote );
    else
        result = GRM.L ( "{name} modified {name2}'s CUSTOM Note: \"{custom1}\" to \"{custom2}\"" , GRM.GetClassifiedName ( editorName , true ) , GRM.GetClassifiedName ( editedName , true ) , nil , oldNote , newNote );
    end

    return GRM.GetLogFormattedTimestamp ( date , result ) , result;
end

-- Method:          GRM.GetGuildNameChangeString ( string , string , array )
-- What it Does:    Builds the string on the fly of when someone's public note has changed
-- Purpose:         Ease of reusing this code and ease of reading it.
GRM.GetGuildNameChangeString = function ( playerName , slimGuildName , date )
    local result = "";

    result = GRM.L ( "{name}'s Guild has Name-Changed to \"{name2}\"" , playerName , slimGuildName );

    return GRM.GetLogFormattedTimestamp ( date , result ) , result;
end

-- Method:          GRM.GetBanLogString ( bool , string , string , string ,  array )
-- What it Does:    Builds the string on the fly of when someone is promoted in the guild for the log
-- Purpose:         Ease of reusing this code and ease of reading it.
GRM.GetBanLogString = function ( banAlts , playerName , playerBannedName , reason , date )
    local result = "";

    if banAlts then
        result = GRM.L ( "{name} has BANNED {name2} and all linked alts from the guild!" , playerName , playerBannedName );
    else
        result = GRM.L ( "{name} has BANNED {name2} from the guild!" , playerName , playerBannedName );
    end

    if reason ~= "" then
        result = result .. ( "\n|CFFFFFFFF" .. GRM.L ( "Reason Banned:" ) .. " " .. reason );
    else
        result = result .. ( "\n|CFFFFFFFF" .. GRM.L ( "Reason Banned:" ) .. " " .. GRM.L ( "None Given" ) );
    end


    return GRM.GetLogFormattedTimestamp ( date , result ) , result;
end

-- (Log Index 20)
-- Method:          GRM.GetBanLogUpdateAndEditString ( bool , bool , string , string , string , array )
-- What it Does:    Builds the string on the fly of when someone is promoted in the guild for the log
-- Purpose:         Ease of reusing this code and ease of reading it.
GRM.GetBanLogUpdateAndEditString = function ( banAlts , isAnEdit , playerName , playerBannedName , reason , date )
    local result = "";

    if banAlts then
        if not isAnEdit then
            result = GRM.L ( "{name} has BANNED {name2} and all linked alts from the guild!" , playerName , playerBannedName );
        else
            result = GRM.L ( "{name} has Updated {name2}'s BAN and also BANNED all linked alts from the guild!" , playerName , playerBannedName );
        end
    else
        if not isAnEdit then
            result = GRM.L ( "{name} has BANNED {name2} from the guild!" , playerName , playerBannedName );
        else
            result = GRM.L ( "{name}'s Ban has been Updated by {name2}!" , playerBannedName , playerName );
        end
    end

    if reason ~= "" then
        result = result .. ( "\n|CFFFFFFFF" .. GRM.L ( "Reason Banned:" ) .. " " .. reason );
    else
        result = result .. ( "\n|CFFFFFFFF" .. GRM.L ( "Reason Banned:" ) .. " " .. GRM.L ( "None Given" ) );
    end

    return GRM.GetLogFormattedTimestamp ( date , result ) , result;
end

-- (Log Index 21)
-- Method:          GRM.GetUnBanString ( string , string , array )
-- What it Does:    Builds the string on the fly of when someone's public note has changed
-- Purpose:         Ease of reusing this code and ease of reading it.
GRM.GetUnBanString = function ( playerNameBanned , playerNameBanning , date )
    local result = "";
    result = GRM.L ( "{name} has Removed {name2} from the Ban List." , playerNameBanning , playerNameBanned );

    return GRM.GetLogFormattedTimestamp ( date , result ) , result;
end

-- (Log Index 22)
-- Method:          GRM.GetBanStatusSyncString ( string , bool , string , string , string , array )
-- What it Does:    Builds the string on the fly of when someone's public note has changed
-- Purpose:         Ease of reusing this code and ease of reading it.
GRM.GetBanStatusSyncString = function ( banStatus , isAnEdit , playerNameBanned , playerNameBanning , reason , date )
    local result = "";

    if banStatus == "ban" then
        if isAnEdit then
            result = GRM.L ( "{name}'s Ban has been Updated by {name2}!" , playerNameBanned , playerNameBanning );                           
        else
            result = GRM.L ( "{name} has been BANNED from the guild!" , playerNameBanned );
        end
        if reason ~= "" then
            result = result .. ( "\n|CFFFFFFFF" .. GRM.L ( "Reason Banned:" ) .. " " .. reason );
        else
            result = result .. ( "\n|CFFFFFFFF" .. GRM.L ( "Reason Banned:" ) .. " " .. GRM.L ( "None Given" ) );
        end
    else
        if playerNameBanning ~= "" then
            result = GRM.L ( "{name} has Removed {name2} from the Ban List." , playerNameBanning , playerNameBanned );
        else
            result = GRM.L ( "{name} has been UN-BANNED from the guild!" , playerNameBanned );
        end
    end

    return GRM.GetLogFormattedTimestamp ( date , result ) , result;
end



-- Method:          GRM.GetJoinOrRejoinString ()
-- What it Does:    Builds the string for players joined or rejoined the guild
-- Purpose:         Ease of reusing this code and ease of reading it.
GRM.GetJoinOrRejoinString = function ( foundInLog , player1 , player2 , date , isRejoin , playerLevel , previousName , numTimesInGuild , isBanned , reasonBanned , dateLeft , howLongAgo , dateOriginallyJoined , origRank , customNote , isTransfer )

    local logReport = "";
    local numTimesString = "";
    local nameChangeString = "";
    local dateLeftG = "";
    local dateOrigJoin = "";
    local howLongReport = "";
    local banReason = "";
    local customNoteString = "";
    local header = "";
    local transferMsg = "";

    if origRank == nil then
        origRank = GRM.L ( "Unknown" );
    end
    if customNote == nil then
        customNote = "";
    end
    
    -- Rejoin String details!!!
    if isRejoin then

        if isTransfer then

            header = GRM.L ( "{name} has transferred servers and REJOINED the Guild." , player2 ) .. " " .. GRM.L ( "(LVL: {num})" , nil , nil , playerLevel );
        
        -- Configure Reason Banned and warning!
        elseif isBanned then

            if reasonBanned == "" then
                banReason = GRM.L ( "None Given" );
            else
                banReason = reasonBanned;
            end

            header = ( GRM.L ( "WARNING!" ) .. "\n" .. GRM.L ( "{name} REJOINED the guild but was previously BANNED!" , player2 ) );
            if foundInLog then
                if player1 == nil then
                    player1 = "|CFFFFFFFF" .. GRM.L ( "Unknown" ) .. "|r";
                end
                header = header  .. " " .. GRM.L ( "(Invited by: {name})" , player1 ) .. "|CFFFFFFFF";
            else
                header = header .. "|CFFFFFFFF";  -- Return the string to WHITE for the information to clearly read it.
            end

        else
            
            if foundInLog and player1 ~= nil then
                header = GRM.L ( "{name} has REINVITED {name2} to the guild" , player1 , player2 ) .. " " .. GRM.L ( "(LVL: {num})" , nil , nil , playerLevel );
            else
                header = GRM.L ( "{name} has REJOINED the guild" , player2 ) .. " " .. GRM.L ( "(LVL: {num})" , nil , nil , playerLevel );

                if foundInLog and player1 == nil then
                    player1 = "|CFFFFFFFF" .. GRM.L ( "Unknown" ) .. "|r";
                    header = header  .. " " .. GRM.L ( "(Invited by: {name})" , player1 ) .. "|CFFFFFFFF";
                end
                
            end
        end

        if not isTransfer then
            -- Number of times returning to the guild
            if numTimesInGuild > 1 then
                numTimesString = GRM.L ( "{name} has Been in the Guild {num} Times Before" , player2 , nil , numTimesInGuild );
            else
                numTimesString = GRM.L ( "{name} is Returning for the First Time." , player2 );
            end

            -- Player Namechanged when they were not in the guild.
            if previousName ~= "" then
                nameChangeString = "\n" .. GRM.L ( "{name} has Name-Changed to {name2}" , previousName , player2 );
            end

            -- Date left
            if dateLeft ~= "" then
                dateLeftG = GRM.FormatTimeStamp ( dateLeft );
            else
                dateLeftG = GRM.L ( "Unknown" );
            end

            -- How long ago
            if ( type ( howLongAgo ) == "number" and howLongAgo ~= -1 ) or ( type ( howLongAgo ) == "string" and #howLongAgo > 1 ) then
                local reportTime = "";

                if type ( howLongAgo ) == "number" then
                    reportTime = GRM.GetTimePassedUsingEpochTime ( howLongAgo ).timestamp;
                else
                    local day , month , year = GRM.ParseStandardFormatDate ( howLongAgo );
                    reportTime = GRM.GetTimePassedUsingTableOrString ( { day , month , year } );
                end

                howLongReport = GRM.L ( "({num} ago)" , nil , nil , reportTime );
            end

            -- Original join date
            if type ( dateOriginallyJoined ) == "string" then
                if dateOriginallyJoined == "" then
                    dateOrigJoin = GRM.L ( "Unknown" );
                else

                    dateOrigJoin = dateOriginallyJoined;

                    -- Let's remove the hour at the end.
                    local tempDate = string.find ( dateOrigJoin , "%s%d%d:" );
                    if tempDate ~= nil then
                        dateOrigJoin = string.sub ( dateOrigJoin , 1 , tempDate - 1 );
                    end
                end
            elseif type ( dateOriginallyJoined ) == "table" then
                if dateOriginallyJoined[1] == 0 then
                    dateOrigJoin = GRM.L ( "Unknown" );
                else
                    dateOrigJoin = GRM.FormatTimeStamp ( { dateOriginallyJoined[1] , dateOriginallyJoined[2] , dateOriginallyJoined[3] } , false )
                end
            end

            if customNote ~= "" then
                customNoteString = "\n|r|CFF66B5E6" .. GRM.L ( "Additional Notes:" ) .. "|r\n" .. customNote .. "\n";
            end

            local information = {};

            if isBanned then
                information = {
                    { "|r|CFF66B5E6" .. GRM.L ( "Date of Ban:" ) .. "|r|CFFFFFFFF" , dateLeftG .. " " .. howLongReport } , 
                    { "|r|CFF66B5E6" .. GRM.L ( "Date Originally Joined:" ) .. "|r|CFFFFFFFF" , dateOrigJoin } ,
                    { "|r|CFF66B5E6" .. GRM.L ( "Old Guild Rank:" ) .. "|r|CFFFFFFFF" , origRank } ,
                    { "|r|CFF66B5E6" .. GRM.L ( "Reason:" ) .. "|r|CFFFFFFFF" , banReason }
                };
            else
                information = {
                    { "|r|CFF66B5E6" .. GRM.L ( "Date Left:" ) .. "|r" , dateLeftG .. " " .. howLongReport } ,
                    { "|r|CFF66B5E6" .. GRM.L ( "Date Originally Joined:" ) .. "|r" , dateOrigJoin } ,
                    { "|r|CFF66B5E6" .. GRM.L ( "Old Guild Rank:" ) .. "|r" , origRank }
                };
            end

            -- Straight column for reporting (since unable to find a good tabbing solution in Lua for column alignment)
            information = GRM.AllignTwoColumns ( information , 20 );

            -- At this the string is mostly built. It still does not have the timstamp attached to the front
            logReport = ( header .. "\n|r|CFFFFFFFF" .. numTimesString .. "|r" .. information .. nameChangeString .. customNoteString );

        else
            -- Player Namechanged when they were not in the guild.
            if previousName ~= "" then
                nameChangeString = "\n" .. GRM.L ( "{name} has Name-Changed to {name2}" , previousName , player2 );
            end
            if customNote ~= "" then
                customNoteString = "\n|r|CFF66B5E6" .. GRM.L ( "Additional Notes:" ) .. "|r\n" .. customNote .. "\n";
            end
            logReport = ( header .. nameChangeString .. customNoteString );

        end

    else
        ---- IS NOT REJOIN
        logReport = GRM.L ( "{name} has JOINED the guild!" , player2 ) .. " " .. GRM.L ( "(LVL: {num})" , nil , nil , playerLevel );
        if foundInLog then
            if player1 == nil then
                player1 = "|CFFFFFFFF" .. GRM.L ( "Unknown" ) .. "|r";
            end
            logReport = logReport .. " - " .. GRM.L ( "Invited By: {name}" , player1 );
        end
    end

    return GRM.GetLogFormattedTimestamp ( date , logReport ) , logReport;
end

-- Method:          GRM.GetEventString ( int , string , string , int , bool , string , array , int )
-- What it Does:    Builds the string for report on events upcoming in the guild.
-- Purpose:         Ease of reusing this code and ease of reading it.
GRM.GetEventString = function ( eventIndex , fullName , class , eventDay , eventMonthIndex , isLeapYear , date , numYears )
    local result = "";
    local eventDate = "";

    -- This needs to be reprocessed for language issues.
    if ( eventDay == 29 and eventMonthIndex == 2 ) and not isLeapYear then    -- If anniversary happened on leap year date, and the current year is NOT a leap year, then put it on 1 Mar.
        eventDate = GRM.L ( "1 Mar" );
    else
        eventDate = eventDay .. " " .. GRM.L ( monthEnum2 [ tostring ( eventMonthIndex ) ] );
    end

    if eventIndex == 1 then
        result = GRM.GetAnniversaryLogReport ( fullName , class , numYears );
    elseif eventIndex == 2 then
        result = GRM.GetBirthdayLogReport ( fullName , class )
    end
    result = result .. " ( " .. eventDate .. " )";

    result = GRM.GetLogFormattedTimestamp ( date , result );

    return result;
end

-- Method:          GRM.GetDeathString ( string , string , int , table )
-- What it Does:    Returns the string with the player indicating their death
-- Purpose:         Indicate player death for hardcore mode.
GRM.GetDeathString = function ( name , class , level , date )
    local result = "";

    result = GRM.L ( "{name} has died at level {num}." , GRM.GetClassColorRGB ( class , true ) .. GRM.FormatName ( name ) .. "|r" , nil , level );
    
    return GRM.GetLogFormattedTimestamp ( date , result ) , result;
end

-- Method:          GRM.ReProcessLogString ( table )
-- What it Does:    Reprocesses all log entries, using their metadata, if available, and re-saves the string
-- Purpose:         Allow the player the change languages and have the strings get reprocessed.
GRM.ReProcessLogString = function( logEntry )
    local entryIndex = logEntry[1];
    local result = "";

    if #logEntry > 2 then
        
        if entryIndex == 1 then
            result = GRM.GetPromotionLogString ( logEntry[3] , logEntry[4] , logEntry[5] , logEntry[6] , logEntry[7] , logEntry[8] );
            
        elseif entryIndex == 2 then
            result = GRM.GetDemotionLogString ( logEntry[3] , logEntry[4] , logEntry[5] , logEntry[6] , logEntry[7] , logEntry[8] );

        elseif entryIndex == 3 then
            result = GRM.GetLeveledString ( logEntry[3] , logEntry[4] , logEntry[5] , logEntry[6] , logEntry[7] , logEntry[8] , logEntry[9] );

        elseif entryIndex == 4 then
            result = GRM.GetNoteChangeString ( logEntry[3] , logEntry[4] , logEntry[5] , logEntry[6] );

        elseif entryIndex == 5 then
            result = GRM.GetOfficerNoteChangeString ( logEntry[3] , logEntry[4] , logEntry[5] , logEntry[6] );

        elseif entryIndex == 6 then
            result = GRM.GetRankRenamedString ( logEntry[3] , logEntry[4] , logEntry[5] , logEntry[6] );

        elseif entryIndex == 7 then
            result = GRM.GetJoinOrRejoinString ( logEntry[3] , logEntry[4] , logEntry[5] , logEntry[6] , logEntry[7] , logEntry[8] , logEntry[9] , logEntry[10] , logEntry[11] , logEntry[12] , logEntry[13] , logEntry[14] , logEntry[15] , logEntry[16] , logEntry[17] );

        elseif entryIndex == 8 then -- Not a rejoin, just a join
            result = GRM.GetJoinOrRejoinString ( logEntry[3] , logEntry[4] , logEntry[5] , logEntry[6] , logEntry[7] , logEntry[8] );

        elseif entryIndex == 9 then
            result = GRM.GetJoinOrRejoinString ( logEntry[3] , logEntry[4] , logEntry[5] , logEntry[6] , logEntry[7] , logEntry[8] , logEntry[9] , logEntry[10] , logEntry[11] , logEntry[12] , logEntry[13] , logEntry[14] , logEntry[15] , logEntry[16] , logEntry[17] );

        elseif entryIndex == 10 then
            local isFoundInEventLog , playerLevel , isLiveDetection , customNote;
            
            if #logEntry < 12 then
                isFoundInEventLog = nil;
            else
                isFoundInEventLog = logEntry[12];
            end

            if #logEntry < 13 then
                playerLevel = nil;
            else
                playerLevel = logEntry[13];
            end

            if #logEntry < 14 then
                isLiveDetection = false;
            else
                isLiveDetection = logEntry[14];
            end

            if #logEntry < 15 then
                customNote = "";
            else
                customNote = logEntry[15];
            end

            result = GRM.GetLeftOrKickString ( logEntry[3] , logEntry[4] , logEntry[5] , logEntry[6] , logEntry[7] , logEntry[8] , logEntry[9] , logEntry[10] , logEntry[11] , isFoundInEventLog , nil , isLiveDetection , playerLevel , customNote )

        elseif entryIndex == 11 then
            result = GRM.GetNameChangeString ( logEntry[3] , logEntry[4] , logEntry[5] );

        elseif entryIndex == 14 then
            result = GRM.GetInactiveReturnString ( logEntry[3] , logEntry[4] , logEntry[5] );

        elseif entryIndex == 15 then
            local numYears;
            if #logEntry == 10 then
                numYears = logEntry[10];
            end
            result = GRM.GetEventString ( logEntry[3] , logEntry[4] , logEntry[5] , logEntry[6] , logEntry[7] , logEntry[8] , logEntry[9] , numYears );

        elseif entryIndex == 16 then
            if #logEntry == 5 then
                result = GRM.GetRecommendKickString ( logEntry[3] , logEntry[4] , logEntry[5] );
            elseif #logEntry == 6 then
                result = GRM.GetRecommendKickString ( logEntry[3] , logEntry[4] , logEntry[5] , logEntry[6] );
            end
        elseif entryIndex == 22 then
            result = GRM.GetPromotionRecommendString ( logEntry[3] , logEntry[4] , logEntry[5] , logEntry[6] );

        elseif entryIndex == 23 then
            result = GRM.GetDemotionRecommendString ( logEntry[3] , logEntry[4] , logEntry[5] , logEntry[6] );

        elseif entryIndex == 19 then
            result = GRM.GetCustomNoteChangeString ( logEntry[3] , logEntry[4] , logEntry[5] , logEntry[6] , logEntry[7] );

        elseif entryIndex == 20 then
            result = GRM.GetBanLogUpdateAndEditString ( logEntry[3] , logEntry[4] , logEntry[5] , logEntry[6] , logEntry[7] , logEntry[8] );

        elseif entryIndex == 21 then
            -- Error protection from an old bug...
            if type ( logEntry[4] ) == "boolean" then
                logEntry[1] = 20;
                result = GRM.GetBanLogUpdateAndEditString ( logEntry[3] , logEntry[4] , logEntry[5] , logEntry[6] , logEntry[7] , logEntry[8] );
            else
                result = GRM.GetUnBanString ( logEntry[3] , logEntry[4] , logEntry[5] );
            end
            
        elseif entryIndex == 24 then
            result = GRM.GetDeathString ( logEntry[3] , logEntry[4] , logEntry[5] , logEntry[5] );        
        end
    else
        result = logEntry[2];         -- Cannot reprocess old stirng. No metadata.
    end

    return result;
end

-- Method:          GRM.ReprocessAllLogEntriesToCurrentLanguage()
-- What it Does:    When Changing the language, this lets you reprocess the entire log in the new language.
-- Purpose:         Ability to re-translate your log as new translation strings open
GRM.ReprocessAllLogEntriesToCurrentLanguage = function()
    for i = 1 , #GRM.GetLog() do
        GRM.GetLog()[i][2] = GRM.ReProcessLogString ( GRM.GetLog()[i] );
    end

    GRM.BuildLogComplete( true , true );
end

---------------------------------------
--------- END LOG BUILD STRINGS -------
---------------------------------------


-------------------------------------------
------- BUILD LOG ENTRY STORAGE FORMATS ---
-------------------------------------------

-- Method:          GRM.AddPromotionDateTempLogEntry ( bool , string , string , string , string , array )
-- What it Does     Stores a temp log entry that will later be added in the final report with the pre-processed string
-- Purpose:         By adding all the metadata the string can be re-processed if the player changes their preferred date format or language.
GRM.AddPromotionDateTempLogEntry = function ( foundInLog , player1 , player2 , initRank , finRank , date )
    table.insert ( GRM_G.TempLogPromotion , { 1 , GRM.GetPromotionLogString ( foundInLog , player1 , player2 , initRank , finRank , date ) , foundInLog , player1 , player2 , initRank , finRank , date } );
end

-- Method:          GRM.AddDemotionDateTempLogEntry ( bool , string , string , string , string , array )
-- What it Does     Stores a temp log entry that will later be added in the final report with the pre-processed string
-- Purpose:         By adding all the metadata the string can be re-processed if the player changes their preferred date format or language.
GRM.AddDemotionDateTempLogEntry = function ( foundInLog , player1 , player2 , initRank , finRank , date )
    table.insert ( GRM_G.TempLogDemotion , { 2 , GRM.GetDemotionLogString ( foundInLog , player1 , player2 , initRank , finRank , date ) , foundInLog , player1 , player2 , initRank , finRank , date } );
end

-- Method:          GRM.AddRankRenameEntry ( int , string , string , array )
-- What it Does     Stores a temp log entry that will later be added in the final report with the pre-processed string
-- Purpose:         By adding all the metadata the string can be re-processed if the player changes their preferred date format or language.
GRM.AddRankRenameEntry = function ( rankNum , oldRank , newRank , date )
    table.insert ( GRM_G.TempRankRename , { 6 , GRM.GetRankRenamedString ( rankNum , oldRank , newRank , date ) , rankNum , oldRank , newRank , date } );
end

-- Method:          GRM.AddLeveledTempLogEntry ( string , int , int , int , array , bool )
-- What it Does     Stores a temp log entry that will later be added in the final report with the pre-processed string
-- Purpose:         By adding all the metadata the string can be re-processed if the player changes their preferred date format or language.
GRM.AddLeveledTempLogEntry = function ( simpleName , milestoneLevel , level , numGained , date , levelCap , fullName )
    table.insert ( GRM_G.TempLogLeveled , { 3 , GRM.GetLeveledString ( simpleName , milestoneLevel , level , numGained , date , levelCap , fullName ) , simpleName , milestoneLevel , level , numGained , date , levelCap , fullName } );
end

-- Method:          GRM.AddNoteTempLogEntry ( string , string , string , array )
-- What it Does     Stores a temp log entry that will later be added in the final report with the pre-processed string
-- Purpose:         By adding all the metadata the string can be re-processed if the player changes their preferred date format or language.
GRM.AddNoteTempLogEntry = function ( simpleName , oldNote , newNote , date )
    table.insert ( GRM_G.TempLogNote , { 4 , GRM.GetNoteChangeString ( simpleName , oldNote , newNote , date ) , simpleName , oldNote , newNote , date } );
end

-- Method:          GRM.AddOfficerNoteTempLogEntry ( string , string , string , array )
-- What it Does     Stores a temp log entry that will later be added in the final report with the pre-processed string
-- Purpose:         By adding all the metadata the string can be re-processed if the player changes their preferred date format or language.
GRM.AddOfficerNoteTempLogEntry = function ( simpleName , oldNote , newNote , date )
    table.insert ( GRM_G.TempLogONote , { 5 , GRM.GetOfficerNoteChangeString ( simpleName , oldNote , newNote , date ) , simpleName , oldNote , newNote , date } );
end

-- Method:          GRM.AddInactiveReturnTempLogEntry ( string , string , string , array )
-- What it Does     Stores a temp log entry that will later be added in the final report with the pre-processed string
-- Purpose:         By adding all the metadata the string can be re-processed if the player changes their preferred date format or language.
GRM.AddInactiveReturnTempLogEntry = function ( simpleName , hoursReport , date )
    table.insert ( GRM_G.TempInactiveReturnedLog , { 14 , GRM.GetInactiveReturnString ( simpleName , hoursReport , date ) , simpleName , hoursReport , date } );
end

-- Method:          GRM.AddEventRecommendKickTempLogEntry ( string , int , array , array )
-- What it Does     Stores a temp log entry that will later be added in the final report with the pre-processed string
-- Purpose:         By adding all the metadata the string can be re-processed if the player changes their preferred date format or language.
GRM.AddEventRecommendKickTempLogEntry = function ( name , numRules , date , ruleNames )
    table.insert ( GRM_G.TempEventRecommendKickReport , { 16 , GRM.GetRecommendKickString ( name , numRules , date , ruleNames ) , name , numRules , date , ruleNames } );
end

-- Method:          GRM.AddEventRecommendPromotionLogEntry ( string , int , array , array )
-- What it Does     Stores a temp log entry that will later be added in the final report with the pre-processed string
-- Purpose:         By adding all the metadata the string can be re-processed if the player changes their preferred date format or language.
GRM.AddEventRecommendPromotionLogEntry = function ( name , numRules , date , ruleNames )
    table.insert ( GRM_G.TempEventRecommendPromotionReport , { 22 , GRM.GetPromotionRecommendString ( name , numRules , date , ruleNames ) , name , numRules , date , ruleNames } );
end

-- Method:          GRM.AddEventRecommendDemotionLogEntry ( string , int , array , array )
-- What it Does     Stores a temp log entry that will later be added in the final report with the pre-processed string
-- Purpose:         By adding all the metadata the string can be re-processed if the player changes their preferred date format or language.
GRM.AddEventRecommendDemotionLogEntry = function ( name , numRules , date , ruleNames )
    table.insert ( GRM_G.TempEventRecommendDemotionReport , { 23 , GRM.GetDemotionRecommendString ( name , numRules , date , ruleNames ) , name , numRules , date , ruleNames } );
end

-- Method:          GRM.AddNameChangeTempLogEntry ( string , string , string , array )
-- What it Does     Stores a temp log entry that will later be added in the final report with the pre-processed string
-- Purpose:         By adding all the metadata the string can be re-processed if the player changes their preferred date format or language.
GRM.AddNameChangeTempLogEntry = function ( simpleName , oldName , date )
    table.insert ( GRM_G.TempNameChanged , { 11 , GRM.GetNameChangeString ( simpleName , oldName , date ) , simpleName , oldName , date } );
end

-- Method:          GRM.AddLeftOrKickEntry ( string , bool , string , array , array , string , string , string , array , bool )
-- What it Does     Stores a temp log entry that will later be added in the final report with the pre-processed string
-- Purpose:         By adding all the metadata the string can be re-processed if the player changes their preferred date format or language.
GRM.AddLeftOrKickEntry = function ( unitName , playerWasKicked , timePassed , logEntryMetaData , listOfAlts , mainName , publicNote , officerNote , date , isFoundInEventLog , _ , playerLevel , customNote )
    table.insert ( GRM_G.TempLeftGuild , { 10 , GRM.GetLeftOrKickString ( unitName , playerWasKicked , timePassed , logEntryMetaData , listOfAlts , mainName , publicNote , officerNote , date , isFoundInEventLog , nil , nil , playerLevel , customNote ) , unitName , playerWasKicked , timePassed , logEntryMetaData , listOfAlts , mainName , publicNote , officerNote , date , isFoundInEventLog , playerLevel , false , customNote } );
end

-- Method:          GRM.AddBanRejoinEntry ( ... )
-- What it Does     Stores a temp log entry that will later be added in the final report with the pre-processed string
-- Purpose:         By adding all the metadata the string can be re-processed if the player changes their preferred date format or language.
GRM.AddBanRejoinEntry = function ( foundInLog , player1 , player2 , date , isRejoin , playerLevel , previousName , numTimesInGuild , isBanned , reasonBanned , dateLeft , howLongAgo , dateOriginallyJoined , origRank , customNote , isTransfer )
    table.insert (
        GRM_G.TempBannedRejoin , 
        { 9 , GRM.GetJoinOrRejoinString ( foundInLog , player1 , player2 , date , isRejoin , playerLevel , previousName , numTimesInGuild , isBanned , reasonBanned , dateLeft , howLongAgo , dateOriginallyJoined , origRank , customNote , isTransfer ) ,
        foundInLog , player1 , player2 , date , isRejoin , playerLevel , previousName , numTimesInGuild , isBanned , reasonBanned , dateLeft , howLongAgo , dateOriginallyJoined , origRank , customNote , playerLevel , isTransfer }
    );
end

-- Method:          GRM.AddNormalRejoinEntry ( ... )
-- What it Does     Stores a temp log entry that will later be added in the final report with the pre-processed string
-- Purpose:         By adding all the metadata the string can be re-processed if the player changes their preferred date format or language.
GRM.AddNormalRejoinEntry = function ( foundInLog , player1 , player2 , date , isRejoin , playerLevel , previousName , numTimesInGuild , isBanned , reasonBanned , dateLeft , howLongAgo , dateOriginallyJoined , origRank , customNote , isTransfer )
    table.insert (
        GRM_G.TempRejoin , 
        { 7 , GRM.GetJoinOrRejoinString ( foundInLog , player1 , player2 , date , isRejoin , playerLevel , previousName , numTimesInGuild , isBanned , reasonBanned , dateLeft , howLongAgo , dateOriginallyJoined , origRank , customNote , isTransfer ) ,
        foundInLog , player1 , player2 , date , isRejoin , playerLevel , previousName , numTimesInGuild , isBanned , reasonBanned , dateLeft , howLongAgo , dateOriginallyJoined , origRank , customNote , playerLevel , isTransfer }
    );

end

-- Method:          GRM.AddJoinEntry ( bool , string , string , array , bool , int )
-- What it Does     Stores a temp log entry that will later be added in the final report with the pre-processed string
-- Purpose:         By adding all the metadata the string can be re-processed if the player changes their preferred date format or language.
GRM.AddJoinEntry = function ( foundInLog , player1 , player2 , date , isRejoin , playerLevel )
    table.insert ( GRM_G.TempNewMember , { 8 , GRM.GetJoinOrRejoinString ( foundInLog , player1 , player2 , date , isRejoin , playerLevel ) , foundInLog , player1 , player2 , date , isRejoin , playerLevel } );
end

-- Method:          GRM.AddEventEntry ( int , string , string , int , bool , string , array , int )
-- What it Does     Stores a temp log entry that will later be added in the final report with the pre-processed string
-- Purpose:         By adding all the metadata the string can be re-processed if the player changes their preferred date format or language.
GRM.AddEventEntry = function ( eventIndex , fullName , class , eventDay , eventMonthIndex , isLeapYear , date , numYears )
    table.insert ( GRM_G.TempEventReport , { 15 , GRM.GetEventString ( eventIndex , fullName , class , eventDay , eventMonthIndex , isLeapYear , date , numYears ) , eventIndex , fullName , class , eventDay , eventMonthIndex , isLeapYear , date , numYears } );
end

-- Method:          GRM.AddHardcoreDeathEntry ( int , string , string , int , int , int , int )
-- What it Does:    Adds an entry for reporting to the log on Hardcore Mode deaths
-- Purpose:         Enable reporting to the log
GRM.AddHardcoreDeathEntry = function ( fullName , class , level , date )
    table.insert ( GRM_G.TempDeathReport , { 24 , GRM.GetDeathString ( fullName , class , level , date ) , fullName , class , level , date } )
end

-- Method:          GRM.GetRuleNames ( table )
-- What it Does:    Returns an array of strings of the given player's matching ruels
-- Purpose:         Log reporting
GRM.GetRuleNames = function( player )
    local result = {};

    for i = #player , 1 , -1 do
        table.insert ( result , player[i][1] );
    end

    return result;
end

-- Method           GRM.ScanRecommendationsList()
-- What it Does:    Builds recommend log messages and also reports them as needed
-- Purpose:         So player knows that it is time to kick a player.
GRM.ScanRecommendationsList = function()

    -- Before we run this, let's validate the rules
    GRM.RuleIntegrityCheck();
    
    local playerRecommendation = {};
    local tempListOfNames = {};
    local ruleNames = "";
    local player;

    GRM.RefreshNumberOfHoursTilRecommend();

    -- Kick Recommendations
    if CanGuildRemove() then        -- No need to do the work and report if you cannot remove players
        playerRecommendation = GRM.GetKickNamesByFilterRules();
        tempListOfNames = {};
        ruleNames = "";
        
        for i = 1 , #playerRecommendation do
            tempListOfNames[playerRecommendation[i].name] = {};     -- Going to be used for validating in list or not.
            ruleNames = GRM.GetRuleNames ( playerRecommendation[i] );
    
            player = GRM.GetPlayer ( playerRecommendation[i].name );
            if not player.recommendToKick then
                player.recommendToKick = true;     -- This acts to prevent the repeat announcement to the log.
                GRM.AddEventRecommendKickTempLogEntry ( GRM.GetClassifiedName ( playerRecommendation[i].name , true ) , #playerRecommendation[i] , select ( 2 , GRM.GetTimestamp() ) , ruleNames );
            end
    
        end
    
        -- Clear all names NOT on this list.
        for _ , p in pairs ( GRM.GetGuild() ) do
            if type ( p ) == "table" and p.recommendToKick and tempListOfNames[p.name] == nil then
                p.recommendToKick = false;        
            end
        end
    end
    
    -- Promotion Recommendations
    if CanGuildPromote() then        -- No need to do the work and report if you cannot remove players
        playerRecommendation = GRM.GetNamesByFilterRules ( 2 );
        tempListOfNames = {};
        ruleNames = "";
    
        for i = 1 , #playerRecommendation do
            tempListOfNames[playerRecommendation[i].name] = {};     -- Going to be used for validating in list or not.
            ruleNames = GRM.GetRuleNames ( playerRecommendation[i] );
    
            player = GRM.GetPlayer ( playerRecommendation[i].name );
            if not player.recommendToPromote then
                player.recommendToPromote = true;     -- This acts to prevent the repeat announcement to the log.
                GRM.AddEventRecommendPromotionLogEntry ( GRM.GetClassifiedName ( playerRecommendation[i].name , true ) , #playerRecommendation[i] , select ( 2 , GRM.GetTimestamp() ) , ruleNames );
            end
    
        end

        -- Clear all names NOT on this list.
        for _ , p in pairs ( GRM.GetGuild() ) do
            if type ( p ) == "table" and p.recommendToPromote and tempListOfNames[p.name] == nil then
                p.recommendToPromote = false;        
            end
        end
    end

    -- Demotion Recommendations
    if CanGuildDemote() then        -- No need to do the work and report if you cannot remove players
        playerRecommendation = GRM.GetNamesByFilterRules ( 3 );
        tempListOfNames = {};
        ruleNames = "";
    
        for i = 1 , #playerRecommendation do
            tempListOfNames[playerRecommendation[i].name] = {};     -- Going to be used for validating in list or not.
            ruleNames = GRM.GetRuleNames ( playerRecommendation[i] );
    
            player = GRM.GetPlayer ( playerRecommendation[i].name );
            if not player.recommendToDemote then
                player.recommendToDemote = true;     -- This acts to prevent the repeat announcement to the log.
                GRM.AddEventRecommendDemotionLogEntry ( GRM.GetClassifiedName ( playerRecommendation[i].name , true ) , #playerRecommendation[i] , select ( 2 , GRM.GetTimestamp() ) , ruleNames );
            end
    
        end

        -- Clear all names NOT on this list.
        for _ , p in pairs ( GRM.GetGuild() ) do
            if type ( p ) == "table" and p.recommendToDemote and tempListOfNames[p.name] == nil then
                p.recommendToDemote = false;        
            end
        end
    end

end


-----------------------------------------
-------- END OF LOG ENTRY FORMATTING ----
-----------------------------------------

-- Method:          GRM.GetGuildEventString ( int , string , string )
-- What it Does:    Gets more exact info from the actual Guild Event Log ( can only be queried once per 10 seconds) as a string
-- Purpose:         This parses more exact info, like "who" did the kicking, or "who" invited who, and so on.
GRM.GetGuildEventString = function ( index , playerName , initRank , finRank , class , liveJoinDetected )
    -- index 1 = demote , 2 = promote , 3 = remove/quit , 4 = invite/join
    local added = false;
    local eventType = { "demote" , "promote" , "invite" , "join" , "quit" , "remove" };
    local logEntryMetaData = { false };

    if GRM_G.BuildVersion >= 30000 then -- Cata 2.3
        QueryGuildEventLog();

        if index == 1 or index == 2 then
            for i = GetNumGuildEvents() , 1 , -1 do
                local typeEvent , p1, p2 , _ , year , month , day , hour = GetGuildEventInfo ( i );
                if p1 ~= nil then                                                 ---or eventType [ 2 ] == type ) and ( p2 ~= nil and p2 == playerName ) and p1 ~= nil then
                    if index == 1 and eventType [ 1 ] == typeEvent and p2 ~= nil and ( p2 == playerName or p2 == GRM.SlimName ( playerName ) ) then          -- DEMOTIONS
                        p1 = GRM.GetStringClassColorByName ( p1 ) .. GRM.SlimName ( p1 ) .. "|r";
                        p2 = GRM.GetStringClassColorByName ( p2 ) .. GRM.SlimName ( p2 ) .. "|r";
                        logEntryMetaData = { true , p1 , p2 , initRank , finRank , GRM.GetTimestampBasedOnTimePassed ( { day , month , year , hour } ) };
                        added = true;
                        break;
                    elseif index == 2 and eventType [ 2 ] == typeEvent and p2 ~= nil and ( p2 == playerName or p2 == GRM.SlimName ( playerName ) ) then      -- PROMOTIONS
                        p1 = GRM.GetStringClassColorByName ( p1 ) .. GRM.SlimName ( p1 ) .. "|r";
                        p2 = GRM.GetStringClassColorByName ( p2 ) .. GRM.SlimName ( p2 ) .. "|r";
                        logEntryMetaData = { true , p1 , p2 , initRank , finRank , GRM.GetTimestampBasedOnTimePassed ( { day , month , year , hour } ) };
                        added = true;
                        break;
                    end
                end
            end

            -- Remove or Quit
       elseif index == 3 then
            local notFound = true;
            for i = GetNumGuildEvents() , 1 , -1 do 
                local typeEvent , p1, p2 , _ , year , month , day , hour = GetGuildEventInfo ( i );
                if p1 ~= nil then 
                    if eventType [ 5 ] == typeEvent or eventType [ 6 ] == typeEvent then   -- Quit or Kicked

                        -- KICKED
                        if eventType [ 6 ] == typeEvent and p2 ~= nil and ( p2 == playerName or p2 == GRM.SlimName ( playerName ) ) then
                            p1 = GRM.GetStringClassColorByName ( p1 ) .. GRM.SlimName ( p1 ) .. "|r";
                            p2 = GRM.GetStringClassColorByName ( p2 ) .. GRM.SlimName ( p2 ).. "|r";
                            logEntryMetaData = { true , p1 , p2 , GRM.GetTimestampBasedOnTimePassed ( { day , month , year , hour } ) };
                            added = true;
                            notFound = false;

                        -- QUIT
                        elseif eventType [ 5 ] == typeEvent and ( p1 == playerName or p1 == GRM.SlimName ( playerName ) ) then
                            -- FOUND!
                            p1 = GRM.GetStringClassColorByName ( playerName ) .. GRM.SlimName ( playerName ) .. "|r";
                            logEntryMetaData = { true , p1 , nil , GRM.GetTimestampBasedOnTimePassed ( { day , month , year , hour } ) };
                            added = true;
                            notFound = false;
                        end
                        if notFound ~= true then
                            break;
                        end
                    end
                end
            end
            -- Invite
        elseif index == 4 then
            for i = GetNumGuildEvents() , 1 , -1 do 
                local typeEvent , p1, p2 , _ , year , month , day , hour = GetGuildEventInfo ( i );
                if eventType [ 3 ] == typeEvent and p1 ~= nil and p2 ~= nil and ( p2 == playerName or p2 == GRM.SlimName ( playerName ) ) then  -- invite
                    p1 = GRM.GetStringClassColorByName ( p1 ) .. GRM.SlimName ( p1 ) .. "|r";
                    p2 = GRM.GetClassColorRGB ( class , true ) .. GRM.SlimName ( p2 ) .. "|r";
                    logEntryMetaData = { true , p1 , p2 , GRM.GetTimestampBasedOnTimePassed ( { day , month , year , hour } ) };
                    added = true;
                    break;
                end
            end

            -- JOINED but no invite data
            -- Possibly player joined but no record of *WHO* invited them
            if not added then

                if not liveJoinDetected then

                    for i = GetNumGuildEvents() , 1 , -1 do 
                        local typeEvent , p1, _ , _ , year , month , day , hour = GetGuildEventInfo ( i );  -- p1 = the player who joined
                        if eventType [ 4 ] == typeEvent  and p1 ~= nil and ( p1 == playerName or p1 == GRM.SlimName ( playerName ) ) then  -- invite
                            p1 = GRM.GetClassColorRGB ( class , true ) .. GRM.SlimName ( p1 ) .. "|r";
                            logEntryMetaData = { true , nil , p1 , GRM.GetTimestampBasedOnTimePassed ( { day , month , year , hour } ) };
                            added = true;
                            break;
                        end
                    end

                else
                    -- Build it on today's date.
                    local hour, minutes = GetGameTime();
                    local time = GRM.GetFormatTime ( hour , minutes );
                    local month, day, year = select ( 2 , GRM.GetTodaysDate() );
                    playerName = GRM.GetClassColorRGB ( class , true ) .. GRM.SlimName ( playerName ) .. "|r";
                    local timestamp = day .. " " .. monthEnum2[ tostring ( month ) ] .. " '" .. tostring ( year - 2000 ) .. " " .. time;
                    logEntryMetaData = { true , nil , playerName , { timestamp , GRM.ConvertToStandardFormatDate ( day , month , year ) , { day , month , year } } };
                    added = true;
                end
            end          
        end
    end

    return added , logEntryMetaData;
end

-- Method:          GRM.RecordKickChanges ( string , boolean , array , string )
-- What it Does:    Records and logs the changes for when a guildie either is KICKED or leaves the guild
-- Purpose:         Having its own function saves on repeating a lot of code here.
GRM.RecordKickChanges = function ( unitName , playerWasKicked , dateArray , officerThatKicked )
    local timestamp , tArray = GRM.GetTimestamp();
    local timeEpoch = time();
    local oldMemberData = GRM.GetFormerMembers();
    local player = GRM.GetPlayer ( unitName );
    local classColorCode = GRM.GetStringClassColorByName ( unitName );
    local timePassed = GRM.GetTimePlayerHasBeenMember ( unitName );
    local added = false;
    local logEntryMetaData = {};
    local listOfAlts = {};
    local tempStorage = { ( classColorCode .. unitName .. "|r" ) , playerWasKicked , timePassed };
    local isNoLongerOnServer = false;
    local playerLevel = 0;
    local customNote = "";
    local stringFound = false;

    -- Live detection
    if officerThatKicked ~= nil then
        added = true;
        local timeS , timeArray = GRM.GetTimestamp();
        logEntryMetaData = { true , GRM.GetStringClassColorByName ( officerThatKicked ) .. GRM.FormatName ( officerThatKicked ) .. "|r" , ( classColorCode .. unitName .. "|r" ) , { timeS , time() , timeArray } };
        timestamp = logEntryMetaData[4][1];
    -- Guild Event Log Detection
    else
        added , logEntryMetaData = GRM.GetGuildEventString ( 3 , unitName ); -- Kicked from the guild.
        if logEntryMetaData[1] then
            -- added = true
            timestamp = logEntryMetaData[4][1];
            dateArray = logEntryMetaData[4][3];
            stringFound = true;
            tempStorage[2] = true;
        end

    end

    -- metaData = 4
    table.insert ( tempStorage , logEntryMetaData ); -- index 4

    -- Keep date formatting consistent.
    local dates = {};
    if not stringFound then
        dates = { tArray[1] , tArray[2] , tArray[3] };
    else
        dates = { dateArray[1] , dateArray[2] , dateArray[3] };
    end
    
    -- Finding Player's record for removal of current guild and adding to the Left Guild table.
    if player then
        -- Found!
        if player.customNote[6] ~= "" then
            customNote = player.customNote[6];
        end

        local standardDate = GRM.ConvertToStandardFormatDate ( dates[1] , dates[2] , dates[3] );

        if #player.rankHist[1][5] == 1 then
            
            player.rankHist[1][1] = player.rankName;
            player.rankHist[1][2] = dates[1];
            player.rankHist[1][3] = dates[2];
            player.rankHist[1][4] = dates[3];
            player.rankHist[1][5] = standardDate;
            player.rankHist[1][6] = 0
            player.rankHist[1][7] = false;
            player.rankHist[1][8] = 1;
            
        end

        if #player.joinDateHist[1][4] == 1 then
            player.joinDateHist[1][1] = dates[1];
            player.joinDateHist[1][2] = dates[2];
            player.joinDateHist[1][3] = dates[3];
            player.joinDateHist[1][4] = standardDate;
            player.joinDateHist[1][5] = 0
            player.joinDateHist[1][6] = false;
            player.joinDateHist[1][7] = 1;
        end

        table.insert ( player.rankHist , 1 , { player.rankName , dates[1] , dates[2] , dates[3] , standardDate , timeEpoch , true , 3 } );      -- 3 means left guild
        table.insert ( player.joinDateHist , 1 , { dates[1] , dates[2] , dates[3] , standardDate , timeEpoch , true , 2 } );

        -- If not banned, then let's ensure we reset his data.
        if not player.bannedInfo[1] then
            player.bannedInfo[1] = false;
            player.bannedInfo[2] = 0;
            player.bannedInfo[3] = false;
            player.bannedInfo[4] = "";
            player.reasonBanned = "";
        end
        
        -- Adding to LeftGuild Player history library
        oldMemberData[unitName] = {};
        oldMemberData[unitName] = GRM.DeepCopyArray ( player );

        playerLevel = oldMemberData[unitName].level;
        
        local main , GUID , class = GRM.GetAltGroupMain ( oldMemberData[unitName].altGroup , true );
        
        -- I don't want to set the main history to be themselves because if they rejoin the guild later, with themselves set as main that could be irrelevant because things change...
        if main ~= "" and main ~= unitName then
            oldMemberData[unitName].mainAtTimeOfLeaving = { main , GUID , class };
        end

        -- Removing it from the alt list
        if GRM.PlayerHasAlts ( player ) then

            -- Let's add them to the end of the report
            local alts = GRM.DeepCopyArray ( GRM.GetListOfAlts ( player , true ) );
            local isFound = false;

            -- Ok, for lookup if they ever rejoin
            oldMemberData[unitName].altsAtTimeOfLeaving = alts;

            for m = 1 , #alts do
                isFound = false;

                -- Only do this if on a scan, not a live detection.
                if officerThatKicked == nil then
                    -- Verify the alt is not on the kick list already;
                    for r = 1 , #GRM_G.TempLeftGuildPlaceholder do
                        if GRM_G.TempLeftGuildPlaceholder[r][1] == alts[m][1] then
                            isFound = true;
                            break;
                        end
                    end
                end

                if not isFound then
                    table.insert ( listOfAlts , GRM.GetClassifiedName ( alts[m][1] , true ) );
                end
            end
            
            -- Let's overwrite the listOfAts
            GRM.RemoveAlt ( unitName , false , 0 );

            -- Set alt to main if it is only one left.
            if oldMemberData[unitName].isMain and #alts == 1 then
                local tempEpochTime = 1;
                if added then
                    tempEpochTime = timeEpoch;
                end
                
                GRM.SetMain ( alts[1][1], tempEpochTime );
            end

            if player.altGroup ~= "" then

                GRM_Alts[GRM_G.guildName][player.altGroup] = nil;
                oldMemberData[unitName].altGroup = "";
            end

        elseif player.altGroup ~= "" then

            GRM_Alts[GRM_G.guildName][player.altGroup] = nil;
            oldMemberData[unitName].altGroup = "";
        end

        oldMemberData[unitName].altGroup = "";
        -- removing from active member library
        GRM_GuildMemberHistory_Save[GRM_G.guildName][unitName] = nil;
        
    end
    table.insert ( tempStorage , listOfAlts ); -- index 5

    -- Update the live frames too!
    if GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame:IsVisible() then
        GRM.RefreshBanListFrames();
    end
    
    local mainName , playerHasAlts = GRM.GetMainName ( unitName , false );
    if mainName ~= "" and mainName ~= unitName and playerHasAlts then
        -- Ok, if they have no mainName, let's check the left player's list for matches..
        table.insert ( tempStorage , GRM.GetClassifiedName ( mainName , true ) );  -- index 6

    else
        table.insert ( tempStorage , "" );  -- index 6
    end

    -- Now, let's add their officer/public notes.
    local p , o = "" , "";
    if GRM.S().addNotesToLeft then
        player = oldMemberData[unitName];
        if player then
            if ( player.note ~= nil and player.note ~= "" ) then
                p = player.note;                
            end
            if ( player.officerNote ~= nil and player.officerNote ~= "" and GRM.CanViewOfficerNote() ) then
                o = player.officerNote;
            end
        end
    end
    -- Let's get it added to the log
    return tempStorage[1] , tempStorage[2] , tempStorage[3] , tempStorage[4] , tempStorage[5] , tempStorage[6] , p , o , dateArray , added , isNoLongerOnServer , playerLevel , customNote;
end

-- Method:          GRM.RecordLeftGuildChanges ( name , array )
-- What it Does:    Records and saves the information when a player leaves the guild, and updates the frames
-- Purpose:         Useful for logging changes that they left the guild on their own, not just kicked.
GRM.RecordLeftGuildChanges = function ( unitName , isLiveDetection )
    local dates = select ( 2 , GRM.GetTimestamp() )
    local timeEpoch = time();
    local oldMemberData = GRM.GetFormerMembers();
    local player = GRM.GetPlayer ( unitName );
    local timePassed = GRM.GetTimePlayerHasBeenMember ( unitName );
    local listOfAlts = {};
    local logEntryMetaData = { true , GRM.GetClassifiedName ( unitName , true ) , nil };
    local isNoLongerOnServer = false;
    local isFoundInEventLog = false;
    local playerLevel = 0;
    local customNote = "";
    local p , o = "" , "";  -- public/officer Notes
    local mainName = "";
    local standardDate = GRM.ConvertToStandardFormatDate ( dates[1] , dates[2] , dates[3] );

    -- Finding Player's record for removal of current guild and adding to the Left Guild table.
    if player then
        -- Found!
        GRM_G.liveKickedToons[player.name] = {};

        -- Now, let's add their officer/public notes.
        if GRM.S().addNotesToLeft then
            if ( player.note ~= nil and player.note ~= "" ) then
                p = player.note;                
            end
            if ( player.officerNote ~= nil and player.officerNote ~= "" and GRM.CanViewOfficerNote() ) then
                o = player.officerNote;
            end
            if player.customNote[6] ~= "" then
                customNote = player.customNote[6];
            end
        end

        mainName = GRM.GetMainName ( unitName , false );

        if #player.rankHist[1][5] == 1 then
            
            player.rankHist[1][1] = player.rankName;
            player.rankHist[1][2] = dates[1];
            player.rankHist[1][3] = dates[2];
            player.rankHist[1][4] = dates[3];
            player.rankHist[1][5] = standardDate;
            player.rankHist[1][6] = 0
            player.rankHist[1][7] = false;
            player.rankHist[1][8] = 1;
            
        end

        if #player.joinDateHist[1][4] == 1 then
            player.joinDateHist[1][1] = dates[1];
            player.joinDateHist[1][2] = dates[2];
            player.joinDateHist[1][3] = dates[3];
            player.joinDateHist[1][4] = standardDate;
            player.joinDateHist[1][5] = 0
            player.joinDateHist[1][6] = false;
            player.joinDateHist[1][7] = 1;
        end

        table.insert ( player.rankHist , 1 , { player.rankName , dates[1] , dates[2] , dates[3] , standardDate , timeEpoch , true , 3 } );      -- 3 means left guild
        table.insert ( player.joinDateHist , 1 , { dates[1] , dates[2] , dates[3] , standardDate , timeEpoch , true , 2 } );

        -- If not banned, then let's ensure we reset his data.
        if not player.bannedInfo[1] then
            player.bannedInfo[1] = false;
            player.bannedInfo[2] = 0;
            player.bannedInfo[3] = false;
            player.bannedInfo[4] = "";
            player.reasonBanned = "";
        end
        playerLevel = player.level;

        -- Adding to LeftGuild Player history library
        oldMemberData[unitName] = GRM.DeepCopyArray ( player );

        local main , GUID , class = GRM.GetAltGroupMain ( player.altGroup , true );

        -- I don't want to set the main history to be themselves because if they rejoin the guild later, with themselves set as main that could be irrelevant because things change...
        if main ~= "" and main ~= unitName and oldMemberData[unitName] then
            oldMemberData[unitName].mainAtTimeOfLeaving = { main , GUID , class };
        end

        -- Removing it from the alt list
        if GRM.PlayerHasAlts ( player ) then

            -- Let's add them to the end of the report
            local alts = GRM.GetListOfAlts ( player , true );

            for m = 1 , #alts do
                table.insert ( listOfAlts , GRM.GetClassifiedName ( alts[m][1] , true ) );
            end

            if oldMemberData[unitName] then
                oldMemberData[unitName].altsAtTimeOfLeaving = alts;
            end

            GRM.RemoveAlt ( player.name , false , 0 );

            -- Set alt to main if it is only one left.
            if oldMemberData[unitName] and oldMemberData[unitName].isMain and #alts == 1 then
                GRM.SetMain ( alts[1][1], 1 );
            end

            if player.altGroup ~= "" then
            
                GRM_Alts[GRM_G.guildName][player.altGroup] = nil;
                oldMemberData[unitName].altGroup = "";
            end

        elseif player.altGroup ~= "" then
            
            GRM_Alts[GRM_G.guildName][player.altGroup] = nil;
            oldMemberData[unitName].altGroup = "";

        end
        -- removing from active member library
        oldMemberData[unitName].altGroup = "";
        GRM_GuildMemberHistory_Save[GRM_G.guildName][unitName] = nil;
    end
    
    -- Let's get it added to the log
    return unitName , false , timePassed , logEntryMetaData , listOfAlts , mainName , p , o , dates , isFoundInEventLog , isNoLongerOnServer , isLiveDetection , playerLevel , customNote;
end

-- Method:          GRM.IsRejoinAndSetDetails ( table , string , string , bool , array )
-- What it Does:    Checks the left player meta data, to the new player joining, and determins if they are rejoining, and if so, if they were banned
--                  It also manages setting the new officer/public note join date, if player uses said feature.
-- Purpose:         Special feature, scanning for changes, live tracking updates as player joins as well... and compartmentalizing this long function.
GRM.IsRejoinAndSetDetails = function( member , simpleName , tempTimeStamp , liveJoinDetected , tempJoinStorage , logEntryMetaData )
    local oldMemberData = GRM.GetFormerMembers();
    local useTimeStamp = false;
    local timeStamp = "";
    local player;

    tempJoinStorage[5] = false;                 -- is a rejoin
    tempJoinStorage[6] = 0;                     -- Player Level
    tempJoinStorage[7] = "";                    -- The previousName
    tempJoinStorage[8] = 0;                     -- Number of Times in Guild
    tempJoinStorage[9] = false;                 -- IsBanned
    tempJoinStorage[10] = "";                   -- reasonBanned
    tempJoinStorage[11] = "";                   -- date left
    tempJoinStorage[12] = -1;                   -- How Long Ago
    tempJoinStorage[13] = "";                   -- Date originally joined
    tempJoinStorage[14] = {};                   -- Original Rank.
    tempJoinStorage[15] = "";                   -- Custom Notes
    tempJoinStorage[16] = false;                -- Guild transfer - Rejoin

    for formerMember , player in pairs ( oldMemberData ) do -- Number of players that have left the guild
        if type ( player ) == "table" then

            if member.GUID == player.GUID or ( player.isTransfer and member.name == player.name and member.class == player.class ) then  -- GUID comparison check - cannot rely purely on the name.
                tempJoinStorage[5] = true;
                -- MATCH FOUND - Player is RETURNING to the guild!
                -- Player has name-changed?
                if member.name ~= player.name then
                    local classColorString = GRM.GetClassColorRGB ( player.class , true );

                    -- For the logging
                    tempJoinStorage[7] = ( classColorString .. GRM.FormatName ( player.name ) .. "|r" );
                    -- Update the banned player's name
                    player.name = member.name;
                end
                
                -- number of times in the guild
                tempJoinStorage[8] = math.floor ( #player.joinDateHist / 2 ) + ( #player.joinDateHist % 2 );
                
                if tempTimeStamp ~= "" then
                    timeStamp = tempTimeStamp;
                    useTimeStamp = true;
                else
                    timeStamp = select ( 2 , GRM.GetTimestamp() );
                end

                -- Universal Rejoin data whether banned or not
                -- Date player left the guild
                if #player.joinDateHist[1][4] > 1 then
                    
                    tempJoinStorage[11] = GRM.GetTimestampFromTable ( { player.joinDateHist[1][1] , player.joinDateHist[1][2] , player.joinDateHist[1][3] } );
                end

                -- How long ago that was
                if #player.joinDateHist[1][4] > 1 and tempJoinStorage[10] ~= "" then
                    tempJoinStorage[12] = player.joinDateHist[1][4];
                end
                -- Date originally joined the guild the first time ever
                tempJoinStorage[13] = { player.joinDateHist[#player.joinDateHist][1] , player.joinDateHist[#player.joinDateHist][2] , player.joinDateHist[#player.joinDateHist][3] };
                -- Set original Rank
                tempJoinStorage[14] = player.rankHist[1][1]

                -- Set Custom Note details
                if player.customNote[6] ~= "" then
                    tempJoinStorage[15] = player.customNote[6];
                end

                if player.isTransfer then
                    tempJoinStorage[16] = true;
                end

                -- isBanned
                local index = 0;
                if player.bannedInfo[1] then
                    index = 9;
                    tempJoinStorage[9] = true;
                    tempJoinStorage[10] = player.reasonBanned;
                                
                    if not liveJoinDetected then
                        -- Written fully out, not as necessary, but to make the next section easier to work with with specific named arguments rather than 16 indexes of an array
                        GRM.AddBanRejoinEntry ( 
                            tempJoinStorage[1] , tempJoinStorage[2] , tempJoinStorage[3] , tempJoinStorage[4] , tempJoinStorage[5] , tempJoinStorage[6] , tempJoinStorage[7] , tempJoinStorage[8] ,
                            tempJoinStorage[9] , tempJoinStorage[10] , tempJoinStorage[11] , tempJoinStorage[12] , tempJoinStorage[13] , tempJoinStorage[14] , tempJoinStorage[15] , tempJoinStorage[16]
                        );
                    else
                        useTimeStamp = true;
                    end
                else
                    index = 7;
                    -- No Ban found, player just returning!
                    -- Set member level
                    tempJoinStorage[6] = member.level;

                    if not liveJoinDetected then
                        -- Written fully out, not as necessary, but to make the next section easier to work with with specific named arguments rather than 16 indexes of an array
                        GRM.AddNormalRejoinEntry ( 
                            tempJoinStorage[1] , tempJoinStorage[2] , tempJoinStorage[3] , tempJoinStorage[4] , tempJoinStorage[5] , tempJoinStorage[6] , tempJoinStorage[7] , tempJoinStorage[8] ,
                            tempJoinStorage[9] , tempJoinStorage[10] , tempJoinStorage[11] , tempJoinStorage[12] , tempJoinStorage[13] , tempJoinStorage[14] , tempJoinStorage[15] , tempJoinStorage[16]
                        );
                    else
                        useTimeStamp = true;
                    end
                end
                
                -- Needs to be reported immediately rather than waiting.
                if liveJoinDetected then
                    if GRM.S()["toChat"].joined then
                        GRM.PrintLog ( 
                            {
                                index , 
                                select ( 2 , GRM.GetJoinOrRejoinString (
                                    tempJoinStorage[1] , tempJoinStorage[2] , tempJoinStorage[3] , tempJoinStorage[4] , tempJoinStorage[5] , tempJoinStorage[6] , tempJoinStorage[7] , tempJoinStorage[8] ,
                                    tempJoinStorage[9] , tempJoinStorage[10] , tempJoinStorage[11] , tempJoinStorage[12] , tempJoinStorage[13] , tempJoinStorage[14] , tempJoinStorage[15] , tempJoinStorage[16]
                                ) )
                            }
                        );
                    end
                    GRM.AddLog (
                        {
                            index , 
                            GRM.GetJoinOrRejoinString (
                                tempJoinStorage[1] , tempJoinStorage[2] , tempJoinStorage[3] , tempJoinStorage[4] , tempJoinStorage[5] , tempJoinStorage[6] , tempJoinStorage[7] , tempJoinStorage[8] ,
                                tempJoinStorage[9] , tempJoinStorage[10] , tempJoinStorage[11] , tempJoinStorage[12] , tempJoinStorage[13] , tempJoinStorage[14] , tempJoinStorage[15] , tempJoinStorage[16]
                            ), 
                            tempJoinStorage[1] , tempJoinStorage[2] , tempJoinStorage[3] , tempJoinStorage[4] , tempJoinStorage[5] , tempJoinStorage[6] , tempJoinStorage[7] , tempJoinStorage[8] ,
                            tempJoinStorage[9] , tempJoinStorage[10] , tempJoinStorage[11] , tempJoinStorage[12] , tempJoinStorage[13] , tempJoinStorage[14] , tempJoinStorage[15] , tempJoinStorage[16]
                        }
                    );

                end

                -- Adding timestamp to new Player.
                local noteIsSet = false;
                local officerNoteIsSet = false;
                if not player.isTransfer and GRM.S().addTimestampToNote and useTimeStamp then
                    local index;

                    if member.rosterSelection == 0 then
                        
                    else
                        index = member.rosterSelection;
                    end

                    if index ~= nil then
                        local name ,_,_,_,_,_, note , oNote = GetGuildRosterInfo( member.rosterSelection );

                        if name == member.name then
                            local timeS;
                            if not tempJoinStorage[1] then
                                timeS = GRM.FormatTimeStamp ( select ( 2 , GRM.GetTimestamp() ) , false , false , GRM.S().globalDateFormat );
                            else
                                timeS = GRM.FormatTimeStamp ( timeStamp , false , false , GRM.S().globalDateFormat );
                            end
                            
                            local noteDate = "";
                            local tempNote = "";
                            if GRM.S().includeTag then
                                noteDate = GRM_G.customHeaderRejoin .. " " .. timeS;
                            else
                                noteDate = timeS;
                            end

                            if GRM.S().joinDateDestination == 1 then
                                if GRM.CanEditOfficerNote() then

                                    tempNote = noteDate .. " " .. GRM.RemoveDateFromNote ( oNote );
                                    
                                    if oNote == "" or GRM.GetNumLetters ( tempNote ) <= GRM_G.MaxOfficerNoteSize then

                                        officerNoteIsSet = true;
                                        GuildRosterSetOfficerNote( member.rosterSelection , tempNote );

                                        if GRM_G.currentName == member.name then
                                            GRM_UI.GRM_MemberDetailMetaData.GRM_noteFontString2:SetText ( tempNote );
                                            GRM_UI.GRM_MemberDetailMetaData.GRM_PlayerOfficerNoteEditBox:SetText ( tempNote );
                                        end
                                        
                                        if liveJoinDetected then
                                            member.officerNote = tempNote
                                        end
                                        
                                    end
                                end
                            elseif GRM.S().joinDateDestination == 2 then
                                if GRM.CanEditPublicNote() then
                                    tempNote = noteDate .. " " .. GRM.RemoveDateFromNote ( note );
                                    if note == "" or GRM.GetNumLetters ( tempNote ) <= GRM_G.MaxPublicNoteSize then
                                        noteIsSet = true;
                                        GuildRosterSetPublicNote( member.rosterSelection , tempNote );

                                        if GRM_G.currentName == player.name then
                                            GRM_UI.GRM_MemberDetailMetaData.GRM_noteFontString1:SetText ( tempNote );
                                            GRM_UI.GRM_MemberDetailMetaData.GRM_PlayerNoteEditBox:SetText ( tempNote );
                                        end

                                        if liveJoinDetected then
                                            member.note = tempNote
                                        end

                                    end
                                end
                            elseif GRM.S().joinDateDestination == 3 then
                                GRM.SetJoinDateToCustomNote ( player.name , noteDate );
                            end

                        end
                    end

                    -- treat it like restoring the player, not rejoining them.
                    -- Restore their player notes.
                elseif player.isTransfer then
                    local index;
                    if member.rosterSelection == 0 then
                    else
                        index = member.rosterSelection;
                    end

                    if index ~= nil then
                        local name ,_,_,_,_,_, note , oNote = GetGuildRosterInfo( member.rosterSelection );

                        if GRM.CanEditPublicNote() and player.note and player.note ~= "" and player.note ~= note then
                            GuildRosterSetPublicNote( member.rosterSelection , player.note );
                            member.note = player.note;
                        end
                        if GRM.CanEditOfficerNote() and player.officerNote and player.officerNote ~= "" and player.officerNote ~= oNote then
                            GuildRosterSetOfficerNote( member.rosterSelection , player.officerNote );
                            member.officerNote = player.officerNote;
                        end
                    end
                end
                
                -- Make sure to include the officer and public notes if necessary as well for new players
                -- Public note
                if noteIsSet and not liveJoinDetected then
                    -- Add the public note!
                    if member.note ~= "" then
                        GRM.AddNoteTempLogEntry ( GRM.GetClassifiedName ( member.name , true ) , "" , member.note , select ( 2 , GRM.GetTimestamp() ) );
                    end
                end

                -- Officer Note
                if officerNoteIsSet and not liveJoinDetected then
                    -- Add the Officer note!
                    if member.officerNote ~= "" then
                        player.officerNote = member.officerNote;
                    end
                end
                -- Make sure the namechange is adjusted in the database or you will get a double report
                GRM.AddMemberRecord ( member , true , GRM.DeepCopyArray ( player ) , liveJoinDetected , logEntryMetaData , player.isTransfer );

                if liveJoinDetected and GRM.AddRejoinToAltGroup ( GRM.GetPlayer ( member.name ) , player.isTransfer ) then
                    GRM.Report ( GRM.L ( "{name} has rejoined their original alt group." , GRM.GetClassColorRGB ( member.class , true ) .. GRM.FormatName ( member.name ) .. "|r" ) );
                end
                
                -- Removing Player from LeftGuild History (Yes, they will be re-added upon leaving the guild.)
                GRM_PlayersThatLeftHistory_Save[GRM_G.guildName][member.name] = nil;
                local returningPlayer = GRM.GetPlayer ( member.name );

                -- It must be done AFTER the record has been added
                -- Promotion Info
                if not returningPlayer.isTransfer and not liveJoinDetected then
                    if member.rankIndex < ( GuildControlGetNumRanks() - 1 ) then
                        -- Promotion Obtained since joining!
                        local timestamp2 , dateArray = GRM.GetTimestamp();
                        local epochTime = time();
                        local nameOfBaseRank = GuildControlGetRankName( GuildControlGetNumRanks() );
                        local added , logEntryMetaData = GRM.GetGuildEventString ( 2 , member.name , nameOfBaseRank , member.rankName );
                        local dates = {};
                        
                        -- I don't want to have an instance where I have the promotion date in the log but the join date is too old os it has fallen off,
                        -- Thus, if the exact join date cannot be determined, it will set the promotion date to be no different.
                        if useTimeStamp then

                            -- Ok data is saved! Now let's report it to the log...
                            if added then

                                timestamp2 = logEntryMetaData[6][1];

                            else
                                logEntryMetaData = { logEntryMetaData[1] , nil , simpleName , nameOfBaseRank , member.rankName , { dateArray } }; -- Mostly redundant - only need true/false statement in index 1
                            end
                            
                        end

                        returningPlayer.rankName = member.rankName; -- Saving new rank Info
                        returningPlayer.rankIndex = member.rankIndex; -- Saving new rank Index Info

                        dates = GRM.ConvertGenericTimestampToIntValues ( timestamp2 );
                        local isVerified = false;
                        local verifiedEpoch = 0;

                        if added then
                            isVerified = true;
                            verifiedEpoch = epochTime;
                        end

                        if not returningPlayer.rankHist[1][7] then

                            returningPlayer.rankHist[1][1] = returningPlayer.rankName;
                            returningPlayer.rankHist[1][2] = dates[1];
                            returningPlayer.rankHist[1][3] = dates[2];
                            returningPlayer.rankHist[1][4] = dates[3];
                            returningPlayer.rankHist[1][5] = GRM.ConvertToStandardFormatDate ( dates[1] , dates[2] , dates[3] );

                            -- verified or not
                            returningPlayer.rankHist[1][6] = verifiedEpoch
                            returningPlayer.rankHist[1][7] = isVerified;
                            returningPlayer.rankHist[1][8] = 1;

                        else
                            table.insert ( returningPlayer.rankHist , 1 , { returningPlayer.rankName , dates[1] , dates[2] , dates[3] , GRM.ConvertToStandardFormatDate ( dates[1] , dates[2] , dates[3] ) , verifiedEpoch , isVerified , 1 } );
                        end

                        returningPlayer.promoteDateUnknown = false;

                        -- Ok data is saved! Now let's report it to the log...
                        if added then
                            GRM.AddPromotionDateTempLogEntry ( logEntryMetaData[1] , logEntryMetaData[2] , logEntryMetaData[3] , logEntryMetaData[4] , logEntryMetaData[5] , logEntryMetaData[6][3] );
                        else
                            GRM.AddPromotionDateTempLogEntry ( logEntryMetaData[1] , nil , simpleName , nameOfBaseRank , member.rankName , select ( 2 , GRM.GetTimestamp() ) );
                        end
                    elseif returningPlayer.rankHist[1] and returningPlayer.rankHist[1][2] ~= 0 then
                        returningPlayer.rankHist[1][7] = true;
                    end
                end            
                break;
            end
        end
    end

    -- Set the level if not joining.
    if not tempJoinStorage[5] then
        tempJoinStorage[6] = member.level;
    end
    
    return tempJoinStorage[5] , member , simpleName , tempTimeStamp , tempJoinStorage
end

-- Method:          GRM.RecordJoinChanges ( array , string , boolean , array , boolean )
-- What it Does:    Checks and records the new player changes... are they a returning player or completely new. Were they previously banned?
-- Purpose:         Keep the methods clean by compartmentalizing this rather lengthy function. It is also useful to not double the code as this will be called to on a live tracked event.
GRM.RecordJoinChanges = function ( member , simpleName , liveJoinDetected , dateArray )
    -- Check against old member list first to see if returning player!
    local rejoin = false;
    -- Use default dates, since these are auto-tagged, you don't want your data to overwrite any others, so set it as OLD...
    local tempTimeStamp = "";
    local timeStandard = "";
    local added , logEntryMetaData = GRM.GetGuildEventString ( 4 , member.name , nil , nil , member.class , liveJoinDetected ); -- For determining who did the invite.
    local currentTime , dataTable = GRM.GetTimestamp();
    local tempJoinStorage = {};
    local player;

    if added then
        tempTimeStamp = logEntryMetaData[4][1];
        timeStandard = logEntryMetaData[4][2];
        tempJoinStorage = { logEntryMetaData[1] , logEntryMetaData[2] , logEntryMetaData[3] , logEntryMetaData[4][3] };
    else
        tempJoinStorage = { false , nil , simpleName , dateArray };
    end
    
    if not added and liveJoinDetected then
        tempTimeStamp = currentTime;
        timeStandard = GRM.ConvertToStandardFormatDate ( dataTable[1] , dataTable[2] , dataTable[3] );
        added = true;
    end
    -- { isAdded , inviter (nil) , invitedPlayer , { day , month , year , hour } }
    rejoin , member , simpleName , tempTimeStamp , tempJoinStorage  = GRM.IsRejoinAndSetDetails ( member , simpleName , tempTimeStamp , liveJoinDetected , tempJoinStorage , logEntryMetaData )

    if not rejoin then
        -- New Guildie. NOT a rejoin!
        local timeS
        local timeStamp;
        if tempTimeStamp ~= "" then
            timeStamp = tempTimeStamp;
        else
            timeStamp = currentTime;
        end

        if not added then
            timeS = currentTime;
        else
            timeS = timeStamp;
        end

        timeS = GRM.FormatTimeStamp ( timeS , false , false , GRM.S().globalDateFormat );
        local finalTStamp = "";
        local tempNote = "";
        local currentOfficerNote = tostring ( member.officerNote );
        local currentPublicNote = tostring ( member.note );
        local noteIsSet = false;
        local officerNoteIsSet = false;
        if GRM.S().includeTag then
            finalTStamp = GRM_G.customHeaderJoin .. " " .. timeS;
        else
            finalTStamp = timeS;
        end
        
        if added and GRM.S().addTimestampToNote and GRM.S().joinDateDestination < 3 then
            local name ,_,_,_,_,_, note , oNote = GetGuildRosterInfo ( member.rosterSelection );
            if name == member.name then
                if not note then
                    note = "";
                end
                if not oNote then
                    oNote = "";
                end

                if GRM.S().joinDateDestination == 1 then
                    if GRM.CanEditOfficerNote() then
                        tempNote = finalTStamp .. " " .. GRM.RemoveDateFromNote ( oNote );
                        if oNote == "" or GRM.GetNumLetters ( tempNote ) <= GRM_G.MaxOfficerNoteSize then
                            GuildRosterSetOfficerNote ( member.rosterSelection , tempNote );
                            officerNoteIsSet = true
                            if liveJoinDetected then
                                member.officerNote = tempNote;
                            end
                        end
                    end
                elseif GRM.S().joinDateDestination == 2 then
                    if GRM.CanEditPublicNote() then
                        tempNote = finalTStamp .. " " .. GRM.RemoveDateFromNote ( note );
                        if note == "" or GRM.GetNumLetters ( tempNote ) <= GRM_G.MaxPublicNoteSize then
                            GuildRosterSetPublicNote( member.rosterSelection , tempNote );
                            noteIsSet = true;
                            if liveJoinDetected then
                                member.note = tempNote;
                            end
                        end
                    end
                end
                -- Of note, cannot do adding custom note yet here because that relies on them being in the database. Profile needs to be built first which happens in a moment
            end
        end
        -- Adding to global saved array, adding to report 
        GRM.AddMemberRecord ( member , false , nil );

        -- now we can add the custom note
        if added and GRM.S().addTimestampToNote and GRM.S().joinDateDestination == 3 then
            GRM.SetJoinDateToCustomNote ( member.name , finalTStamp );
        end

        if officerNoteIsSet or noteIsSet then
            finalTStamp = tempNote;
        end
        
        if not liveJoinDetected then

            GRM.AddJoinEntry ( tempJoinStorage[1] , tempJoinStorage[2] , tempJoinStorage[3] , tempJoinStorage[4] , tempJoinStorage[5] , tempJoinStorage[6] );
        else

            if GRM.S()["toChat"].joined then
                GRM.PrintLog ( 
                    {
                        8 , 
                        select ( 2 , GRM.GetJoinOrRejoinString (
                            tempJoinStorage[1] , tempJoinStorage[2] , tempJoinStorage[3] , tempJoinStorage[4] , tempJoinStorage[5] , tempJoinStorage[6]
                        ) )
                    }
                );
            end
            GRM.AddLog (
                {
                    8 , 
                    GRM.GetJoinOrRejoinString (
                        tempJoinStorage[1] , tempJoinStorage[2] , tempJoinStorage[3] , tempJoinStorage[4] , tempJoinStorage[5] , tempJoinStorage[6]
                    ) ,
                    tempJoinStorage[1] , tempJoinStorage[2] , tempJoinStorage[3] , tempJoinStorage[4] , tempJoinStorage[5] , tempJoinStorage[6]
                } 
            )
        end

        player = GRM.GetPlayer ( member.name );
        -- adding join date to history and rank date.
        if player then

            -- Add the tempTimeStamp to officer note... this avoids report spam
            -- Promo Date stamp
            if tempTimeStamp ~= "" then
                -- Clear if set to unknown
                player.promoteDateUnknown = false;
                
                -- For Event tracking!
                local date = GRM.ConvertGenericTimestampToIntValues ( timeStamp );
                if timeStandard == nil or timeStandard == "" then
                    timeStandard = GRM.ConvertToStandardFormatDate ( date[1] , date[2] , date[3] );
                end

                if player.joinDateHist[1][3] == 0 then
                    player.joinDateHist[1][1] = date[1];
                    player.joinDateHist[1][2] = date[2];
                    player.joinDateHist[1][3] = date[3];
                    player.joinDateHist[1][4] = timeStandard;
                    player.joinDateHist[1][5] = 0;
                    player.joinDateHist[1][6] = false;
                    player.joinDateHist[1][7] = 1;
                else
                    table.insert ( player.joinDateHist , 1 , { date[1] , date[2] , date[3] , timeStandard , 0 , false , 1 } );               
                end

                player.events[1][1][1] = date[1];
                player.events[1][1][2] = date[2];
                player.events[1][1][3] = date[3];
            else
                -- UNVERIFIED DATA!!!!
                local tStamp = currentTime;

                -- Clear if set to unknown
                player.promoteDateUnknown = false;

                -- For Event tracking!
                local date = GRM.ConvertGenericTimestampToIntValues ( tStamp );

                if player.joinDateHist[1][4] == 3 then
                    player.joinDateHist[1][1] = date[1];
                    player.joinDateHist[1][2] = date[2];
                    player.joinDateHist[1][3] = date[3];
                    player.joinDateHist[1][4] = GRM.ConvertToStandardFormatDate ( date[1] , date[2] , date[3] );
                    player.joinDateHist[1][5] = 0
                    player.joinDateHist[1][6] = false;
                    player.joinDateHist[1][7] = 1;
                else
                    table.insert ( player.joinDateHist , 1 , { date[1] , date[2] , date[3] , GRM.ConvertToStandardFormatDate ( date[1] , date[2] , date[3] ) , 0 , false , 1 } );            
                end
                player.events[1][1][1] = date[1];
                player.events[1][1][2] = date[2];
                player.events[1][1][3] = date[3];
            end
            
            local dateTable = {};

            if added then 
                -- Join Date is Verified
                player.joinDateHist[1][6] = true;
                player.joinDateHist[1][5] = time(); -- verified right now!
                
                dateTable = GRM.ConvertGenericTimestampToIntValues ( tempTimeStamp );
            else
                dateTable = GRM.ConvertGenericTimestampToIntValues ( currentTime );
            end

            -- Promo Date
            if #player.rankHist[1][5] == 1 then
                player.rankHist[1][1] = GuildControlGetRankName( GuildControlGetNumRanks() ); -- Always lowest rank on new join
                player.rankHist[1][2] = dateTable[1];
                player.rankHist[1][3] = dateTable[2];
                player.rankHist[1][4] = dateTable[3];
                player.rankHist[1][5] = GRM.ConvertToStandardFormatDate ( dateTable[1] , dateTable[2] , dateTable[3] );
                player.rankHist[1][6] = time();
                player.rankHist[1][7] = added
                player.rankHist[1][8] = 1;
            else
                table.insert ( player.rankHist , 1 , { GuildControlGetRankName( GuildControlGetNumRanks() ) , dateTable[1] , dateTable[2] , dateTable[3] , timeStandard , time() , true , 1 } );
            end

            if not liveJoinDetected and added then
                if currentOfficerNote == nil or currentOfficerNote == "" then
                    if GRM.S().addTimestampToNote then
                        if GRM.S().joinDateDestination == 1 and GRM.CanEditOfficerNote() and ( player.officerNote == "" or player.officerNote == nil ) then
                            player.officerNote = finalTStamp;
                        elseif GRM.S().joinDateDestination == 2 and GRM.CanEditPublicNote() and ( player.note == "" or player.note == nil ) then
                            player.note = finalTStamp;
                        elseif GRM.S().joinDateDestination == 3 then
                            GRM.SetJoinDateToCustomNote ( member.name , finalTStamp );
                        end
                    end

                elseif currentOfficerNote ~= nil and currentOfficerNote ~= "" then
                    if GRM.S().addTimestampToNote then
                        if GRM.S().joinDateDestination == 1 and GRM.CanEditOfficerNote() and ( player.officerNote == "" or player.officerNote == nil ) then
                            player.officerNote = currentOfficerNote;
                        elseif GRM.S().joinDateDestination == 2 and GRM.CanEditPublicNote() and ( player.note == "" or player.note == nil ) then
                            player.note = currentPublicNote;
                        elseif GRM.S().joinDateDestination == 3 then
                            GRM.SetJoinDateToCustomNote ( member.name , finalTStamp );
                        end
                    end
                end
            end

            -- Let's check the notes
            if added then
                if noteIsSet and not liveJoinDetected and member.note ~= "" then
                    -- Add the public note!
                    GRM.AddNoteTempLogEntry ( GRM.GetClassifiedName ( member.name , true ) , "" , member.note , select ( 2 , GRM.GetTimestamp() ) );

                end
                -- Officer Note
                if officerNoteIsSet and not liveJoinDetected and member.officerNote ~= "" then
                    -- Add the Officer note!
                    GRM.AddOfficerNoteTempLogEntry ( GRM.GetClassifiedName ( member.name , true ) , "" , member.officerNote , select ( 2 , GRM.GetTimestamp() ) );
                end
            end

            -- Promotion Info
            if member.rankIndex < ( GuildControlGetNumRanks() - 1 ) then
                -- Promotion Obtained since joining!
                local timestamp2 = currentTime;
                local epochTime = time();
                local nameOfBaseRank = GuildControlGetRankName( GuildControlGetNumRanks() );
                local added , logEntryMetaData = GRM.GetGuildEventString ( 2 , member.name , nameOfBaseRank , member.rankName , liveJoinDetected );

                -- I don't want to have an instance where I have the promotion date in the log but the join date is too old os it has fallen off,
                -- Thus, if the exact join date cannot be determined, it will set the promotion date to be no different.

                if added then
                    timestamp2 = logEntryMetaData[6][1];    -- New timestamp based on guild event log
                end

                -- Clear if set to unknown
                player.promoteDateUnknown = false;

                -- For SYNC
                local dates = GRM.ConvertGenericTimestampToIntValues ( timestamp2 );

                if #player.rankHist[1][5] == 1 then

                    player.rankHist[1][1] = member.rankName;
                    player.rankHist[1][2] = dates[1];
                    player.rankHist[1][3] = dates[2];
                    player.rankHist[1][4] = dates[3];
                    player.rankHist[1][5] = GRM.ConvertToStandardFormatDate ( dates[1] , dates[2] , dates[3] );
                    player.rankHist[1][6] = epochTime;
                    player.rankHist[1][7] = added;
                    player.rankHist[1][8] = 1;

                else

                    if not player.rankHist[1][7] then
                        player.rankHist[1][7] = true;
                    end

                    table.insert ( player.rankHist , 1 , { player.rankName , dates[1] , dates[2] , dates[3] , GRM.ConvertToStandardFormatDate ( dates[1] , dates[2] , dates[3] ) , epochTime , added , 1 } );
                end
                
                
                player.rankName = member.rankName; -- Saving new rank Info
                player.rankIndex = member.rankIndex; -- Saving new rank Index Info
                
                -- Ok data is saved! Now let's report it to the log...
                
                if logEntryMetaData[1] then
                    GRM.AddPromotionDateTempLogEntry ( logEntryMetaData[1] , logEntryMetaData[2] , logEntryMetaData[3] , logEntryMetaData[4] , logEntryMetaData[5] , logEntryMetaData[6][3] );
                else
                    GRM.AddPromotionDateTempLogEntry ( logEntryMetaData[1] , nil , GRM.GetClassifiedName ( member.name , true ) , nameOfBaseRank , member.rankName , dateArray );
                end
            end
        end
    end

    -- This happened live and is 100% verified
    player = GRM.GetPlayer ( member.name );
    if liveJoinDetected and player then

        local tStamp = GRM.DeepCopyArray ( player.joinDateHist[1] );
        player.joinDateHist[1][5] = tonumber ( tStamp[5] );
        player.joinDateHist[1][6] = true;
        player.rankHist[1][6] = tonumber ( tStamp[5] );
        player.rankHist[1][7] = true;

    end

    -- Live detection it refreshes the logs, not on first scan check on logon.
    if liveJoinDetected then
        GRM.RefreshSelectHybridFrames ( true , true , true , true );
    end
end

-- Method:          GRM.RecordCustomNoteChanges ( string , string , string , boolean )
-- What it Does:    Reports the Custom note changes to the Guild Log
-- Purpose:         For ease of reporting to the log, as a UI feature.
GRM.RecordCustomNoteChanges = function( newNote , oldNote , editorName , editedName , rebuildLog )
    -- Remove the linebreaks in the log reporting or it will be spammy. Replace with a dash
    local nNote = string.gsub ( newNote , "\n" , "-" );
    local oNote = string.gsub ( oldNote , "\n" , "-" );

    local logReportWithTime , logReport = GRM.GetCustomNoteChangeString ( nNote , oNote , GRM.GetClassifiedName ( editorName , true ) , GRM.GetClassifiedName ( editedName , true ) , select ( 2 , GRM.GetTimestamp() ) );
    -- Ok that to the log...
    if rebuildLog and GRM.S()["toChat"].customNote then
        GRM.PrintLog ( { 19 , logReport } );
    end

    GRM.AddLog ( { 19 , logReportWithTime , nNote , oNote , GRM.GetClassifiedName ( editorName , true ) , GRM.GetClassifiedName ( editedName , true ) , select ( 2 , GRM.GetTimestamp() ) } );
    if rebuildLog and GRM_UI.GRM_RosterChangeLogFrame:IsVisible() and GRM.S().toLog.customNote then
        GRM_G.LogNumbersColorUpdate = true;
        GRM.BuildLogComplete( true , true );
    end

    if GRM_UI.GRM_MemberDetailMetaData:IsVisible() and editedName == GRM_G.currentName and GRM_UI.GRM_MemberDetailMetaData.GRM_ConfirmCustomNoteButton:IsVisible() then
        GRM_UI.GRM_MemberDetailMetaData.GRM_ConfirmCustomNoteButton:Hide();
        GRM_UI.GRM_MemberDetailMetaData.GRM_CancelCustomNoteButton:Hide();
        GRM_UI.GRM_MemberDetailMetaData.GRM_CustomNoteEditBoxFrame.GRM_CustomNoteEditBox:SetText ( GRM_G.OriginalEditBoxValue );
        GRM_UI.GRM_MemberDetailMetaData.GRM_CustomNoteEditBoxFrame.GRM_CustomNoteEditBox:ClearFocus();
        GRM_UI.GRM_MemberDetailMetaData.GRM_CustomNoteEditBoxFrame.GRM_CustomNoteTextCount:Hide();
        
        if GRM_G.currentName ~= GRM_G.addonUser then
            GRM_UI.GRM_MemberDetailMetaData.GRM_SafeFromRulesButton:Show();

            local player = GRM.GetPlayer ( GRM_G.currentName );
            if player then
                if player.isOnline then
                    GRM.SetGroupInviteButton ( GRM_G.currentName );
                    GRM_UI.GRM_MemberDetailMetaData.GRM_GroupInviteButton:Show();
                end
            end
        end
        
        GRM.BuildCustomNoteScrollFrame ( GRM_G.OriginalEditBoxValue );
        if GRM_UI.GRM_MemberDetailMetaData.GRM_DateSubmitButton:IsVisible() ~= true then            -- Does not unpause if the date still needs to be selected or canceled.
            GRM_UI.Unpause();
        end
    end
end

-- Method:          GRM.SetCustomNote();
-- What it Does:    Modifies the custom note to new one, if necessary and sends proper updates and comms
-- Purpose:         Reduce a bit of code bloat. Make the UI functions of the editbox more readable.
GRM.SetCustomNote = function()
    local player = GRM.GetPlayer ( GRM_G.currentName );
    if player then
        -- The trim is so that just a white space doesn't somehow count as a new note.
        if GRM.Trim ( GRM_UI.GRM_MemberDetailMetaData.GRM_CustomNoteEditBoxFrame.GRM_CustomNoteEditBox:GetText() ) ~= player.customNote[6] then
            local oldNote = player.customNote[6];
            player.customNote[2] = time();
            player.customNote[3] = GRM_G.addonUser;
            player.customNote[6] = GRM.Trim ( GRM_UI.GRM_MemberDetailMetaData.GRM_CustomNoteEditBoxFrame.GRM_CustomNoteEditBox:GetText() );
            GRM_G.OriginalEditBoxValue = player.customNote[6];  -- This needs to be set to handle the OnEditFocusLost logic..
            -- Handle Log reporting logic here...

            GRM.RecordCustomNoteChanges ( player.customNote[6] , oldNote , GRM_G.addonUser , player.name , true )

            -- Handle live sync SendMessage here...
            if GRM.S().syncEnabled and GRM.S().syncRankCustom and player.customNote[1] then
                local tempMsg = GRM_G.PatchDayString .. "?GRM_CNOTE?" .. GRM.S().syncRankCustom .. "?" .. player.customNote[4] .. "?#"  .. player.name .. "?#" .. tostring ( player.customNote[2] );
                local customNote = "";
                if #player.customNote[6] > 0 then
                    customNote = player.customNote[6];
                else
                    customNote = "X&&X";
                end
                -- Check size... if need to split
                if ( #tempMsg + #customNote + GRMsyncGlobals.sizeModifier ) > 254 then
                    -- size is too big! let's split it!
                    GRMsync.SendMessage ( "GRM_SYNC" , GRM_G.PatchDayString .. "?GRM_CNOTE?" .. GRM.S().syncRankCustom .. "?" .. string.sub ( customNote , #customNote - 49 ) .. "&X&" , "GUILD" );
                    -- now we send all the data in followup...
                    GRMsync.SendMessage ( "GRM_SYNC" , tempMsg .. "?#" .. string.sub ( customNote , 1 , #customNote - 50 ) .. "&X&" , "GUILD" );
                else
                    GRMsync.SendMessage ( "GRM_SYNC" , tempMsg  .. "?#" .. customNote , "GUILD" );
                end
            end
        end

        if GRM.Trim ( GRM_UI.GRM_MemberDetailMetaData.GRM_CustomNoteEditBoxFrame.GRM_CustomNoteEditBox:GetText() ) == "" then
            GRM_UI.GRM_MemberDetailMetaData.GRM_CustomNoteEditBoxFrame.GRM_CustomNoteEditBox:SetText ( GRM.L ( "Click here to set Custom Notes" ) );
            GRM_G.OriginalEditBoxValue = GRM.L ( "Click here to set Custom Notes" );
        else
            GRM_UI.GRM_MemberDetailMetaData.GRM_CustomNoteEditBoxFrame.GRM_CustomNoteEditBox:SetText ( player.customNote[6] );
        end

    end
    GRM_UI.GRM_MemberDetailMetaData.GRM_CustomNoteEditBoxFrame.GRM_CustomNoteEditBox:ClearFocus();
end

-- Method:          GRM.SetJoinDateToCustomNote ( string , string )
-- What it Does:    Checks to see if new note can merge with old custom note and be less than or equal to 150 characters. If not, it does nothing
-- Purpose:         To allow the player to auto update the join date to the custom note window.
GRM.SetJoinDateToCustomNote = function( playerName , noteToSet )
    local player = GRM.GetPlayer ( playerName );

    if not player then
        player = GRM.GetFormerPlayer (playerName);
        if not player then
            return;
        end 
    end

    local newNote = noteToSet;
    local oldNote = player.customNote[6];
    local goodToSet = false;
    -- Check note size...
    if oldNote == "" then
        goodToSet = true;
    else
        if string.find ( oldNote , newNote , 1 , true ) == nil then  -- No need to merge if note already there
            newNote = newNote .. "\n" .. GRM.RemoveDateFromNote ( oldNote );   -- Ok, merged the notes...
            if GRM.GetNumLetters ( newNote ) <= GRM_G.MaxCustomNoteSize then
                goodToSet = true;
            end
        end
    end
    -- Update it, report it!
    if goodToSet then
        player.customNote[2] = time();
        player.customNote[3] = playerName;
        player.customNote[6] = newNote;
        GRM.RecordCustomNoteChanges ( newNote , oldNote , GRM_G.addonUser , playerName , true )
        -- Update the note live!
        if GRM_G.currentName == playerName then
            GRM_UI.GRM_MemberDetailMetaData.GRM_CustomNoteEditBoxFrame.GRM_CustomNoteEditBox:SetText ( newNote );
        end
    end
end

-- Method:          GRM.IsAnyCustomNoteLarge()
-- What it Does:    Returns true if at least one guildie as a custom note > 100
-- Purpose:         Adjust the throttle cap.
GRM.IsAnyCustomNoteLarge = function()
    local result = false;
    local guildData = GRM.GetGuild();

    for _ , player in pairs ( guildData ) do
        if type ( player ) == "table" then
            if #player.customNote[6] > 99 then
                result = true;
                break;
            end
        end
    end
    return result;
end

-- Method:          GRM.ScanKillSwitch()
-- What it Does:    In case you quit a guild in the middle of a scan, this will purge it.
GRM.ScanKillSwitch = function()
    if GRM_G.changeHappenedExitScan or not IsInGuild() then
        GRM.ResetTempLogs();
        GRM_G.changeHappenedExitScan = false;
        GRM_G.CurrentlyScanning = false;
        GRM_G.OnFirstLoad = false;
        GRM_G.numRanksHasChanged = false;
        GRM_G.rankChangeShift = 0;
        return true;
    else
        return false;
    end
end

-- Method           GRM.RecordChanges( int , table , table )
-- What it does:    Builds all the changes, sorts them, then adds them to change report
-- Purpose:         Consolidation of data for final output report.
GRM.RecordChanges = function ( indexOfInfo , member , memberOldInfo , logEntryMetaData , dateArray )

    if GRM.ScanKillSwitch() then   -- Necessary in case you purge guild in middle of scan
        return;
    end

    local simpleName = "";
    if type ( member ) == "string" then
        simpleName = GRM.GetStringClassColorByName ( member ) .. GRM.SlimName ( member ) .. "|r";
    elseif indexOfInfo ~= 10 then
        simpleName = GRM.GetStringClassColorByName ( member.name ) .. GRM.SlimName ( member.name ) .. "|r";
    else
        simpleName = GRM.GetClassColorRGB ( member.class , true ) .. GRM.SlimName ( member.name ) .. "|r";
    end

    -- 2 = Guild Rank Promotion
    if indexOfInfo == 2 then
        local goodToAdd = true;
        if logEntryMetaData[1] then

            -- Ok, ranks are same name - does this mean the rank itself has shifted, or that there are ranks with the same name?
            -- Well, let's see if there are 2 ranks the same name..
            if logEntryMetaData[4] == logEntryMetaData[5] then
                local c = 0;
                for i = 1 ,  GuildControlGetNumRanks() do
                    if GuildControlGetRankName ( i ) == logEntryMetaData[4] then
                        c = c + 1;
                    end
                end

                if c == 1 then
                    goodToAdd = false;
                end
            end
            if goodToAdd then
                GRM.AddPromotionDateTempLogEntry ( logEntryMetaData[1] , logEntryMetaData[2] , logEntryMetaData[3] , logEntryMetaData[4] , logEntryMetaData[5] , logEntryMetaData[6][3] );
            end
        else
            if memberOldInfo.rankName == member.rankName then
                local c = 0;
                for i = 1 ,  GuildControlGetNumRanks() do
                    if GuildControlGetRankName ( i ) == memberOldInfo.rankName then
                        c = c + 1;
                    end
                end

                if c == 1 then
                    goodToAdd = false;      -- This means there aren't multiple of same rank
                end
            end


            if goodToAdd then
                GRM.AddPromotionDateTempLogEntry ( logEntryMetaData[1] , nil , simpleName , memberOldInfo.rankName , member.rankName , dateArray );
            end
        end

    -- 9 = Guild Rank Demotion
    elseif indexOfInfo == 9 then

        local goodToAdd = true;
        if logEntryMetaData[1] then

            -- Ok, ranks are same name - does this mean the rank itself has shifted, or that there are ranks with the same name?
            -- Well, let's see if there are 2 ranks the same name..
            if logEntryMetaData[4] == logEntryMetaData[5] then
                local c = 0;
                for i = 1 ,  GuildControlGetNumRanks() do
                    if GuildControlGetRankName ( i ) == logEntryMetaData[4] then
                        c = c + 1;
                    end
                end

                if c == 1 then
                    goodToAdd = false;
                end
            end

            if goodToAdd then
                GRM.AddDemotionDateTempLogEntry ( logEntryMetaData[1] , logEntryMetaData[2] , logEntryMetaData[3] , logEntryMetaData[4] , logEntryMetaData[5] , logEntryMetaData[6][3] );
            end
        else
            if memberOldInfo.rankName == member.rankName then
                local c = 0;
                for i = 1 ,  GuildControlGetNumRanks() do
                    if GuildControlGetRankName ( i ) == memberOldInfo.rankName then
                        c = c + 1;
                    end
                end

                if c == 1 then
                    goodToAdd = false;
                end
            end

            if goodToAdd then
                GRM.AddDemotionDateTempLogEntry ( logEntryMetaData[1] , nil , simpleName , memberOldInfo.rankName , member.rankName , dateArray );
            end
        end

    -- 4 = level
    elseif indexOfInfo == 4 then
        GRM.AddLeveledTempLogEntry ( simpleName , logEntryMetaData , member.level , ( member.level - memberOldInfo.level ) , dateArray , ( member.level == GRM_G.LvlCap ) , member.name );

    -- 5 = note
    elseif indexOfInfo == 5 then
        GRM.AddNoteTempLogEntry ( simpleName , memberOldInfo.note , member.note , dateArray )
    -- 6 = officerNote
    elseif indexOfInfo == 6 then
        GRM.AddOfficerNoteTempLogEntry ( simpleName , memberOldInfo.officerNote , member.officerNote , dateArray );

        -- 8 = Guild Rank Name Changed to something else
    elseif indexOfInfo == 8 then
        GRM.AddRankRenameEntry ( nil , memberOldInfo.rankName , member.rankName , dateArray );

    -- 10 = New Player
    elseif indexOfInfo == 10 then
        -- Check against old member list first to see if returning player!
        GRM.RecordJoinChanges ( member , simpleName , false , dateArray );

    -- 11 = Player Left  
    elseif indexOfInfo == 11 then
        table.insert ( GRM_G.TempLeftGuildPlaceholder , { member.name , simpleName , false , dateArray } );

    -- 12 = NameChanged
    elseif indexOfInfo == 12 then
        local colorHex = GRM.GetClassColorRGB ( memberOldInfo.class , true );
        GRM.AddNameChangeTempLogEntry ( ( colorHex .. simpleName .. "|r" ) , ( colorHex .. GRM.SlimName (  memberOldInfo.name ) .. "|r" ) , dateArray );

    -- 13 = Inactive Members Return!
    elseif indexOfInfo == 13 then
        GRM.AddInactiveReturnTempLogEntry ( simpleName , GRM.HoursReport ( memberOldInfo ) , dateArray );

    elseif indexOfInfo == 14 then
        GRM.AddHardcoreDeathEntry ( member.name , member.class , member.level , dateArray );
    end
end

-- Method:          GRM.AddonPlayerRankChange ( index )
-- What it Does:    If the player's rank is changed, it does a re-check on permissions and sets up sync again.
-- purpose:         Need to update personal details immediately so sync can be processed.
GRM.AddonPlayerRankChange = function( newRankIndex )

    local needsUpdate = false;
    if newRankIndex ~= GRM_G.playerRankID then
        needsUpdate = true;
    end

    GRM_G.playerRankID = newRankIndex;

    if GRM_UI.GRM_RosterChangeLogFrame:IsVisible() then
        GRM_UI.BuildLogFrames();
    end
    
    -- Determine if player has access to guild chat or is in restricted chat rank - need to recheck with rank change.
    GRM_G.HasAccessToOfficerChat = false;
    GRM.RegisterGuildChatPermission();

    if GRM_UI.GRM_ToolCoreFrame ~= nil and GRM_UI.GRM_ToolCoreFrame:IsVisible() then
        if needsUpdate then
            GRM.Report ( GRM.L ( "GRM:" ) .. " " .. GRM.L ( "Player rank change detected, re-checking permissions and rebuilding GRM Macro Tool." ) );
        end
        GRM_UI.RefreshManagementTool();
    end

    -- Let's do a resync check as well... If permissions have changed, we should resync check em.
    -- First, RESET all..
    if needsUpdate and GRM.S().syncEnabled and not GRMsyncGlobals.currentlySyncing and GRM_G.HasAccessToGuildChat and not GRM_G.OnFirstLoad then
        if GRMsync.IsPlayerDataSyncCompatibleWithAnyOnline() then
            GRMsync.TriggerFullReset();
            GRM.Report ( GRM.L ( "GRM:" ) .. " " .. GRM.L ( "Your rank has changed. Re-evaluating sync permissions." ) );
            C_Timer.After ( 3 , GRMsync.Initialize ); -- Now, let's add a brief delay, 3 seconds, to trigger sync again
        end
    end
end

-- Method:          GRM.CheckForDeadAccounts( bool )
-- What it Does:    Scans the roster for dead account names and then gives you the option to kick them
-- Purpose:         Quality of life feature for maintenance reasons of a roster.
GRM.CheckForDeadAccounts = function ( isManual )
    GRM_G.customKickList = {};
    local hours = 4320; -- Equals 180 days - presumably someone with account deleted. This is just a buffer because sometimes names get flagged for rename for TOS violation but are still active.
    local ind = 0;

    for _ , player in pairs ( GRM.GetGuild() ) do
        if type ( player ) == "table" then
            if ( not player.deadNameIgnore or isManual ) and player.lastOnline >= hours and string.match ( GRM.SlimName ( player.name ) , "%d" ) ~= nil then  -- Needs to just be first name because servers may have numbers in them, like Area52, but the player name cannot.

                table.insert ( GRM_G.customKickList , { player.name } );
                ind = #GRM_G.customKickList;
                GRM_G.customKickList[ind].name = player.name;
                GRM_G.customKickList[ind].class = GRM.GetClassColorRGB ( player.class );
                GRM_G.customKickList[ind].lastOnline = player.lastOnline;
                GRM_G.customKickList[ind].action = GRM.L ( "Kick" );
                GRM_G.customKickList[ind].macro = "/gremove";
                GRM_G.customKickList[ind].isHighlighted = false;
                GRM_G.customKickList[ind].mainName = GRM.GetMainName ( player , true );
                GRM_G.customKickList[ind].customMsg = GRM.L ( "Dead Account" );
                GRM_G.customKickList[ind].isMain = false;
                GRM_G.customKickList[ind].isAlt = false;
                GRM_G.customKickList[ind].tab = false;
                
            end
        end
    end
    
    if #GRM_G.customKickList > 0 then
        sort ( GRM_G.customKickList , function ( a , b ) return a[1] < b[1] end );

        local kickDeadNames = function()
            GRM_UI.GRM_ToolCoreFrame.GRM_KickTab:Click();
            GRM_UI.GRM_ToolCoreFrame.TabPosition = 1;
            GRM_G.customKickGroup = true;
            if not GRM_UI.GRM_ToolCoreFrame or ( GRM_UI.GRM_ToolCoreFrame and not GRM_UI.GRM_ToolCoreFrame:IsVisible() ) then
                GRM_UI.GRM_ToolCoreFrame:Show();
                
            elseif GRM_UI.GRM_ToolCoreFrame:IsVisible() then
                GRM_UI.RefreshManagementTool( false , false , true );

            end
        end

        local ignoreDeadNames = function()

            local player;
            for i = 1 , #GRM_G.customKickList do
                player = GRM.GetPlayer ( GRM_G.customKickList[i].name );
                if player then
                    player.deadNameIgnore = true;
                end
            end
            
            GRM.Report ( GRM.L ( "You can re-check in the future by typing '/grm dead'" ) );
        end

        local numDeadMsg = "";
        if #GRM_G.customKickList > 1 then
            numDeadMsg = GRM.L ( "There are {num} players in your guild on dead accounts."  , nil , nil , #GRM_G.customKickList ) .. " " .. GRM.L ( "Would you like to remove them?" );
        else
            numDeadMsg = GRM.L ( "There is 1 player in your guild on a dead account." ) .. " " .. GRM.L ( "Would you like to remove them?" );
        end

        GRM.SetConfirmationWindow ( kickDeadNames , numDeadMsg .. "\n\n" .. GRM.L (  "Click CONFIRM to review the names, IGNORE to remove this pop-up permanently, or CANCEL to be reminded next session." ) , ignoreDeadNames , { 320 , 140 } )

    end

end

-- Method:          GRM.CheckLogChanges ( table , table , string  )
-- What it Does:    Checks the player changes that can be cross-referenced from the log
-- Purpose:         Compartmentalize the scan   
GRM.CheckLogChanges = function ( updatedPlayer , player , rosterName )
    if updatedPlayer.rankIndex ~= player.rankIndex then -- This checks to see if guild just changed the name of a rank.

        local added = false;
        local timestamp , dateArray = GRM.GetTimestamp();
        local epochTime = time();
        local logEntryroster = {};
        local rankShift = false;
        local needsUpdate = false;

        if GRM_G.numRanksHasChanged then

            if updatedPlayer.rankIndex == ( player.rankIndex + GRM_G.rankChangeShift ) then -- number of ranks added or removed - shift up or down.
            -- Adjust new rank index - make rank change good.
                if updatedPlayer.rankName == player.rankName then
                    player.rankIndex = updatedPlayer.rankIndex; -- Saving new rank Index Info
                    rankShift = true;
                    -- No need to ad
                end
            end
        end

        -- Promotion Obtained
        if updatedPlayer.rankIndex < player.rankIndex then

            if not GRM_G.livePromotedToons[updatedPlayer.name] then
                needsUpdate = true;
                
                added , logEntryroster = GRM.GetGuildEventString ( 2 , updatedPlayer.name , player.rankName , updatedPlayer.rankName , nil , false );
                if added then
                    timestamp = logEntryroster[6][1];
                    dateArray = logEntryroster[6][3];
                end
                GRM.RecordChanges ( 2 , updatedPlayer , player , logEntryroster , dateArray );

            end
            
        -- Demotion Obtained
        elseif updatedPlayer.rankIndex > player.rankIndex then

            if not GRM_G.livePromotedToons[updatedPlayer.name] then
                needsUpdate = true;
                added , logEntryroster = GRM.GetGuildEventString ( 1 , updatedPlayer.name , player.rankName , updatedPlayer.rankName , nil , false );
                if added then
                    timestamp = logEntryroster[6][1];
                    dateArray = logEntryroster[6][3];
                end
                
                if updatedPlayer.rankName ~= player.rankName then
                    GRM.RecordChanges ( 9 , updatedPlayer , player , logEntryroster , dateArray );
                end
            end
        end
        
        if needsUpdate then

            player.rankName = updatedPlayer.rankName; -- Saving new rank Info
            player.rankIndex = updatedPlayer.rankIndex; -- Saving new rank Index Info

            -- Clear if set to unknown
            player.promoteDateUnknown = false;

            -- For SYNC
            local isVerified = false;
            local verifiedTime = 0;
            local dates , standardTime;
            
            if added then
                dates = { logEntryroster[6][3][1] , logEntryroster[6][3][2] , logEntryroster[6][3][3] };
            else
                dates = GRM.ConvertGenericTimestampToIntValues ( timestamp );
            end

            standardTime = GRM.ConvertToStandardFormatDate ( dates[1] , dates[2] , dates[3] );

            if added then
                isVerified = true;
                verifiedTime = epochTime;
            end

            if not rankShift then
                if #player.rankHist[1][5] == 1 then

                    player.rankHist[1][1] = player.rankName;
                    player.rankHist[1][2] = dates[1];
                    player.rankHist[1][3] = dates[2];
                    player.rankHist[1][4] = dates[3];
                    player.rankHist[1][5] = standardTime;
                    player.rankHist[1][6] = verifiedTime
                    player.rankHist[1][7] = isVerified;
                    player.rankHist[1][8] = 1;

                else
                    table.insert ( player.rankHist , 1 , { player.rankName , dates[1] , dates[2] , dates[3] , standardTime , verifiedTime , isVerified , 1 } );
                end
                
                -- Update the player index if it is the player themselves that received the change in rank.
                if updatedPlayer.name == GRM_G.addonUser then
                    GRM.AddonPlayerRankChange ( updatedPlayer.rankIndex );
                end
            end
        end

    elseif updatedPlayer.rankName ~= player.rankName and updatedPlayer.rankIndex == player.rankIndex then

        player.rankName = updatedPlayer.rankName; -- Saving new Info
        if #player.rankHist[1][5] > 0 then
            player.rankHist[1][1] = updatedPlayer.rankName;   -- Adjusting the historical name if 
            -- We are just renaming the rank in the history - nothing else.
        end

    elseif GRM_G.livePromotedToons[updatedPlayer.name] or GRM_G.liveDemotedToons[updatedPlayer.name] then

        -- Rank is the same now, let's remove them from promote or demote list.
        GRM_G.livePromotedToons[updatedPlayer.name] = nil;
        GRM_G.liveDemotedToons[updatedPlayer.name] = nil;

    end
end

-- Method:          GRM.CheckRosterChanges ( table , table , string )
-- What it Does:    Checks the player changes that are found by scanning roster, that are not in Guild Event Log
-- Purpose:         Compartmentalize the scanning for efficiency.
GRM.CheckRosterChanges = function ( updatedPlayer , player , rosterName )
    -- Level
    if updatedPlayer.level ~= player.level then
        if updatedPlayer.level > player.level and GRM.S().recordLevelUp then
            local needsToRecord = false;
            local mileStones = { 10 , 20 , 30 , 40 , 50 };
            local level = 0;

            if GRM.S().levelReportMin <= updatedPlayer.level then
                needsToRecord = true
            else
                for i = ( #mileStones ) , 1 , -1 do
                    if updatedPlayer.level >= mileStones[i] and GRM.S().levelFilters[i] and player.level < mileStones[i] then
                        needsToRecord = true;
                        level = mileStones[i];
                        break;
                    end
                end
            end
            if needsToRecord then
                GRM.RecordChanges ( 4 , updatedPlayer , player , level , select ( 2 , GRM.GetTimestamp() ) );
            end
        end
        player.level = updatedPlayer.level; -- Saving new Info
    end

    -- Check if we have the [D] tag and if relevant.
    if GRM_G.HardcoreActive and not player.HC.isDead and updatedPlayer.note:find ( "%[" .. GRM.L ( "D" ) .. "%]" ) then
        local time = updatedPlayer.note:match ( "%[" .. GRM.L ( "D" ) .. "%]%-(%d%d%d%d%d%d%d%d)" );
        local day, month , year;
        local dateArray = select ( 2 , GRM.GetTimestamp() );
        dateArray[6] = false;

        if time and tonumber ( time ) ~= nil then
            day , month , year = GRM.ParseStandardFormatDate ( time );
            if day ~= "" then
                dateArray[1] = day;
                dateArray[2] = month;
                dateArray[3] = year;
                player.HC.timeOfDeath[6] = true
                dateArray[6] = true;
            end
        end

        -- Ok, set death status
        player.HC.isDead = true;
        player.HC.timeOfDeath[1] = dateArray[1];
        player.HC.timeOfDeath[2] = dateArray[2];
        player.HC.timeOfDeath[3] = dateArray[3];
        player.HC.timeOfDeath[4] = dateArray[4];
        player.HC.timeOfDeath[5] = dateArray[5];

        GRM.RecordChanges ( 14 , updatedPlayer , nil , nil , dateArray )
    end

    -- Note
    if updatedPlayer.note ~= player.note then
        -- Let's first compare the notes... make sure they are not the same
        local isDifferent = true;
        local newNote , oldNote = "" , "";

        if GetCVar("profanityFilter") == "1" then                               -- The profanity filter is on!
            newNote = GRM.NormalizeMatureWords ( updatedPlayer.note );
            oldNote = GRM.NormalizeMatureWords ( player.note );
        else
            newNote = updatedPlayer.note;
            oldNote = player.note;
        end

        if newNote == oldNote then
            isDifferent = false;
        end

        if isDifferent then
            GRM.RecordChanges ( 5 , updatedPlayer , player , nil , select ( 2 , GRM.GetTimestamp() ) );
            player.note = updatedPlayer.note;
            -- Update metaframe
            if GRM_UI.GRM_MemberDetailroster ~= nil and GRM_UI.GRM_MemberDetailroster:IsVisible() and GRM_G.currentName == updatedPlayer.name then
                if updatedPlayer.note == "" then
                    if ( GRM.CanEditPublicNote() or ( GRM_G.BuildVersion >= 80000 and GRM_G.currentName == GRM_G.addonUser ) ) then
                        GRM_UI.GRM_MemberDetailroster[rosterName].GRM_noteFontString1:SetText ( GRM.L ( "Click here to set a Public Note" ) );
                    else
                        GRM_UI.GRM_MemberDetailroster[rosterName].GRM_noteFontString1:SetText ( GRM.L ( "Unable to Edit Public Note at Rank" ) );
                    end
                else
                    GRM_UI.GRM_MemberDetailroster[rosterName].GRM_noteFontString1:SetText ( updatedPlayer.note );
                end
                GRM_UI.GRM_MemberDetailroster[rosterName].GRM_PlayerNoteEditBox:SetText ( updatedPlayer.note );
            end
        end
    end

    -- Officer Note
    if updatedPlayer.officerNote ~= player.officerNote and GRM.CanViewOfficerNote() then
        if updatedPlayer.officerNote == nil or player.officerNote == nil then
            player.officerNote = updatedPlayer.officerNote;
        else
            local isDifferent = true;
            local newNote , oldNote = "" , "";

            if GetCVar("profanityFilter") == "1" then                               -- The profanity filter is on!
                newNote = GRM.NormalizeMatureWords ( updatedPlayer.officerNote );
                oldNote = GRM.NormalizeMatureWords ( player.officerNote );
            else
                newNote = updatedPlayer.officerNote;
                oldNote = player.officerNote;
            end

            if newNote == oldNote then
                isDifferent = false;
            end

            if isDifferent then
                -- Guild Leader! Let's check their officer note for changes for settings!
                GRM.RecordChanges ( 6 , updatedPlayer , player , nil , select ( 2 , GRM.GetTimestamp() ) );
                player.officerNote = updatedPlayer.officerNote;
            end
        end
        if GRM_UI.GRM_MemberDetailroster ~= nil and GRM_UI.GRM_MemberDetailroster:IsVisible() and GRM_G.currentName == updatedPlayer.name then
            if updatedPlayer.officerNote == "" then
                if GRM.CanEditOfficerNote() then
                    GRM_UI.GRM_MemberDetailroster[rosterName].GRM_noteFontString2:SetText ( GRM.L ( "Click here to set an Officer's Note" ) );
                else
                    GRM_UI.GRM_MemberDetailroster[rosterName].GRM_noteFontString2:SetText ( GRM.L ( "Unable to Edit Officer Note at Rank" ) );
                end
            else
                GRM_UI.GRM_MemberDetailroster[rosterName].GRM_noteFontString2:SetText ( updatedPlayer.officerNote );
            end
            GRM_UI.GRM_MemberDetailroster[rosterName].GRM_PlayerOfficerNoteEditBox:SetText (  updatedPlayer.officerNote );
        end
    end

    -- Class Change - fix error or future class change redundancy if they ever implemented
    if updatedPlayer.class ~= player.class then
        player.class = updatedPlayer.class;
        -- TO DO IF EVER IMPLEMENTED
        -- UPDATE THE ALT INFO CLASS AS WELL IF NEED TO CHANGE.
    end

-- Recommendations for Offline Kicks
    if updatedPlayer.lastOnline ~= -1 then

        -- Report inactive returns
        if GRM.S().reportInactiveReturn and player.lastOnline > GRM.S().inactiveHours and updatedPlayer.lastOnline < GRM.S().inactiveHours and player.lastOnline > updatedPlayer.lastOnline then  -- Player has logged in after having been inactive for greater than given time
            local needsToReport = true;

            local alts = GRM.GetListOfAlts ( player , false );
            -- No need to report if any player's alts are active still...
            if #alts and GRM.S().allAltRequirement then
                if GRM.IsAnyAltActive ( alts ) then
                    needsToReport = false;
                end
            end

            if needsToReport then
                GRM.RecordChanges ( 13 , updatedPlayer.name , ( player.lastOnline - updatedPlayer.lastOnline ) , nil , select ( 2 , GRM.GetTimestamp() ) );   -- Recording the change in hours to log
            end
        end

        player.lastOnline = updatedPlayer.lastOnline;                   -- Set new hours since last login.
    end

    -- Just straight update these everytime... No need for change check
    if ( updatedPlayer.isOnline and player.zone ~= updatedPlayer.zone ) or GRM_G.OnFirstLoad then
        player.timeEnteredZone = time();   -- Resetting the time on hitting this zone.
    end

    if GRM_G.BuildVersion >= 80000 then
        player.MythicScore = updatedPlayer.MythicScore;
    end

    if updatedPlayer.race ~= "" then
        player.race = updatedPlayer.race;    -- Race
    end
    if updatedPlayer.sex ~= "" then
        player.sex = updatedPlayer.sex;    -- Sex
    end

    player.zone = updatedPlayer.zone;                               -- zone
    player.achievementPoints = updatedPlayer.achievementPoints;     -- Achievement pts
    player.isMobile = updatedPlayer.isMobile;                       -- isMobile
    player.guildRep = updatedPlayer.rep;                            -- Guild Reputation
    player.isOnline = updatedPlayer.isOnline;                       -- online Status
    player.status = updatedPlayer.status;                           -- Active Status
    player.GUID = updatedPlayer.GUID;                               -- GUID
    player.faction = updatedPlayer.faction;                     -- 0 = Horde, 1 = Alliance

    -- No need to keep this info once player has been imported.
    if player.isTransfer then
        player.isTransfer = nil;
    end
end

-- Method:          GRM.CheckLogJoinOrLeave ( table )
-- What it Does:    Registers if a player as joined or left the guild and builds the string after making changes
-- Purpose:         Control flow of log information in updating GRM.
GRM.CheckLogJoinOrLeave = function ( roster , data )

    local guildData = data;

    -- Scan the roster for missing names...
    for _ , member in pairs ( guildData ) do
        if type ( member ) == "table" then
            if roster[member.name] == nil then         -- It exists in the existing database, but the updated one it is missing, thus implying player is no longer in the guild.
                table.insert ( GRM_G.leavingPlayers , member );
            end
        end
    end

    -- Final check on players that left the guild to see if they are namechanges.GRM.CanViewOfficerNote
    local playerNotMatched = true;
    if #GRM_G.leavingPlayers > 0 and #GRM_G.newPlayers > 0 then
        for k = 1 , #GRM_G.leavingPlayers do
            playerNotMatched = true;

            for j = 1 , #GRM_G.newPlayers do
                if ( GRM_G.leavingPlayers[k] ~= nil and GRM_G.newPlayers[j] ~= nil ) and GRM_G.leavingPlayers[k].GUID == GRM_G.newPlayers[j].GUID then   -- COMPARING GUID
                    playerNotMatched = false;   -- In other words, player was found, but it's a namechange!!!!!
                    -- Match Found!!!
                    GRM.RecordChanges ( 12 , GRM_G.newPlayers[j] , GRM_G.leavingPlayers[k] , nil , select ( 2 , GRM.GetTimestamp() ) );

                    -- We need to change the name EVERYWHERE!!!
                    for member in pairs ( guildData ) do
                        if type ( guildData[member] ) == "table" then
                            if GRM_G.leavingPlayers[k].GUID == guildData[member].GUID then -- Mathching the Leaving player to historical index so it can be identified and new name stored.

                                -- Need to remove him from list of alts IF he has a lot of alts...
                                GRM.ChangePlayerNameInAltGrouping ( GRM_G.leavingPlayers[k].name , GRM_G.newPlayers[j].name );

                                -- Group Info module -- update player Name change as well
                                if GRM_GroupInfo_Save ~= nil then
                                    GRM_GroupInfo_Save[GRM_G.newPlayers[j].name] = {};
                                    GRM_GroupInfo_Save[GRM_G.newPlayers[j].name] = GRM.DeepCopyArray ( GRM_GroupInfo_Save[GRM_G.leavingPlayers[k].name] );
                                    GRM_GroupInfo_Save[GRM_G.leavingPlayers[k].name] = nil;
                                end

                                guildData[GRM_G.newPlayers[j].name] = {};
                                guildData[GRM_G.newPlayers[j].name] = GRM.DeepCopyArray ( guildData[GRM_G.leavingPlayers[k].name] );
                                guildData[GRM_G.newPlayers[j].name].name = GRM_G.newPlayers[j].name;            -- Need to update this new name too!
                                guildData[GRM_G.leavingPlayers[k].name] = nil;
                                break
                            end
                        end
                    end
                    -- since namechange identified, also need to remove name from GRM_G.newPlayers array now.
                    if #GRM_G.newPlayers == 1 then
                        GRM_G.newPlayers = {}; -- Clears the array of the one name.
                    else
                        table.remove ( GRM_G.newPlayers , j );
                    end
                    break;
                end
            end
            
            -- Player not matched! For sure this player has left the guild!
            if playerNotMatched then
                GRM.RecordChanges ( 11 , GRM_G.leavingPlayers[k] , GRM_G.leavingPlayers[k] , nil , select ( 2 , GRM.GetTimestamp() ) );
            end
        end

    elseif #GRM_G.leavingPlayers > 0 then
        for i = 1 , #GRM_G.leavingPlayers do
            GRM.RecordChanges ( 11 , GRM_G.leavingPlayers[i] , GRM_G.leavingPlayers[i] , nil , select ( 2 , GRM.GetTimestamp() ) );
        end
    end

    if #GRM_G.newPlayers > 0 then
        for i = 1 , #GRM_G.newPlayers do
            GRM.RecordChanges ( 10 , GRM_G.newPlayers[i] , nil , nil , select ( 2 , GRM.GetTimestamp() ) );
        end
    end

    -- Now that we have collected all the players to be kicked... Let's not spam the log with alt info by parsing it properly.
    if #GRM_G.TempLeftGuildPlaceholder > 0 then
        for i = 1 , #GRM_G.TempLeftGuildPlaceholder do
            GRM.AddLeftOrKickEntry ( GRM.RecordKickChanges ( GRM_G.TempLeftGuildPlaceholder[i][1] , GRM_G.TempLeftGuildPlaceholder[i][3] , GRM_G.TempLeftGuildPlaceholder[i][4] ) );
        end
    end

    return guildData;
end

-- Method:          GRM.CheckPlayerChanges ( array )
-- What it Does:    Scans through guild roster and re-checks for any  (Will only fire if guild is found!)
-- Purpose:         Keep whoever uses the addon in the know instantly of what is going and changing in the guild.
GRM.CheckPlayerChanges = function ( roster )

    local guildData = GRM.GetGuild();
    local newPlayerFound;
    local player = {};
    local updatedPlayer = {};

    if GRM.S().scanEnabled or GRM_G.ManualScanEnabled then
        
        if GRM.ScanKillSwitch() then   -- Necessary in case you purge guild in middle of scan
            return;
        end
        
        for rosterName in pairs ( roster ) do

            newPlayerFound = true;
            player = guildData[rosterName];
            updatedPlayer = roster[rosterName];
    
            if player then
                
                if player.GUID == updatedPlayer.GUID or ( player.isTransfer and updatedPlayer.name == player.name and updatedPlayer.class == player.class ) then  -- In case someone deleted a toon, then joined a new toon with same name, need to confirm it is the same.

                    newPlayerFound = false;
                    GRM.CheckLogChanges ( updatedPlayer , player , rosterName );
                    GRM.CheckRosterChanges ( updatedPlayer , player , rosterName );
                        
                else
                    -- This means same name found, but different GUIDs, so different toon.
                    -- Player found in existing database - they need to be added to leaving players, then need to import the new player.
                    newPlayerFound = true;

                    GRM.AddLeftOrKickEntry ( GRM.RecordKickChanges ( player.name , GRM.SlimName ( player.name ) , select ( 2 , GRM.GetTimestamp() ) ) );
    
                end
            end
    
            -- NEW PLAYER FOUND! (Maybe)
            if newPlayerFound then
                if not GRM_G.liveKickedToons[updatedPlayer.name] then
                    table.insert ( GRM_G.newPlayers , updatedPlayer );
                end
            end
        end

        guildData = GRM.CheckLogJoinOrLeave ( roster , guildData );

        -- OK, let's close this out!!!!!
        -- Seeing if any upcoming notable events, like anniversaries/birthdays
        GRM.CheckPlayerEvents();

        -- Printing Report, and sending report to log.
        GRM.FinalReport();

        -- Disable manual scan if activated.
        if GRM_G.ManualScanEnabled and GRM_UI.GRM_ToolCoreFrame.MacroSuccess then
            GRM_G.ManualScanEnabled = false;
            GRM.Report ( GRM.L ( "GRM:" ) .. " " .. GRM.L ( "Manual Scan Complete" ) , 1.0 , 0.84 , 0 );
        end

        if GRM_G.ManualScanEnabled and not GRM_UI.GRM_ToolCoreFrame.MacroSuccess then
            GRM_G.ManualScanEnabled = false;
            GRM.ValidateMacroRecordingSuccess ( true );
        end

    else
        -- Seeing if any upcoming notable events, like anniversaries/birthdays
        GRM.CheckPlayerEvents();
    
        -- Printing Report, and sending report to log.
        GRM.FinalReport();
    
    end
end

-- Method:          GRM.FinalReport()
-- What it Does:    Organizes flow of final report and send it to chat frame and to the logReport.
-- Purpose:         Clean organization for presentation.
GRM.FinalReport = function()
    local needToReport = false;
    if GRM.ScanKillSwitch() then   -- Necessary in case you purge guild in middle of scan
        return;
    end

    -- For extra tracking info to display if the left player is on the server anymore...
    if #GRM_G.TempLeftGuild > 0 then
        -- need to build the names of those leaving for insert...
        
        local names = {};
        for i = 1 , #GRM_G.leavingPlayers do
            table.insert ( names , { GRM_G.leavingPlayers[i].name , GRM_G.leavingPlayers[i].GUID } );  -- Name and GUID
        end
        -- Establishing the players that left but are still on the server
        GRM.SetplayersStillOnServer ( names );
    end

    -- Cleanup the notes for reporting
    -- Join Dates Cleaned up First
    if #GRM_G.TempNewMember > 0 then
        local tempTable = {};
        for i = 1 , #GRM_G.TempNewMember do
            if string.find ( GRM_G.TempNewMember[i][2] , GRM.L ( "Invited By:" ) ) ~= nil then
                table.insert ( tempTable , 1 , GRM_G.TempNewMember[i] );
            else
                table.insert ( tempTable , GRM_G.TempNewMember[i] );
            end
        end
        GRM_G.TempNewMember = tempTable;
    end

    -- No need to spam the chat window when logging in.
    if not GRM_G.OnFirstLoad then

        if #GRM_G.TempBannedRejoin > 0 and GRM.S()["toChat"].joined then
            
            for i = 1 , #GRM_G.TempBannedRejoin do
                GRM.PrintLog ( GRM_G.TempBannedRejoin[i] );
            end
        end

        if #GRM_G.TempNameChanged > 0 and GRM.S()["toChat"].nameChange then
            
            for i = 1 , #GRM_G.TempNameChanged do
                GRM.PrintLog ( GRM_G.TempNameChanged[i] );
            end
        end

        if #GRM_G.TempLogPromotion > 0 and GRM.S()["toChat"].promotion then
            
            for i = 1 , #GRM_G.TempLogPromotion do
                GRM.PrintLog ( GRM_G.TempLogPromotion[i] );
            end
        end

        if #GRM_G.TempLogDemotion > 0 and GRM.S()["toChat"].demotion then
            
            for i = 1 , #GRM_G.TempLogDemotion do
                GRM.PrintLog ( GRM_G.TempLogDemotion[i] );                          
            end
        end

        if #GRM_G.TempRejoin > 0 and GRM.S()["toChat"].joined then
            
            for i = 1 , #GRM_G.TempRejoin do
                GRM.PrintLog ( GRM_G.TempRejoin[i] );            -- Same Comments on down
            end
        end

        if #GRM_G.TempNewMember > 0 and GRM.S()["toChat"].joined then
            
            for i = 1 , #GRM_G.TempNewMember do
                GRM.PrintLog ( GRM_G.TempNewMember[i] );   -- Send to print to chat window
            end
        end

        if #GRM_G.TempInactiveReturnedLog > 0 and GRM.S()["toChat"].inactiveReturn then
            
            for i = 1 , #GRM_G.TempInactiveReturnedLog do
                GRM.PrintLog ( GRM_G.TempInactiveReturnedLog[i] );
            end
        end

        if #GRM_G.TempRankRename > 0 and GRM.S()["toChat"].rankRename then
            
            for i = 1 , #GRM_G.TempRankRename do
                GRM.PrintLog ( GRM_G.TempRankRename[i] );
            end
        end
        if #GRM_G.TempLogLeveled > 0 and GRM.S()["toChat"].leveled then
            for i = 1 , #GRM_G.TempLogLeveled do
                GRM.PrintLog ( GRM_G.TempLogLeveled[i] );                  
            end
        end

        if #GRM_G.TempLogNote > 0 and GRM.S()["toChat"].note then
            
            for i = 1 , #GRM_G.TempLogNote do
                GRM.PrintLog ( GRM_G.TempLogNote[i] );         
            end
        end

        if #GRM_G.TempLogONote > 0 and GRM.S()["toChat"].officerNote then
            
            for i = 1 , #GRM_G.TempLogONote do
                GRM.PrintLog ( GRM_G.TempLogONote[i] );  
            end
        end

        if #GRM_G.TempEventReport > 0 and GRM.S()["toChat"].eventAnnounce then
            
            for i = 1 , #GRM_G.TempEventReport do
                GRM.PrintLog ( GRM_G.TempEventReport[i] );
            end
        end

        if #GRM_G.TempEventRecommendKickReport > 0 and GRM.S()["toChat"].recommend then
            
            for i = 1 , #GRM_G.TempEventRecommendKickReport do
                GRM.PrintLog ( GRM_G.TempEventRecommendKickReport[i] ); 
            end
        end

        if #GRM_G.TempEventRecommendPromotionReport > 0 and GRM.S()["toChat"].recommend then
            
            for i = 1 , #GRM_G.TempEventRecommendPromotionReport do
                GRM.PrintLog ( GRM_G.TempEventRecommendPromotionReport[i] ); 
            end
        end

        if #GRM_G.TempEventRecommendDemotionReport > 0 and GRM.S()["toChat"].recommend then
            
            for i = 1 , #GRM_G.TempEventRecommendDemotionReport do
                GRM.PrintLog ( GRM_G.TempEventRecommendDemotionReport[i] ); 
            end
        end

        if #GRM_G.TempDeathReport > 0 and GRM.S()["toChat"].death then
            
            for i = 1 , #GRM_G.TempDeathReport do
                GRM.PrintLog ( GRM_G.TempDeathReport[i] ); 
            end
        end
    end

    -- OK, NOW LET'S REPORT TO LOG FRAME IN REVERSE ORDER!!!

    if #GRM_G.TempEventRecommendKickReport > 0 then
        needToReport = true;
        if GRM_G.OnFirstLoad then
            GRM_G.ChangesFoundOnLoad = true;
        end
        for i = 1 , #GRM_G.TempEventRecommendKickReport do
            GRM.AddLog ( GRM_G.TempEventRecommendKickReport[i] );                    
        end
    end

    if #GRM_G.TempEventRecommendPromotionReport > 0 then
        needToReport = true;
        if GRM_G.OnFirstLoad then
            GRM_G.ChangesFoundOnLoad = true;
        end
        for i = 1 , #GRM_G.TempEventRecommendPromotionReport do
            GRM.AddLog ( GRM_G.TempEventRecommendPromotionReport[i] );                    
        end
    end

    if #GRM_G.TempEventRecommendDemotionReport > 0 then
        needToReport = true;
        if GRM_G.OnFirstLoad then
            GRM_G.ChangesFoundOnLoad = true;
        end
        for i = 1 , #GRM_G.TempEventRecommendDemotionReport do
            GRM.AddLog ( GRM_G.TempEventRecommendDemotionReport[i] );                    
        end
    end

    if #GRM_G.TempEventReport > 0 then
        needToReport = true;
        if GRM_G.OnFirstLoad then
            GRM_G.ChangesFoundOnLoad = true;
        end
        for i = 1 , #GRM_G.TempEventReport do
            GRM.AddLog( GRM_G.TempEventReport[i] );
        end
    end

    if #GRM_G.TempLogONote > 0 then
        needToReport = true;
        if GRM_G.OnFirstLoad then
            GRM_G.ChangesFoundOnLoad = true;
        end
        for i = 1 , #GRM_G.TempLogONote do
            GRM.AddLog ( GRM_G.TempLogONote[i] );                    
        end
    end
 
    if #GRM_G.TempLogNote > 0 then
        needToReport = true;
        if GRM_G.OnFirstLoad then
            GRM_G.ChangesFoundOnLoad = true;
        end
        for i = 1 , #GRM_G.TempLogNote do
            GRM.AddLog ( GRM_G.TempLogNote[i] );                    
        end
    end

    if #GRM_G.TempLogLeveled > 0 then
        needToReport = true;
        if GRM_G.OnFirstLoad then
            GRM_G.ChangesFoundOnLoad = true;
        end
        for i = 1 , #GRM_G.TempLogLeveled do
            GRM.AddLog ( GRM_G.TempLogLeveled[i] );                    
        end
    end

    if #GRM_G.TempRankRename > 0 then
        needToReport = true;
        if GRM_G.OnFirstLoad then
            GRM_G.ChangesFoundOnLoad = true;
        end
        for i = 1 , #GRM_G.TempRankRename do
            GRM.AddLog ( GRM_G.TempRankRename[i] );
        end
    end

    if #GRM_G.TempRejoin > 0 then
        needToReport = true;
        if GRM_G.OnFirstLoad then
            GRM_G.ChangesFoundOnLoad = true;
        end
        for i = 1 , #GRM_G.TempRejoin do
            GRM.AddLog ( GRM_G.TempRejoin[i] );
        end
    end

    if #GRM_G.TempNewMember > 0 then
        needToReport = true;
        if GRM_G.OnFirstLoad then
            GRM_G.ChangesFoundOnLoad = true;
        end
        for i = 1 , #GRM_G.TempNewMember do
            GRM.AddLog ( GRM_G.TempNewMember[i] );                                           -- Adding to the Log of Events
        end
    end

    if #GRM_G.TempLogDemotion > 0 then
        needToReport = true;
        if GRM_G.OnFirstLoad then
            GRM_G.ChangesFoundOnLoad = true;
        end
        for i = 1 , #GRM_G.TempLogDemotion do
            GRM.AddLog ( GRM_G.TempLogDemotion[i] );                           
        end
    end

    if #GRM_G.TempLogPromotion > 0 then
        needToReport = true;
        if GRM_G.OnFirstLoad then
            GRM_G.ChangesFoundOnLoad = true;
        end
        for i = 1 , #GRM_G.TempLogPromotion do
            GRM.AddLog ( GRM_G.TempLogPromotion[i] );
        end
    end

    if #GRM_G.TempNameChanged > 0 then
        needToReport = true;
        if GRM_G.OnFirstLoad then
            GRM_G.ChangesFoundOnLoad = true;
        end
        for i = 1 , #GRM_G.TempNameChanged do
            GRM.AddLog ( GRM_G.TempNameChanged[i] );
        end
    end

    if #GRM_G.TempInactiveReturnedLog > 0 then
        needToReport = true;
        if GRM_G.OnFirstLoad then
            GRM_G.ChangesFoundOnLoad = true;
        end
        for i = 1 , #GRM_G.TempInactiveReturnedLog do
            GRM.AddLog ( GRM_G.TempInactiveReturnedLog[i] );
        end
    end

    if #GRM_G.TempBannedRejoin > 0 then
        needToReport = true;
        if GRM_G.OnFirstLoad then
            GRM_G.ChangesFoundOnLoad = true;
        end
        for i = 1 , #GRM_G.TempBannedRejoin do
            GRM.AddLog ( GRM_G.TempBannedRejoin[i] );
        end
    end

    if #GRM_G.TempDeathReport > 0 then
        needToReport = true;
        if GRM_G.OnFirstLoad then
            GRM_G.ChangesFoundOnLoad = true;
        end
        for i = 1 , #GRM_G.TempDeathReport do
            GRM.AddLog( GRM_G.TempDeathReport[i] );
        end
    end

    local wait = 0;

     -- Let's go through the Left Players.
     if #GRM_G.TempLeftGuild > 0 then
        needToReport = true;
        C_Timer.After ( 1.5 , function()
            GRM.FinalLeftPlayersReport();
        end);
        wait = 2;
    end

    C_Timer.After ( wait , function()
        GRM.FinalReportInformation( needToReport );
    end);
end

-- Method:          GRM.FinalLeftPlayersReport()
-- What it Does:    Adds reporting extra info to end of the log string
-- Purpose:         Compartmentalize the log reporting code to be cleaner.
GRM.FinalLeftPlayersReport = function()

    if GRM.ScanKillSwitch() then   -- Necessary in case you purge guild in middle of scan
        return;
    end

    if GRM_G.OnFirstLoad then
        GRM_G.ChangesFoundOnLoad = true;
    end
    -- Let's compare our left players now...
    local isMatched = false;
    for i = 1 , #GRM_G.leavingPlayers do
        isMatched = false;
        for j = 1 , #GRM_G.playersStillOnServer do
            if GRM_G.leavingPlayers[i].name == GRM_G.playersStillOnServer[j] then
                isMatched = true;
                -- now let's match it to propper tempLeft table
                break;
            end
        end

        local timePassed = GRM.GetTimePlayerHasBeenMember ( GRM_G.leavingPlayers[i].name );
        if timePassed ~= "" then
            timePassed = ( "|cFFFFFFFF" .. GRM.L ( "Time as Member:" ) .. " " .. timePassed .. "|r" );
        end
        -- if not isMatched then (player not on friends list... this means that the player has left the server or namechanged)
        if not isMatched then

            for m = 1 , #GRM_G.TempLeftGuild do
                if string.find ( GRM_G.TempLeftGuild[m][2] , GRM.L ( "Player no longer on Server" ) ) == nil and 
                ( string.find ( GRM_G.TempLeftGuild[m][2] , GRM.L ( "has Left the guild" ) ) ~= nil or string.find ( GRM_G.TempLeftGuild[m][2] , GRM.L ( "is no longer in the Guild!" ) ) ~= nil ) and 
                string.find ( GRM_G.TempLeftGuild[m][2] , GRM.SlimName ( GRM_G.leavingPlayers[i].name ) ) ~= nil then
                    if string.find ( GRM_G.TempLeftGuild[m][2] , GRM.L ( "ALTS IN GUILD:" ) ) ~= nil then
                        local index2 = select ( 2 , string.find ( GRM_G.TempLeftGuild[m][2] , "\n" ) );
                        if timePassed ~= "" then
                            GRM_G.TempLeftGuild[m][2] = string.sub ( GRM_G.TempLeftGuild[m][2] , 1 , index2 - 1 ) .. " |CFFFF0000(" .. GRM.L ( "Player no longer on Server" ) .. ")|CFF808080" .. string.sub ( GRM_G.TempLeftGuild[m][2] , index2 ) .. "\n" .. timePassed;
                        else
                            GRM_G.TempLeftGuild[m][2] = string.sub ( GRM_G.TempLeftGuild[m][2] , 1 , index2 - 1 ) .. " |CFFFF0000(" .. GRM.L ( "Player no longer on Server" ) .. ")|CFF808080" .. string.sub ( GRM_G.TempLeftGuild[m][2] , index2 );
                        end
                    else
                        if timePassed ~= "" then
                            GRM_G.TempLeftGuild[m][2] = GRM_G.TempLeftGuild[m][2] .. " |CFFFF0000(" .. GRM.L ( "Player no longer on Server" ) .. ")\n" .. timePassed;
                        else
                            GRM_G.TempLeftGuild[m][2] = GRM_G.TempLeftGuild[m][2] .. " |CFFFF0000(" .. GRM.L ( "Player no longer on Server" ) .. ")";
                        end
                    end
                    GRM_G.TempLeftGuild[m][12] = true;
                    break;
                end
            end
        else
            -- Player is still on the server, just no longer in the guild
            for m = 1 , #GRM_G.TempLeftGuild do
                if string.find ( GRM_G.TempLeftGuild[m][2] , GRM.L ( "has Left the guild" ) ) ~= nil and string.find ( GRM_G.TempLeftGuild[m][2] , GRM.SlimName ( GRM_G.leavingPlayers[i].name ) ) ~= nil then
                    if timePassed ~= "" then
                        GRM_G.TempLeftGuild[m][2] = GRM_G.TempLeftGuild[m][2] .. " (" .. timePassed .. ")";
                    else
                        GRM_G.TempLeftGuild[m][2] = GRM_G.TempLeftGuild[m][2];
                    end
                    break;
                end
            end

            for m = 1 , #GRM_G.TempLeftGuild do
                if string.find ( GRM_G.TempLeftGuild[m][2] , GRM.L ( "kicked" ) ) ~= nil and string.find ( GRM_G.TempLeftGuild[m][2] , GRM.SlimName ( GRM_G.leavingPlayers[i].name ) ) ~= nil then
                    if timePassed ~= "" then
                        GRM_G.TempLeftGuild[m][2] = GRM_G.TempLeftGuild[m][2] .. " (" .. timePassed .. ")";
                    else
                        GRM_G.TempLeftGuild[m][2] = GRM_G.TempLeftGuild[m][2];
                    end
                    break;
                end
            end
        end

    end

    -- sending to log
    for i = 1 , #GRM_G.TempLeftGuild do
        if GRM_G.OnFirstLoad then
            GRM_G.ChangesFoundOnLoad = true;
        end
        GRM.AddLog ( GRM_G.TempLeftGuild[i] );
    end

end

-- Method:          GRM.FinalReportInformation( bool )
-- What it Does:    Cleans up the scan from all the remaining info and reports
-- Purpose:         Compartmentalize the wrap up part of the scan
GRM.FinalReportInformation = function( needToReport )

    -- Update the Add Event Window
    if #GRM_G.TempEventReport > 0 and GRM_UI.GRM_RosterChangeLogFrame.GRM_EventsFrame:IsVisible() then
        GRM.RefreshAddEventFrame();
    end
    -- Clear the changes.
    GRM.ResetTempLogs();

    if GRM_G.OnFirstLoad then
        if GRM.S().viewOnLoad then
            if GRM.S().onlyViewIfChanges and GRM_G.ChangesFoundOnLoad then
                GRM_UI.GRM_RosterChangeLogFrame:Show();
            end
        end

        -- Let's do an announcement
        GRM.AnnounceIfBirthday();
        GRM.CheckForDeadAccounts( false );

    end
    -- Let's update the frames!
    if needToReport and GRM_UI.GRM_RosterChangeLogFrame ~= nil and GRM_UI.GRM_RosterChangeLogFrame:IsVisible() then
        GRM.BuildLogComplete( true , true );
    end

    if GRM_UI.GRM_MemberDetailMetaData:IsVisible() then
        GRM.PopulateMemberDetails ( GRM_G.currentName );
    end

    if GRM_UI.GRM_RosterFrame ~= nil and GRM_UI.GRM_RosterFrame:IsVisible() then
        GRM_R.RefreshRosterName();
    end

    -- Report on the live changes collected while this scan was occurring.
    if #GRM.LiveScanQue > 0 then
        GRM.ProcessLiveScanQue();
    end

    GRM_G.OnFirstLoad = false;
    GRM_G.numRanksHasChanged = false;
    GRM_G.rankChangeShift = 0;
    GRM_G.CurrentlyScanning = false;
    GRM_G.changeHappenedExitScan = false;

end

-- Method:          GRM.GetLogFormattedTimestamp ( array , string )
-- What it Does:    Attaches the timestamp properly to the log string at start and in converted format
-- Purpose:         Reusable function for cleaner code for repeat reporting.
GRM.GetLogFormattedTimestamp = function ( date , result )
    if date[4] ~= nil and date[5] ~= nil then
        result = GRM.FormatTimeStamp ( date , true ) .. " : " .. result;
    end

    return result;
end

-- Method:          GRM.ParseGuildRanks()
-- What it Does:    Parses the string with al the guild ranks and returns it as an array
-- Purpose:         Due to some tables scanning logic I want to keep this stored as a string and then converted to a table during your session or re-converted if the ranks are updated.
GRM.ParseGuildRanks = function()
    local ranks = {};

    for rankName in string.gmatch ( GRM.GetGuild().ranks , "[^||]+" ) do
        table.insert ( ranks , rankName );
    end
    return ranks;
end

-- Method:          GRM.CheckGuildRanks()
-- What it Does:    Checks for any changes in the guild rank structure of the guild and reports on them
-- Purpose:         Just extra info, especially to help make it more clear to the player why they might get spammed in their log for mass demote/promotions
GRM.CheckGuildRanks = function()
    -- If the ranks are set, let's check if they do not match now.
    local numRanks = GuildControlGetNumRanks();
    
    if numRanks == 0 or numRanks == nil then   -- To prevent an error here, as this is critical, we wil not continue forward.
        return false;
    end

    local guildData = GRM.GetGuild();
    
    guildData.ranks = guildData.ranks or GRM.GetListOfGuildRanks ( true , true , true );
    
    GRM_G.guildRankNames = GRM_G.guildRankNames or GRM.ParseGuildRanks();

    if guildData.grmNumRanks == nil or guildData.grmNumRanks == 0 then
        guildData.grmNumRanks = numRanks;
    end

    if numRanks ~= guildData.grmNumRanks then
        
        GRM_G.rankChangeShift = numRanks - guildData.grmNumRanks;
        GRM.AddRankRenameEntry ( GRM_G.rankChangeShift , nil , nil , select ( 2 , GRM.GetTimestamp() ) );
        guildData.grmNumRanks = numRanks;
        GRM_G.numRanksHasChanged = true;
        
    else
        
        local rankNames = GRM.GetListOfGuildRanks ( true , true );
        local changeMade = false;

        for i = 1 , #rankNames do
            if rankNames[i] ~= GRM_G.guildRankNames[i] then
                changeMade = true;
                GRM.AddRankRenameEntry ( nil , GRM_G.guildRankNames[i] , rankNames[i] , select ( 2 , GRM.GetTimestamp() ) );
            end
        end

        if changeMade then
            guildData.ranks = GRM.GetListOfGuildRanks ( true , true , true );
            GRM_G.guildRankNames = GRM.ParseGuildRanks();
        end
    end

    return true;
end

-- Method:          GRM.NoLivecheck()
-- What it Does:    It compares the live Check event table if a live scan is going, and it ignores checking roster
-- Purpose:         To prevent overlap reporting erroneously to the log.
GRM.NoLivecheck = function()
    local result = true;

    for _, group in pairs ( GRM_G.LiveScanningBlock ) do
        for i = 1 , #group do
            if group[i] then
                result = false;
            end
        end
    end

    return result;
end

-- Method:          GRM.LogPrecheck()
-- What it Does:    Controls when to give the go ahead to scan the roster if an event triggers
-- Purpose:         It can be a bit spammy in pulling data from the server if it calls too frequently. This controls that.
GRM.LogPrecheck = function()
    if ( ( ( time() - GRM_G.ScanControl ) >= GRM_G.DefaultMinScanTime ) and GRM.NoLivecheck() ) or GRM_G.OnFirstLoad then
        C_Timer.After ( 0.2 , function()
            if ( ( ( time() - GRM_G.ScanControl ) >= GRM_G.DefaultMinScanTime ) and GRM.NoLivecheck() and #GRM.LiveScanQue == 0 ) or GRM_G.OnFirstLoad then
                if not GRM_G.CurrentlyScanning then
                    
                    GRM.BuildNewRoster();
                    
                end
            end
        end);
    end
end

-- Method:          GRM.RosterPreCheck()
-- What it Does:    Controls when to give the go ahead to scan the roster if an event triggers
-- Purpose:         It can be a bit spammy in pulling data from the server if it calls too frequently. This controls that.
GRM.RosterPreCheck = function()
    if ( ( ( time() - GRM_G.ScanControl ) >= GRM_G.DefaultMinScanTime ) and GRM.NoLivecheck() ) or GRM_G.OnFirstLoad then
        C_Timer.After ( 0.1 , function()
            if ( ( ( time() - GRM_G.ScanControl ) >= GRM_G.DefaultMinScanTime ) and GRM.NoLivecheck() ) or GRM_G.OnFirstLoad then
                if not GRM_G.CurrentlyScanning then
                    GRM.BuildNewRoster();
                end
            end
        end);
    end
end

-- Method:          GRM.BuildNewRoster()
-- What it does:    Rebuilds the roster to check against for any changes.
-- Purpose:         To track for guild changes of course!
GRM.BuildNewRoster = function()

    if not GRM_G.CurrentlyScanning and not GRM.ScanKillSwitch() and not GRM_G.MacroInProgress then   -- Necessary in case you purge guild in middle of 

        GRM_G.CurrentlyScanning = true;
        GRM_G.ScanControl = time();
    else
        return;
    end

    local roster = {};
    -- Checking if Guild Found or Not Found, to pre-check for Guild name tag.
    local guildNotFound = false;
    if not GRM.GetGuild() then
        guildNotFound = true;
    end

    local atLeastOne = false;

    for i = 1 , GRM.GetNumGuildies() do
        -- For guild info
        local name , rank , rankInd , level , _ , zone , note , officerNote , online , status , class , achievementPoints , _ , isMobile , _ , rep , GUID = GetGuildRosterInfo ( i );

        if GRM_G.liveAddedToons[name] then
            GRM_G.liveAddedToons[name] = nil;   -- No longer needed on this list since they are confirmed in guild.
        end

        roster[name] = {};      -- For easy referencing.
        roster[name].name = name                                    -- 1
        roster[name].rankName = rank;                               -- 2
        roster[name].rankIndex = rankInd;                           -- 3
        roster[name].level = level;                                 -- 4
        roster[name].note = note;                                   -- 5
        if GRM.CanViewOfficerNote() then -- Officer Note permission to view.
            roster[name].officerNote = officerNote;                 -- 6
        else
            roster[name].officerNote = nil; -- Set Officer note to nil if needed due to player not being able to view. - If it is set to "" then player will think it is changing.
        end
        roster[name].class = class;                                 -- 7
        roster[name].lastOnline = GRM.GetHoursSinceLastOnline ( i , online ); -- 8 Time since they last logged in in hours.
        roster[name].zone = zone;                                   -- 9
        roster[name].achievementPoints = achievementPoints;         -- 10
        roster[name].isMobile = isMobile;                           -- 11
        roster[name].rep = rep;                                     -- 12
        roster[name].isOnline = online;                             -- 13
        roster[name].status = status;                               -- 14
        roster[name].GUID = GUID;                                   -- 15

        local race , sex = select ( 4 , GetPlayerInfoByGUID ( GUID ) );
        if race == nil or sex == nil then
            race , sex = select ( 4 , GetPlayerInfoByGUID ( GUID ) );   -- Call a second time... sometimes the server is weird and the first call produces nil, but the immediate 2nd does respond.
            if race == nil or sex == nil then
                race = "";
                sex = 1;
            end
        end 

        roster[name].race = race;                                   -- 16
        roster[name].sex = sex;                                     -- 17
        roster[name].rosterSelection = i;                           -- 18
        roster[name].faction = GRM_G.faction;

        if GRM_G.BuildVersion >= 80000 then
            roster[name].MythicScore = 0;
        end

        atLeastOne = true;

    end

    for memberName in pairs ( GRM_G.liveKickedToons ) do
        if not roster[memberName] then
            GRM_G.liveKickedToons[memberName] = nil;    -- Player kicked is confirmed not showing up in guild.
        end
    end

    if GRM_G.BuildVersion >= 80000 then

        local clubID = C_Club.GetGuildClubId();
        if clubID and clubID ~= "" then
            local members = C_Club.GetClubMembers ( clubID )
            local name = "";

            for i = 1 , #members do
                player = C_Club.GetMemberInfo ( clubID , members[i] )
                name = GRM.GetFullNameClubMember ( player.guid );

                if name ~= "" and roster[name] then
                    if player.overallDungeonScore then
                        roster[name].MythicScore = player.overallDungeonScore;
                    end

                    if GRM_G.BuildVersion >= 100000 then
                        roster[name].faction = player.faction;
                    end

                end
            end
        end
    end

        -- Build Roster for the first time if guild not found.
    if atLeastOne and GRM_G.guildName ~= nil and GRM_G.guildName ~= "" then
        if guildNotFound then
            -- See if it is a Guild NameChange first!
            GRM.BuildNewGuildOrNameChange ( roster , false );

        else
            -- This is critical to do in case the guild has added or removed ranks...
            GRM.CheckGuildRanks();

            GRM_G.ThrottleControlNum = 1;
            -- new member and leaving members arrays to check at the end - need to reset it here.
            GRM_G.newPlayers = {};
            GRM_G.leavingPlayers = {};
            -- Add in a delay for the server calls to work

            GRM.GuildRoster();
            if GRM_G.BuildVersion >= 30000 then
                QueryGuildEventLog();
            end

            C_Timer.After ( 1.5 , function()
                GRM.CheckPlayerChanges ( roster );
            end);
        end
    end
end

-- Method:          GRM.BuildNewGuildOrNameChange ( table )
-- What it Does:    Guild namechange detection
-- Purpose:         Determine if it is a guild nameChange and if so, to convert DB to new name without losing everything.
GRM.BuildNewGuildOrNameChange = function ( roster , forceRebuild )

    local guildNameChanged , currentGuildName , oldGuildName = GRM.GuildNameChanged ( GRM_G.guildName );

    if not forceRebuild and guildNameChanged then
        -- Popup window to Ask player to confirm...
        -- if confirm

        if GRM_G.BuildVersion < 80000 then
            GRM_G.GuildNamechangeProcessing = true;

            local Confirm = function()
                GRM.ProcessGuildNameChange ( currentGuildName , oldGuildName );
            end
            local Reject = function()
                GRM.BuildNewGuildOrNameChange ( roster , true );
            end

            GRM.SetConfirmationWindow ( Confirm , GRM.L ( "Please confirm that the guild \"{name}\" has been renamed to \"{name2}\"." , oldGuildName , currentGuildName ) , Reject , nil , GRM.L ( "Reject" ) );
        else
            GRM.ProcessGuildNameChange ( currentGuildName , oldGuildName );
        end

    else
        GRM.Report ( "\n" .. GRM.L ( "Guild Roster Manager" ) .. "\n" .. GRM.L ( "Analyzing guild for the first time..." ) .. "\n" .. GRM.L ( "Building Profiles on ALL \"{name}\" members" , GRM.SlimName ( GRM_G.guildName ) ) .. "\n\n" );
        -- This reiterates over this, because sometimes it can have a delay. This ensures it is secure.

        local clubID = 0;
        if GRM_G.BuildVersion >= 80000 then
            clubID = C_Club.GetGuildClubId();
        else
            clubID = GRM.CreateCustomGUIDValue( GRM_G.guildName );
        end

        if not GRM.GetGuild() then
            GRM_GuildMemberHistory_Save[ GRM_G.guildName ] = {};
            GRM_GuildMemberHistory_Save[ GRM_G.guildName ]["grmName"] = GRM_G.guildName;
            GRM_GuildMemberHistory_Save[ GRM_G.guildName ]["grmCreationDate"] = GRM_G.guildCreationDate or "";
            GRM_GuildMemberHistory_Save[ GRM_G.guildName ]["grmNumRanks"] = GuildControlGetNumRanks() or 0;
            GRM_GuildMemberHistory_Save[ GRM_G.guildName ]["grmClubID"] = clubID or 0;
            
            GRM_PlayersThatLeftHistory_Save[ GRM_G.guildName ] = {};
            
            -- Configure and initialize the backup tables.
            GRM_GuildDataBackup_Save[ GRM_G.guildName ] = {};
            GRM_GuildDataBackup_Save[ GRM_G.guildName ].guildCreationDate = GRM_G.guildCreationDate;
            GRM_GuildDataBackup_Save[ GRM_G.guildName ].numGuildies = 0;
            GRM_GuildDataBackup_Save[ GRM_G.guildName ].date = "";
            GRM_GuildDataBackup_Save[ GRM_G.guildName ].epochDate = 0;
            GRM_GuildDataBackup_Save[ GRM_G.guildName ].members = {};
            GRM_GuildDataBackup_Save[ GRM_G.guildName ].formerMembers = {};
            GRM_GuildDataBackup_Save[ GRM_G.guildName ].log = {};
            GRM_GuildDataBackup_Save[ GRM_G.guildName ].alts = {};
        
            -- Make sure guild is not already added.
            if not GRM_PlayerListOfAlts_Save[GRM_G.guildName] then
                GRM_PlayerListOfAlts_Save[GRM_G.guildName] = {};
            end
        
            -- Log table
            if GRM_LogReport_Save[ GRM_G.guildName ] == nil then
                GRM_LogReport_Save[ GRM_G.guildName ] = {};
            end
        
            -- Calendar table
            GRM_CalendarAddQue_Save[ GRM_G.guildName ] = {};
        
            if GRM_Alts[GRM_G.guildName] == nil then
                GRM_Alts[GRM_G.guildName] = {};
            end
        
            for player in pairs ( roster ) do
                -- Build the guild and add each player
                GRM.AddMemberRecord ( roster[player] , false , nil );
                if GRM_GuildMemberHistory_Save [ GRM_G.guildName ][player] ~= nil then
                    GRM_GuildMemberHistory_Save [ GRM_G.guildName ][player].lastOnline = roster[player].lastOnline;   -- Setting Timestamp for the first time only.
                end
            end

            -- Add new guild
            GRM_AddonSettings_Save[GRM_G.guildName] = {};

            -- Load the Default Settings
            for i = 0 , GRM_G.SettingsPages do
                GRM.SetDefaultAddonSettings ( GRM_AddonSettings_Save[GRM_G.guildName] , i );
            end

            if IsAddOnLoaded("epgp") and GRM.S().joinDateDestination ~= 3 then
                GRM.S().joinDateDestination = 2;
            end

            GRM.GuildSpecificConfigurations();
            GRM_UI.ReloadAllFrames ( true , false );

            if not GRM_G.MainHookConfigured then
                GRM.MessageHookControl();
            end

        end


        GRM_G.GuildNamechangeProcessing = false;
    end
end

-- Method:          GRM.ProcessGuildNameChange ( string , string )
-- What it Does:    Changes the guildName
-- Purpose:         Allows use of compartmentalizing the guildNameChange so a popupWindow can confirm
GRM.ProcessGuildNameChange = function ( currentGuildName , oldGuildName )

    GRM_PlayersThatLeftHistory_Save[currentGuildName] = {};
    GRM_PlayersThatLeftHistory_Save[currentGuildName] = GRM.DeepCopyArray ( GRM_PlayersThatLeftHistory_Save[oldGuildName] );
    GRM_PlayersThatLeftHistory_Save[oldGuildName] = nil;

    GRM_GuildMemberHistory_Save[currentGuildName] = {};
    GRM_GuildMemberHistory_Save[currentGuildName] = GRM.DeepCopyArray ( GRM_GuildMemberHistory_Save[oldGuildName] );
    GRM_GuildMemberHistory_Save[currentGuildName].grmName = currentGuildName;
    GRM_GuildMemberHistory_Save[oldGuildName] = nil;

    GRM_PlayerListOfAlts_Save[currentGuildName] = {};
    GRM_PlayerListOfAlts_Save[currentGuildName] = GRM.DeepCopyArray ( GRM_PlayerListOfAlts_Save[oldGuildName] );
    GRM_PlayerListOfAlts_Save[oldGuildName] = nil;

    GRM_LogReport_Save[currentGuildName] = {};
    GRM_LogReport_Save[currentGuildName] = GRM.DeepCopyArray ( GRM_LogReport_Save[oldGuildName] );
    GRM_LogReport_Save[oldGuildName] = nil;

    GRM_CalendarAddQue_Save[currentGuildName] = {};
    GRM_CalendarAddQue_Save[currentGuildName] = GRM.DeepCopyArray ( GRM_CalendarAddQue_Save[oldGuildName] );
    GRM_CalendarAddQue_Save[oldGuildName] = nil;

    GRM_Alts[currentGuildName] = GRM.DeepCopyArray ( GRM_Alts[oldGuildName] );
    GRM_Alts[oldGuildName] = nil;

    -- Also need to change the guild's name in the saved database...
    if GRM_GuildDataBackup_Save[oldGuildName].date ~= "" then
        GRM_GuildDataBackup_Save[oldGuildName].members.grmName = currentGuildName;
    end

    GRM_GuildDataBackup_Save[currentGuildName] = {};
    GRM_GuildDataBackup_Save[currentGuildName] = GRM.DeepCopyArray ( GRM_GuildDataBackup_Save[oldGuildName] );
    GRM_GuildDataBackup_Save[oldGuildName] = nil;

    local tempName = GRM.GetStringClassColorByName( GRM_G.addonUser ) .. GRM.SlimName( GRM_G.addonUser ) .. "|r";
    local logEntryWithTime , logEntry = GRM.GetGuildNameChangeString ( tempName , GRM.SlimName ( currentGuildName ) , select ( 2 , GRM.GetTimestamp() ) );

    GRM.PrintLog ( { 15 , logEntry } );   
    GRM.AddLog ( { 15 , logEntryWithTime , tempName , GRM.SlimName ( currentGuildName ) , select ( 2 , GRM.GetTimestamp() ) } , currentGuildName );

    GRM_G.GuildNamechangeProcessing = false;
end

-- Method:          GRM.GuildNameChanged( string )
-- What it Does:    Returns true if the player's guild is the same, it just changed its name
-- Purpose:         Good to know... what a pain it would be if you had to reset all of your settings
GRM.GuildNameChanged = function ( currentGuildName )
    local result = false;
    local moveForward = false;
    local oldGuildName = "";

    if GRM_G.BuildVersion >= 80000 then
        if GRM_GuildMemberHistory_Save[currentGuildName] == nil or ( GRM_GuildMemberHistory_Save[currentGuildName] ~= nil and GRM_GuildMemberHistory_Save[currentGuildName].grmClubID ~= GRM_G.gClubID ) then
            moveForward = true;
        end

    elseif GRM_G.BuildVersion < 80000 then
        -- Classic build cannot compare clubIDs as that did not work until 8.0. Look for confirmation of the roster ratio being same

        if GRM_GuildMemberHistory_Save[currentGuildName] == nil then
                
            local numGuildies = GRM.GetNumGuildies();
            local threshold = math.floor ( numGuildies / 2 ); -- Just > 50%
            local countMatch = 0;
            local name = "";

            for guildName in pairs ( GRM_GuildMemberHistory_Save ) do
                countMatch = 0;

                for i = 1 , numGuildies do
                    name = GetGuildRosterInfo ( i );

                    if GRM_GuildMemberHistory_Save[guildName][name] then
                        countMatch = countMatch + 1;
                    end

                end
                
                threshold = math.floor ( ( countMatch / numGuildies ) * 100 );
                -- Keep it within 50% difference, over or under

                if threshold > 50 and threshold < 150 then

                    if threshold > 100 then
                        threshold = threshold - 100;
                    end

                    result = true;
                    oldGuildName = guildName;

                    GRM.Report ( GRM.L ( "GRM:" ) .. " " .. GRM.L ( "Possible Guild Name Change Detected. {num}% match." , nil , nil , threshold ) , 1.0 , 0.84 , 0 );

                    break;
                end
                
            end

        end

    end
        -- If the guild name is found in database but club IDs do not match, then it can be determined that this is likely a namechange, but it is coming from a guild someone was just holding on to.
    if moveForward then
    -- For each guild
        for guild in pairs ( GRM_GuildMemberHistory_Save ) do
            if GRM_GuildMemberHistory_Save[guild].grmClubID == GRM_G.gClubID then -- This only works retail...
                result = true;
                oldGuildName = guild;
            end
        end
    end
    return result , currentGuildName , oldGuildName;
end

-- Method:          GRM.VerifyAllRankDates ( int )
-- What it Does:    Auto verifies all the promotions or demotion dates within that happened within X number of days.
-- Purpose:         Give player the ability to verify all the dates, or within a range.
GRM.VerifyAllRankDates = function ( numDays )

    local count = 0;
    local dateRestriction = false;
    local readyToUpdate = false;

    if numDays then
        dateRestriction = true;
    end

    local guildData = GRM.GetGuild();

    for _ , player in pairs ( guildData ) do
        if type ( player ) == "table" then
            readyToUpdate = false;
            if #player.rankHist > 0 and player.rankHist[1][2] ~= 0 and player.rankHist[1][7] == false then
                -- Player has a date set, but it is not verified.
                if dateRestriction then
                    if ( time() - ( ( numDays * 86400 ) + 86400 ) ) <= GRM.convertToEpoch ( player.rankHist[1][2] , player.rankHist[1][3] , player.rankHist[1][4] , 0 , 0 , 0 , false ) then
                        readyToUpdate = true;
                    end
                else
                    readyToUpdate = true;
                end

                if readyToUpdate then
                    for i = 1 , #player.rankHist do
                        player.rankHist[i][6] = 1;  -- 1 so it is not zero, but mass verify when not truly verified should be overwritten by others if newer info
                        player.rankHist[i][7] = true;
                    end
                    count = count + 1;
                end

            end
        end
    end

    if GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame:IsVisible() then
        GRM.RefreshAuditFrames ( true , true );
    end

    if GRM_UI.GRM_MemberDetailMetaData:IsVisible() then
        GRM.PopulateMemberDetails ( GRM_G.currentName );
    end

    if GRM_UI.GRM_RosterFrame ~= nil and GRM_UI.GRM_RosterFrame:IsVisible() then
        GRM_R.RefreshRosterName();
    end

    if count == 1 then
        GRM.Report ( GRM.L ( "GRM:" ) .. " " ..  GRM.L ( "1 Promotion Date Has Been Confirmed." ) );
    else
        GRM.Report ( GRM.L ( "GRM:" ) .. " " ..  GRM.L ( "{num} Promotion Dates Have Been Confirmed." , nil , nil , count ) );
    end

end

-- Method:          GRM.VerifyAllJoinDates ( int )
-- What it Does:    Auto verifies all the promotions or demotion dates within that happened within X number of days.
-- Purpose:         Give player the ability to verify all the dates, or within a range.
GRM.VerifyAllJoinDates = function ( numDays )
    local count = 0;
    local dateRestriction = false;
    local readyToUpdate = false;

    if numDays then
        dateRestriction = true;
    end

    local guildData = GRM.GetGuild();

    for _ , player in pairs ( guildData ) do
        if type ( player ) == "table" then
            readyToUpdate = false;
            if #player.joinDateHist > 0 and player.joinDateHist[1][1] ~= 0 and player.joinDateHist[1][6] == false then
                -- Player has a date set, but it is not verified.
                if dateRestriction then
                    if ( time() - ( ( numDays * 86400 ) + 86400 ) ) <= GRM.convertToEpoch ( player.joinDateHist[1][1] , player.joinDateHist[1][2] , player.joinDateHist[1][3] , 0 , 0 , 0 , false ) then
                        readyToUpdate = true;
                    end
                else
                    readyToUpdate = true;
                end

                if readyToUpdate then
                    for i = 1 , #player.joinDateHist do
                        player.joinDateHist[i][5] = 1;
                        player.joinDateHist[i][6] = true;
                    end
                    count = count + 1;
                end

            end
        end
    end

    if GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame:IsVisible() then
        GRM.RefreshAuditFrames ( true , true );
    end

    if GRM_UI.GRM_MemberDetailMetaData:IsVisible() then
        GRM.PopulateMemberDetails ( GRM_G.currentName );
    end

    if GRM_UI.GRM_RosterFrame ~= nil and GRM_UI.GRM_RosterFrame:IsVisible() then
        GRM_R.RefreshRosterName();
    end

    if count == 1 then
        GRM.Report ( GRM.L ( "GRM:" ) .. " " .. GRM.L ( "1 Join Date Has Been Confirmed." ) );
    else
        GRM.Report ( GRM.L ( "GRM:" ) .. " " ..  GRM.L ( "{num} Join Dates Have Been Confirmed." , nil , nil , count ) );
    end

end

-- Method:          GRM.GetNumUnverifiedJoinDates()
-- What it Does:    Returns the integer count of the number of players with unverified join dates.
-- Purpose:         Quality of life reporting how many there are to do
GRM.GetNumUnverifiedJoinDates = function()
    local count = 0;
    local guildData = GRM.GetGuild();

    for _ , player in pairs ( guildData ) do
        if type ( player ) == "table" then
            if #player.joinDateHist > 0 and player.joinDateHist[1][1] ~= 0 and player.joinDateHist[1][6] == false then
                count = count + 1;
            end
        end
    end

    return count;
end

-- Method:          GRM.GetNumUnverifiedPromoDates()
-- What it Does:    Returns the integer count of the number of players with unverified rank change dates.
-- Purpose:         Quality of life reporting how many there are to verify
GRM.GetNumUnverifiedPromoDates = function()
    local count = 0;
    local guildData = GRM.GetGuild();

    for _ , player in pairs ( guildData ) do
        if type ( player ) == "table" then
            if #player.rankHist > 0 and player.rankHist[1][2] ~= 0 and player.rankHist[1][7] == false then
                count = count + 1;
            end
        end
    end

    return count;
end


--------------------------------------
------ END OF METADATA LOGIC ---------
--------------------------------------
-----------------------------
--- NOTIFICATION TRACKING ---
-----------------------------

-- Method:          GRM.NotificationCheck( boolean , int , int , string )
-- What it Does:    Checks if you have any notifications you are tracking, and if so, reports the status change
-- Purpose:         Since some may wish to throttle the speed at which they scan for changes, or disable it altogether, this status check system needs to be an independent
--                  check. It also would be unwise to set a notification to tell you a player came back from being AFK, but your scan for changes was set to once per 10 minutes. Useless!
--                  This independence is not yet implemented and is intertwined into the status check system...
GRM.NotificationCheck = function( isOnline , status , i , name )
    local updateNeeded = false;

    if GRM_G.ActiveStatusQue[i][3] == 2 or GRM_G.ActiveStatusQue[i][3] == 3 then
        if GRM_G.ActiveStatusQue[i][2] ~= isOnline then
            if isOnline then
                GRM.Report ( "\n|cffff0000" .. GRM.L ( "NOTIFICATION:" ) .. "|r |CFFFFFFFF" .. GRM.L ( "{name} is now ONLINE!" , GRM.GetStringClassColorByName ( GRM_G.ActiveStatusQue[i][1] ) .. GRM.SlimName ( GRM_G.ActiveStatusQue[i][1] ) .. "|r" ) .. "\n" );
            else
                GRM.Report ( "\n|cffff0000" .. GRM.L ( "NOTIFICATION:" ) .. "|r |CFFFFFFFF" .. GRM.L ( "{name} is now OFFLINE!" , GRM.GetStringClassColorByName ( GRM_G.ActiveStatusQue[i][1] ) .. GRM.SlimName ( GRM_G.ActiveStatusQue[i][1] ) .. "|r" ) .. "\n" );
            end
            table.remove ( GRM_G.ActiveStatusQue , i );
            updateNeeded = true;
        end
    else
        if status == 0 then
            if isOnline then
                GRM.Report ( "\n|cffff0000" .. GRM.L ( "NOTIFICATION:" ) .. "|r |CFFFFFFFF" .. GRM.L ( "{name} is No Longer AFK or Busy!" , GRM.GetStringClassColorByName ( GRM_G.ActiveStatusQue[i][1] ) .. GRM.SlimName ( GRM_G.ActiveStatusQue[i][1] ) .. "|r" ) .. "\n" );
            else
                GRM.Report ( "\n|cffff0000" .. GRM.L ( "NOTIFICATION:" ) .. "|r |CFFFFFFFF" .. GRM.L ( "{name} is No Longer AFK or Busy, but they Went OFFLINE!" , GRM.GetStringClassColorByName ( GRM_G.ActiveStatusQue[i][1] ) .. GRM.SlimName ( GRM_G.ActiveStatusQue[i][1] ) .. "|r" )  .. "\n" );
            end
            table.remove ( GRM_G.ActiveStatusQue , i );
            updateNeeded = true;
        end
    end

    local player = GRM.GetPlayer ( name );
    player.status = status;
    player.isOnline = isOnline;

    if updateNeeded and GRM_UI.GRM_MemberDetailMetaData:IsVisible() then
        GRM.PopulateMemberDetails ( GRM_G.currentName );
    end

end

-- Method:          GRM.NotificationIndependentChecker()
-- What it Does:    Activates a notification check loop if any notifications are out there or are outstanding
-- Purpose          Keep the notifications on their own separate loop from the scanning so they update rather quickly.
GRM.NotificationIndependentChecker = function()
    local timer = 10;

    for i = 1 , #GRM_G.ActiveStatusQue do
        for j = 1 , GRM.GetNumGuildies() do
            -- For guild info
            local name , _ , _ , _ , _ , _ , _ , _ , isOnline , status = GetGuildRosterInfo ( j );

            if name == GRM_G.ActiveStatusQue[i][1] then
                GRM.NotificationCheck ( isOnline , status , i , name );
                break;
            end

        end
    end

    -- Re-Check if notifications still are on there.
    if #GRM_G.ActiveStatusQue > 0 then
        if ( GRM_G.BuildVersion < 80000 and GuildFrame:IsVisible() ) or ( GRM_G.BuildVersion >= 80000 and CommunitiesFrame:IsVisible() ) then
            timer = 1;  -- if these windows are open the server authorizes player guild roster updates on the fly (less than 1 second)
        end

        C_Timer.After ( timer , function()     -- Guild Roster only updates once per 10 seconds
            GRM.GuildRoster();
            C_Timer.After ( 1 , function()
                GRM.NotificationIndependentChecker();
            end);
        end);
    end
end
        
----------------------
-- EVENT TRACKING!!!!!
----------------------

-- Method:          GRM.SetBirthdayFrameLogic()
-- What it Does:    Sets the birthdate and resets the frames as needed
-- Purpose:         To keep presentation clean!
GRM.SetBirthdayFrameLogic = function()
    local day = GRM_G.dayIndex;
    local month = GRM_G.monthIndex;
    local timeStampFormat = tostring ( day ) .. " " .. monthEnum2 [ tostring ( month ) ] .. " '22";      -- The year is just a placeholder to be parsed out... without needing to rewrite a bunch of logic - just ignore
    GRM.SetBirthday ( GRM_G.currentName , day , month , 1 , timeStampFormat , time() );

    -- Birthday Text logic...
    GRM_UI.GRM_MemberDetailMetaData.GRM_BirthdayText:SetText ( GRM.FormatTimeStamp ( timeStampFormat , false , true ) );
    GRM_UI.GRM_MemberDetailMetaData.GRM_BirthdayText:Show();
    GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailBirthdayButton:Hide();

    -- Promo Window

    local player = GRM.GetPlayer ( GRM_G.currentName );
    if player then
        if #player.rankHist[1][5] == 1 and not player.promoteDateUnknown then
            GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailRankDateTxt:Hide();
            GRM_UI.GRM_MemberDetailMetaData.GRM_SetPromoDateButton:Show();
        else
            GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailRankDateTxt:Show();
        end
    end

    -- Frame Logic
    GRM_UI.GRM_MemberDetailMetaData.GRM_DayDropDownMenuSelected:Hide();
    GRM_UI.GRM_MemberDetailMetaData.GRM_MonthDropDownMenuSelected:Hide();
    GRM_UI.GRM_MemberDetailMetaData.GRM_DateSubmitCancelButton:Hide();
    GRM_UI.GRM_MemberDetailMetaData.GRM_DateSubmitButton:Hide();

    if GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame:IsVisible() then
        GRM.RefreshAuditFrames ( true , true );
    end
end

-- Method:          GRM.SetBirthday ( string , int , int , int , string , int , boolean , string , boolean )
-- What it Does:    Sets the player's birthday
-- Purpose:         To take advantage of the player birthdate feature!
GRM.SetBirthday = function ( name , day , month , year , date , timeStamp , isSync , sender , isFullSync )
    local player = GRM.GetPlayer ( name );
    if player then
        if player.events[2][4] < timeStamp then
            player.events[2][1] = { day , month , year };
            player.events[2][2] = false;
            player.events[2][3] = date;
            player.events[2][4] = timeStamp;

            if player.birthdayUnknown then
                player.birthdayUnknown = false
            end

            GRM.RemoveFromCalendarQue ( player.name , 2 , nil );

            -- Check Alts as well
            GRM.SetBirthdayForAltGrouping ( name , day , month , year , date , timeStamp );

            -- Now, send the details out...
            if not isFullSync then
                if not isSync then
                    if GRM.S().syncBDays and GRM.S().syncEnabled then
                        local syncRankFilter = GRM.S().syncRank;
                        if GRM.S().exportAllRanks then
                            syncRankFilter = GuildControlGetNumRanks() - 1;
                        end
                        GRMsync.SendMessage ( "GRM_SYNC" , GRM_G.PatchDayString .. "?GRM_BDAY?" .. syncRankFilter .. "?" .. name .. "?" .. tostring ( day ) .. "?" .. tostring ( month ) .. "?" .. date .. "?" .. tostring ( timeStamp ) , "GUILD" );
                    end
                    GRM.Report ( GRM.L ( "{name}'s Birthday has been set: {custom1}" , GRM.GetClassifiedName ( name , true ) , nil , nil , GRM.FormatTimeStamp ( date , false , true ) ) );
                elseif isSync then
                    if GRM.S().syncChatEnabled then
                        GRM.Report ( GRM.L ( "{name} has set {name2}'s Birthday: {custom1}" , GRM.GetClassifiedName ( sender , true ) , GRM.GetClassifiedName ( name , true ) , nil , GRM.FormatTimeStamp ( date , false , true ) ) );
                    end
                end
            else
                GRMsyncGlobals.updateCount = GRMsyncGlobals.updateCount + 1;
                GRMsyncGlobals.updatesEach[6] = GRMsyncGlobals.updatesEach[6] + 1;
            end

            -- Update frames if looking at them on the spot...
            if GRM_UI.GRM_MemberDetailMetaData:IsVisible() and name == GRM_G.currentName and GRM.S().showBDay then
                GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailBirthdayButton:Hide();
                GRM_UI.GRM_MemberDetailMetaData.GRM_BirthdayText:SetText ( GRM.FormatTimeStamp ( date , false , true ) );
                GRM_UI.GRM_MemberDetailMetaData.GRM_BirthdayText:Show();
            end

            if GRM_UI.GRM_RosterChangeLogFrame.GRM_EventsFrame:IsVisible() then
                GRM.RefreshAddEventFrame()
            end
        end
    end
end

-- Method:          GRM.CleanupBirthdays ( int , int )
-- What it Does:    Searches for all matches of this birthdate, and resets them to default empty value
-- Purpose:         Help cleanup a bug introduced from 1.33
GRM.CleanupBirthdays = function ( day , month , forceOthers , g )
    if type ( day ) == "number" and type ( month ) == "number" then
        if day > 0 and day < 32 and month > 0 and month < 13 then
            local guildData = g or GRM.GetGuild();
            local count = 0;
            local timeStamp = 0;
            if forceOthers then
                timeStamp = time();
            end
            for member in pairs ( guildData ) do
                if type ( guildData[member] ) == "table" then
                    if guildData[member].events[2][1][1] == day and guildData[member].events[2][1][2] == month then
                        guildData[member].events[2] = { { 0 , 0 , 0 } , false , "" , timeStamp };
                        count = count + 1;
                    end
                end
            end
            if count > 0 then
                GRM.Report ( GRM.L ( "{num} birthdays have been reset." , nil , nil , count ) );
            else
                GRM.Report ( GRM.L ( "No player was found to have that birthday." ) );
            end

        else
            if not ( day > 0 and day < 32 ) then
                GRM.Report ( GRM.L ( "The day cannot be {num}. It must be a number between 1 and 31" , nil , nil , day ) );
            end
            if not ( month > 0 and month < 13 ) then
                GRM.Report ( GRM.L ( "The month cannont be {num}. must be a number between 1 and 12" , nil , nil , month ) );
            end
        end
    else
        if type ( day ) ~= "number" then
            GRM.Report ( GRM.L ( "{num} is not a valid day of the month! It must be a number between 1 and 31" , nil , nil , day ) );
        end
        if type ( month ) ~= "number" then
            GRM.Report ( GRM.L ( "{num} is not a valid index of the month of the year! It must be a number between 1 and 12" , nil , nil , month ) );
        end
    end
end

-- Method:          GRM.GetCleanTimestamp ( string )
-- What it Does:    Returns the timestamp formatted properly
-- Purpose:         Clean the timestamp for proper parsing and formatting.
GRM.GetCleanTimestamp = function ( timestamp )
    return string.match ( timestamp , "%d.+'%d%d" );
end

-- Method:          GRM.GetEventYear ( string )
-- What it Does:    Returns the year of the given event from timestamp
-- Purpose:         Keep code clutter down, put this block in reusable form.
GRM.GetEventYear = function ( timestamp )
    -- timestamp format = "Day month year hour min"
    local result = 0;
    if timestamp ~= "" and timestamp ~= nil then
        result = tonumber ( string.match ( timestamp , "'(%d%d)" ) ) + 2000;
    end
    return result;
end

-- Method:          GRM.GetEventMonth ( string )
-- What it Does:    Returns the 3 letter string of the name of the month of the event.
-- Purpose:         Again, avoid code cludder. For event tracking, knowing exact date is essential.
GRM.GetEventMonth = function ( timestamp )
    if timestamp == "" or timestamp == nil then
        return nil;
    else
        return string.match ( timestamp , "%a+" );
    end
end

-- Method:          GRM.GetEventMonthEnumResult ( string )
-- What it Does:    Returns the integer index representative of the month of the year. Jan = 1 and Dec = 12
-- Purpose:         Accessibility to Enum from outside this class.
GRM.GetEventMonthEnumResult = function ( month )
    return monthEnum [ month ];
end

-- Method:          GRM.GetEventDay ( string )
-- What it Does:    Returns the number of the day, as a string, based on day of the month for given event timestamp
-- Purpose:         Important to know what day event should happen on.
GRM.GetEventDay = function ( timestamp )
    if timestamp == "" or timestamp == nil then
        return nil;
    else
        return tonumber ( string.match ( timestamp , "%d+" ) );
    end
end

-- Method:          GRM.IsCalendarEventAlreadyAdded ( string , string , int , int , int , int )
-- What it Does:    Returns true if the event has already been added to the calendar 
-- Purpose:         If the player wipes his save history, it does not wipe what is added to in-game calendar. This just double-checks to avoid double adding.
GRM.IsCalendarEventAlreadyAdded = function ( name , title , day , month , year , typeIndex )

    local titleGeneric = "";
    if typeIndex == 1 then
        titleGeneric = GRM.SlimName ( name ) .. "'s Anniversary!";     -- The title argument received is properly sourced, this just adds a layer of compatibility for guilds that might use a combo of English in the guild and their own translation.
    elseif typeIndex == 2 then
        titleGeneric = GRM.SlimName ( name ) .. "'s Birthday!";
    end
    
    local result = false;
    local monthIndex = 0;
    local monthInfo;
    local dayEvent;

    for i = 0 , 24 do                       -- Let's get to the right month on the calendar
        monthInfo = C_Calendar.GetMonthInfo( i );
        if monthInfo.month == month and monthInfo.year == year then
            monthIndex = i;
            break;
        end
    end
    for i = 1 , C_Calendar.GetNumDayEvents ( monthIndex , day ) do         -- Let's look at all the events on the day of the event
        dayEvent = C_Calendar.GetDayEvent ( monthIndex , day , i ).title;
        if dayEvent == titleGeneric or dayEvent == title then
            result = true;
            break;
        end
    end
    return result;
end

-- Method:          GRM.IsOnAnnouncementList ( string , int , string )
-- What it Does:    returns true if the player is in the que to add to the calendar
-- Purpose:         Avoid double adding to que, and basic logic checking.
GRM.IsOnAnnouncementList = function ( name , index , eventName )

    local result = false;
    local calendarQ = GRM.GetEvents();

    for i = 1 , #calendarQ do
        if calendarQ[i][1] == name then

            -- Anniversary and Birthday
            if index < 3 and calendarQ[i][7] == index then              -- Helps to check against index so people of multiple localizations can be compared without compatibility issues
                result = true;

                -- Custom
            elseif index > 2 and calendarQ[i][2] == eventName then      -- Custom events are not localized as the "titles" will be unique to what the user put.
                result = true;
            end

            if result then
                break;
            end
        end
    end
    return result;
end

-- Method:          GRM.RemoveFromCalendarQue ( string , int , string )
-- What it Does:    Removes the player/event from the global Calendar Add Que table
-- Purpose:         Keep the Que Clean
GRM.RemoveFromCalendarQue = function ( name , index , eventName )
    local calendarQ = GRM.GetEvents();
    
    for i = 1 , #calendarQ do
        if calendarQ[i][1] == name then

            if index < 3 and calendarQ[i][7] == index then      -- position 7 will may either be 1 or 2
                table.remove ( calendarQ , i );
                break;
            elseif index > 2 and calendarQ[i][2] == eventName then
                table.remove ( calendarQ , i );
                break;
            end

        end
    end
end

-- Method:          GRM.RemoveAllFromEventQue()
-- What it Does:    Adds a popup window to confirm if the player wishes to remove all the players from the calendar que and then does that if confirmed
-- Purpose:         Give the option for the player to more easily clean up the calendar que.
GRM.RemoveAllFromEventQue = function()
    local msg = "";
    local calendarQ = GRM.GetEvents();
    local num = #calendarQ;
    
    -- Function for the popup window
    local removeAllEvents = function()
        GRM_CalendarAddQue_Save[GRM_G.guildName] = {};
        GRM.Report ( GRM.L ( "All events have been removed." ) );

        if GRM_UI.GRM_RosterChangeLogFrame.GRM_EventsFrame:IsVisible() then
            GRM.RefreshAddEventFrame();
        end
    end

    if num > 0 then
        
        if GRM_G.BuildVersion >= 30000 and CanEditGuildEvent() then
            if num == 1 then
                msg = GRM.L ( "This event has not yet been added to the calender. Are you sure?" );
            else
                msg = GRM.L ( "{num} events have not yet been added to the calendar. Are you sure?" , nil , nil , num );
            end

        else
            msg = GRM.L ( "Please confirm the removal of {num} events." , nil , nil , num );
        end

        GRM.SetConfirmationWindow ( removeAllEvents , msg );
    else
        GRM.Report ( GRM.L ( "There are no events listed here to remove." ) );
    end
end

-- Method:          GRM.CalendarQueCheck ()
-- What it Does:    It checks the Add Que list, if the event is already on the calendar, then it removes it from the addque list.
-- Purpose:         In case other players add items to the calendar, this keeps it clean.
GRM.CalendarQueCheck = function ()
    if GRM_G.BuildVersion >= 30000 then
        local calendarQ = GRM.GetEvents();

        for i = #calendarQ , 1 , -1 do
            if GRM.IsCalendarEventAlreadyAdded ( GRM.SlimName ( calendarQ[i][1] ) , calendarQ[i][2] , calendarQ[i][4] , calendarQ[i][3] , calendarQ[i][5] , calendarQ[i][7] ) then
                table.remove ( calendarQ , i );
            end
        end
    end
end

-- Method:          GRM.GetAnniversaryLogReport( string , string , int )
-- What it Does:    Returns the proper string of the annivesary events, both formats. One for UI display, and one for readabilty
-- Purpose:         For the addon feature of reporting and adding the anniversary to the calendar.
GRM.GetAnniversaryLogReport = function ( name , class , numYears )
    local result;
    local classifiedName = GRM.GetClassColorRGB ( class , true ) .. GRM.SlimName ( name ) .. "|r";

    if numYears == 1 then
        result = GRM.L ( "{name} will be celebrating {num} year in the Guild!" , classifiedName , nil , numYears );
    else
        result = GRM.L ( "{name} will be celebrating {num} years in the Guild!" , classifiedName , nil , numYears );
    end
    return result;
end

-- Method:          GRM.GetBirthdayLogReport( string )
-- What it Does:    Returns the proper string of the birthday events, both formats. One for UI display, and one for readabilty
-- Purpose:         For the addon feature of reporting and adding the anniversary to the calendar.
GRM.GetBirthdayLogReport = function ( name , class )
    local classifiedName = GRM.GetClassColorRGB ( class , true ) .. GRM.SlimName ( name ) .. "|r";
    
    return GRM.L ( "Happy Birthday, {name}!" , classifiedName );
end

-- Method:          GRM.GetCustomEventReport( string , int , string )
-- What it Does:    Returns the proper string of the custom events, both formats. One for UI display, and one for readabilty
-- Purpose:         For the addon feature of reporting and adding the anniversary to the calendar.
-- GRM.GetCustomEventReport = function ( name , numYears , eventDate )
--     local result , result2;

--     return result , result2;
-- end

-- Method:          GRM.ResetPlayerEvent ( string , int , string )
-- What it Does:    It checks if the event is on the eventsLog announcecment, and then if so, removes it.
-- Purpose:         Events log needs to be adjusted as the player adjusts the settings. This is used for many conditions, so it keeps it in one reusable function.
GRM.ResetPlayerEvent = function ( name , index , eventName )
    if GRM.IsOnAnnouncementList ( name , index , eventName ) then
        GRM.RemoveFromCalendarQue ( name , index , eventName );
    end
end

-- Method:          GRM.CleanupEventsFromplayers ()
-- What it Does:    If the player is not found in the guild but they are still on the event list, just dump the event list.
-- Purpose:         Cleanup events QoL
GRM.CleanupEventsFromplayers = function ()
    local cleanupHappened = false;
    local calendarQ = GRM.GetEvents();

    for i = #calendarQ , 1 , -1 do
        if not GRM.GetPlayer ( calendarQ[i][1] ) then
            table.remove ( calendarQ , i );
            cleanupHappened = true;
        end
    end

    if cleanupHappened and GRM_UI.GRM_RosterChangeLogFrame.GRM_EventsFrame:IsVisible() then
        GRM.RefreshAddEventFrame();
        
    end
end

-- Method:          GRM.CheckPlayerEvents ()
-- What it Does:    Scans through all players'' "events" of the given guild and updates if any are pending
-- Purpose:         Event Management for Anniversaries, Birthdays, and Custom Events
GRM.CheckPlayerEvents = function ()

    -- including anniversary, birthday , and custom
    local month , day , year = select ( 2 , GRM.GetTodaysDate() );
    local eventMonthIndex , eventDay , eventYear , isLeapYear , description;
    local title = "";

    -- Quickly cleanup the list if necessary
    GRM.CleanupEventsFromplayers();
    local playerSlimName;
    local guildData = GRM.GetGuild();
    local cleanupHappened = false;

    for _ , player in pairs ( guildData ) do
        if type ( player ) == "table" then
            playerSlimName = GRM.SlimName ( player.name );

            -- Player identified, now let's check his event info!
            for r = 1 , #player.events do          -- Loop all events to check!

                if r > 2 or ( r == 1 and GRM.S().annivAnnounce ) or ( r == 2 and GRM.S().bdayAnnounce ) then
                    description = "";
                    title = "";
                    
                    eventDay = player.events[r][1][1];
                    eventMonthIndex = player.events[r][1][2];
                    eventYear = player.events[r][1][3];
                    if not eventYear or ( r == 2 and eventYear < 2000 ) then
                        eventYear = year;
                    end

                    local daysTil = GRM.GetDaysBetweenDates ( { day , month , year } , { eventDay , eventMonthIndex , eventYear } );

                    -- Not reported AND there is a day recorded...
                    if not player.events[r][2] and player.events[r][1][1] ~= 0 and ( r > 2 or ( r < 3 and ( not GRM.S().onlyAnnounceForMain or player.isMain ) ) ) then        -- if it has already been reported, then we are good!

                        -- Now, let's check if it needs to be reported!
                        if GRM.S().calendarAnnouncements and daysTil <= GRM.S().eventAdvanceDays then

                            -- YES! It needs reporting! It is within the threshold!
                            -- Configure some of the dates
                            local numYears = year - eventYear;
                            if month == 12 and eventMonthIndex == 1 then
                                numYears = numYears + 1;
                            end
                            
                            if ( eventDay == 29 and eventMonthIndex == 2 ) and not isLeapYear then    -- If anniversary happened on leap year date, and the current year is NOT a leap year, then put it on 1 Mar.
                                eventDay = 1;
                                eventMonthIndex = 3;
                            end
                            
                            -- Join Date Anniversary -- Let's see if player has it set to ONLY announce anniversary event on Calendar for a player's "main"
                            if r == 1 and numYears ~= 0 then

                                title = GRM.L ( "{name}'s Anniversary!" , playerSlimName );
                                description = GRM.GetAnniversaryLogReport ( player.name , player.class , numYears )
                                GRM.AddEventEntry ( r , player.name ,  player.class , eventDay , eventMonthIndex , isLeapYear , select ( 2 , GRM.GetTimestamp() ) , numYears );

                            elseif r == 2 then

                                title = GRM.L ( "{name}'s Birthday!" , playerSlimName );
                                description = GRM.GetBirthdayLogReport ( player.name , player.class )
                                GRM.AddEventEntry ( r , player.name ,  player.class , eventDay , eventMonthIndex , isLeapYear , select ( 2 , GRM.GetTimestamp() ) );

                            end
                            
                            -- Now, let's add it to the calendar!!!
                            if description ~= "" then
                                local finalYear = year;
                                if month == 12 and eventMonthIndex == 1 then
                                    finalYear = finalYear + 1;
                                end 

                                if ( GRM_G.BuildVersion < 30000 or ( GRM_G.BuildVersion >= 30000 and not GRM.IsCalendarEventAlreadyAdded ( playerSlimName , title , eventDay , eventMonthIndex , finalYear , r ) ) ) and not GRM.IsOnAnnouncementList ( player.name , r , title ) then

                                    GRM.InsertNewEvent ( player.name , title , eventDay , eventMonthIndex , finalYear , description , r );

                                    cleanupHappened = true;

                                end
                            end
                            -- This has been reported, save it!
                            player.events[r][2] = true;
                        end
                        
                    -- Resetting the event report to false if parameters meet
                    elseif player.events[r][2] then  -- It is still true! Event has been reported! Let's check if time has passed sufficient to wipe it to false

                        if ( daysTil > GRM.S().eventAdvanceDays ) or ( GRM.S().onlyAnnounceForMain and not player.isMain  ) then     -- Event is behind us now

                            player.events[r][2] = false;
                            GRM.ResetPlayerEvent ( player.name , r , title );
                            cleanupHappened = true;

                        end
                    end
                -- No longer tracking, let's remove.
                elseif player.events[r][2] then
                    player.events[r][2] = false;
                    GRM.ResetPlayerEvent ( player.name , r , "" );
                    cleanupHappened = true;
                end
            end
        end
    end

    if cleanupHappened and GRM_UI.GRM_RosterChangeLogFrame.GRM_EventsFrame:IsVisible() then
        GRM.RefreshAddEventFrame();
    end
    
end

-- Method:          GRM.InsertNewEvent ( string , string , int , int , int , string , int )
-- What it Does:    Inserts new event sorted by date, and if the same day, then sorted by name order
-- Purpose:         Cleanly insert the event into the array in order of date most soon, for UI purposes
GRM.InsertNewEvent = function ( name , title , eventDay , eventMonthIndex , finalYear , description , type )
    local epochTime = tonumber ( GRM.ConvertToStandardFormatDate ( eventDay , eventMonthIndex , finalYear ) );
    local calendarQ = GRM.GetEvents();
    
    if #calendarQ == 0 then
        table.insert ( calendarQ , { name , title , eventMonthIndex , eventDay , finalYear , description , type , epochTime } );
    else
        -- Sort in order
        local insertPoint = 0;

        for i = 1 , #calendarQ do

            -- Redundancy due to DB changes
            if not calendarQ[i][8] then
                calendarQ[i][8] = GRM.ConvertToStandardFormatDate ( calendarQ[i][4] , calendarQ[i][3] , calendarQ[i][5] );
            end

            if calendarQ[i][8] >= epochTime then
                if calendarQ[i][8] > epochTime then
                    insertPoint = i;
                else
                    -- Equal numbers
                    for j = i , #calendarQ do
                        if calendarQ[j][8] > epochTime then
                            -- No longer equal, we've passed same day
                            insertPoint = j;
                            break;
                        else
                            -- same epochTime, let's compare names
                            if calendarQ[j][1] > name then
                                insertPoint = j;
                                break;
                            end
                        end
                    end
                end
                break;
            end
        end
        if insertPoint == 0 then
            table.insert ( calendarQ , { name , title , eventMonthIndex , eventDay , finalYear , description , type , epochTime } );
        else
            table.insert ( calendarQ , insertPoint , { name , title , eventMonthIndex , eventDay , finalYear , description , type , epochTime } );
        end
    end
end

-- Method:          GRM.AddAnnouncementToCalendar ( string , int , int , int , string )
-- What it Does:    Adds the announcement to the in-game calendar, if player has permissions to do so.
-- Purpose:         CalendarAddEvent() is a protected function thus it needs to be triggered by a player in-game action, so it will
--                  be linked to a button on the "GRM_UI.GRM_RosterChangeLogFrame.GRM_EventsFrame" window. Again, this cannot be activated, it WILL NOT WORK without 
--                  in-game action to remove protection on function
GRM.AddAnnouncementToCalendar = function ( title , eventMonthIndex , eventDay , year , description )
    C_Calendar.CloseEvent()                           -- Just in case previous event was never closed, either by other addons or by player
    local month, day, _ , hourServer , minServer = select ( 2 , GRM.GetTodaysDate() );
    if not hourServer then
        hourServer, minServer = GetGameTime();
    end

    local hour = 0;                                 -- 24hr scale, on when to add it...
    local min = 5;

    if eventMonthIndex == month and eventDay == day then      -- Add current time now!
        hour = hourServer;
        min = minServer;

        local tempMin = min;
        min = min - ( min % 5 ) + 5;    -- To get incrememnt by 5
        if min == 60 then
            if tempMin <= 55 then
                min = 55;
            else
                min = tempMin;
            end
        end
    end

    -- C_Calendar.NewGuildAnnouncement();
    C_Calendar.CreateGuildAnnouncementEvent()
    C_Calendar.EventSetDate ( eventMonthIndex , eventDay , year );
    C_Calendar.EventSetTitle ( title );
    C_Calendar.EventSetDescription ( GRM.RemoveStringColoring ( description ) ); -- No need to include the date at the end.
    C_Calendar.EventSetTime ( hour , min );    
    C_Calendar.EventSetType ( Enum.CalendarEventType.Other );     -- 4 = Other/Announcement
    C_Calendar.AddEvent();
    C_Calendar.CloseEvent();
end

--------------------------------
-------- LOG CONTROLS ----------
--------------------------------

-- Method:          GRM.RemoveItemFromLog ( index , bool , bool )
-- What it Does:    Finds the matching string in the log, and removes it from the tempFiltered Log and the core log.
-- Purpose:         For quick log cleanup.
-- Notes:           Worth mentioning, one of the reasons it is handled this way is because you want to clear the lines but not do a full refresh of the log, which takes
--                  processing, but more importantly, resets the slider to the top. This allows you to clear as you move and continue on.
GRM.RemoveItemFromLog = function ( index , buildLog , buildComplete )

    local tempIndex = GRM_G.fullLogMatch[index][5];         -- This is identifying index. If repeated, it is a multi-line input to the log entry.
    local tempText = GRM_G.fullLogMatch[index][6];

    local i = 1;
    local isFound = false;

    -- Remove it from the tempLog
    while i <= #GRM_G.fullLogMatch and ( not isFound or ( isFound and GRM_G.fullLogMatch[i][5] == tempIndex ) ) do
        if GRM_G.fullLogMatch[i][5] == tempIndex then
            isFound = true;
            table.remove ( GRM_G.fullLogMatch , i );
        else
            i = i + 1;
        end
    end

    -- Shift all values by 1, since we are removing
    if i > 1 then
        for j =  ( i - 1 ) , #GRM_G.fullLogMatch do
            GRM_G.fullLogMatch[j][5] = GRM_G.fullLogMatch[j][5] - 1;
        end
    end

    -- Remove from core. 
    for i = #GRM.GetLog() , 1 , -1 do
        if GRM.GetLog()[i][2] == tempText then
            table.remove ( GRM.GetLog() , i );
            break;
        end
    end

    if buildLog and GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame:IsVisible() then
        GRM_G.LogNumbersColorUpdate = true;
        GRM.BuildLogComplete( true , buildComplete );
    end
end

-- Method:          GRM.ClearAllLogLinesWithinRange ( int , int )
-- What it Does:    Parse through all of the fontstrings visible, then matches them to the log and purges them
-- Purpose:         For log cleanup and UI features for the user
GRM.ClearAllLogLinesWithinRange = function ( start , stop )
    
    if start == 0 then
        start = 1;
    end

    local totalCount = stop - start + 1;
    local log = GRM_G.fullLogMatch;
    local index = 0;

    for i = 1 , #log do
        if index ~= log[i][4] and log[i][5] >= start and log[i][5] <= stop then
            index = log[i][4]
            -- Next entry!
            table.remove ( GRM.GetLog() , log[i][4] );
            -- You need to keep incrementing because the table will be shrinking.

        elseif log[i][5] > stop then
            break;      -- easy escape to not process everything!
        end
    end

    GRM_G.CurrentTotalCount = GRM_G.CurrentTotalCount - totalCount;

    GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_RosterChangeLogFrameNumEntriesText:SetText ( GRM.L ( "Total Entries: {num}" , nil , nil , GRM_G.CurrentTotalCount ) );

    if totalCount == 1 then
        GRM.Report ( GRM.L ( "1 entry has been removed from the log" ) );
    else
        GRM.Report ( GRM.L ( "{num} entries have been removed from the log" , nil , nil , totalCount ) );
    end

end

-- Method:          GRM.ResetLogReport()
-- What it Does:    Deletes the guild Log
-- Purpose:         In case player wishes to reset guild Log information.
GRM.ResetLogReport = function()
    if #GRM.GetLog() == 0 then
        GRM.Report ( GRM.L ( "There are No Log Entries to Delete, silly {name}!" , GRM.GetClassifiedName ( GRM_G.addonUser , true ) ) );
    else
        GRM.Report ( GRM.L ( "Guild Log has been RESET!" ) );
        GRM_LogReport_Save[GRM_G.guildName] = {};

        GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_LogEditBox:SetText( GRM.L ( "Search Filter" ) );
        if GRM_UI.GRM_RosterChangeLogFrame:IsVisible() then    -- if frame is open, let's rebuild it!
            GRM.BuildLogComplete( true , true );
        end
    end
end

-- Method:          GRM.LogSetLastValue()
-- What it Does:    Triggers the setting fo all values at index 40 of the core log
-- Purpose:         On the single line shift, you end up with 1 on the edge that needs to be built
GRM.LogSetLastValue = function()
    GRM.SetLogValues ( #GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_RosterChangeLogScrollChildFrame.AllButtons , GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_RosterChangeLogScrollChildFrame.Offset );
end

-- Method:          GRM.LogSetFirstValue()
-- What it Does:    Triggers the setting fo all values at index 1 of the core Log
-- Purpose:         On the single line shift, you end up with 1 on the edge that needs to be built
GRM.LogSetFirstValue = function()
    GRM.SetLogValues ( 1 , GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_RosterChangeLogScrollChildFrame.Offset - #GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_RosterChangeLogScrollChildFrame.AllButtons + 1 );
end

-- Method:          GRM.LogToolHybridShiftDown()
-- What it Does:    Shifts all the values down one line to give the illusion of scrolling when in reality this is just a hybrid scrollframe
-- Purpose:         Clean scrolling
GRM.LogToolHybridShiftDown = function()
    if #GRM_G.fullLogMatch > 25 then
        local fontStrings = GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_RosterChangeLogScrollChildFrame.AllButtons;
        local MouseOverButton = 0;
        -- Shift them down...
        for i = 1 , #fontStrings - 1 do
            fontStrings[i][2]:SetText( fontStrings[i+1][2]:GetText() );
            fontStrings[i][2]:SetTextColor ( fontStrings[i+1][2]:GetTextColor ( fontStrings[i+1][2]:GetText() ) );
            fontStrings[i][3]:SetText( fontStrings[i+1][3]:GetText() );
            fontStrings[i][3]:SetTextColor ( fontStrings[i+1][3]:GetTextColor ( fontStrings[i+1][3]:GetText() ) );
            fontStrings[i][4] = fontStrings[i+1][4]

            if MouseOverButton == 0 and fontStrings[i][1]:IsMouseOver() then
                MouseOverButton = i;
            end
        end
        GRM.LogSetLastValue();
        if MouseOverButton > 0 then
            GRM.RefreshLogTooltip( fontStrings[MouseOverButton][1] );
        end
    end
end

-- Method:          GRM.LogToolHybridShiftUP()
-- What it Does:    Shifts all the values up one line to give the illusion of scrolling when in reality this is just a hybrid scrollframe
-- Purpose:         Clean scrolling
GRM.LogToolHybridShiftUP = function()
    if #GRM_G.fullLogMatch > 25 then
        local fontStrings = GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_RosterChangeLogScrollChildFrame.AllButtons;
        local MouseOverButton = 0;
        -- Shift them down...
        for i = #fontStrings , 2 , -1 do
            fontStrings[i][2]:SetText( fontStrings[i-1][2]:GetText() );
            fontStrings[i][2]:SetTextColor ( fontStrings[i-1][2]:GetTextColor ( fontStrings[i-1][2]:GetText() ) );
            fontStrings[i][3]:SetText( fontStrings[i-1][3]:GetText() );
            fontStrings[i][3]:SetTextColor ( fontStrings[i-1][3]:GetTextColor ( fontStrings[i-1][3]:GetText() ) );
            fontStrings[i][4] = fontStrings[i-1][4]
            -- Configure new SetPoints due to varying string sizes

            if MouseOverButton == 0 and fontStrings[i][1]:IsMouseOver() then
                MouseOverButton = i;
            end
        end
        GRM.LogSetFirstValue();
        if MouseOverButton > 0 then
            GRM.RefreshLogTooltip( fontStrings[MouseOverButton][1] );
        end
    end
end

-- Method:          GRM.ConfigureChangesHeader()
-- What it Does:    Configures the changes header to add it
-- Purpose:         To Clear the changes header
GRM.ConfigureChangesHeader = function()
    local neededToAddChanges = false;
    if GRM_G.FirstTimeViewed and GRM_G.IndexOfLastLogEntry ~= #GRM.GetLog() and #GRM.GetLog() > 0 then
        neededToAddChanges = true
        -- Fontstring rules
        GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_RosterChangeLogScrollChildFrame.GRM_ChangesHeader:SetJustifyH ( "LEFT" );
        GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_RosterChangeLogScrollChildFrame.GRM_ChangesHeader:SetWidth ( 561 );
        GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_RosterChangeLogScrollChildFrame.GRM_ChangesHeader:SetSpacing ( 7 );
        GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_RosterChangeLogScrollChildFrame.GRM_ChangesHeader:SetWordWrap ( false );
        GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_RosterChangeLogScrollChildFrame.GRM_ChangesHeader:SetFont ( GRM_G.FontChoice , GRM_G.FontModifier + 10.79 );
        GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_RosterChangeLogScrollChildFrame.GRM_ChangesHeader:SetText ( GRM.AddNewChangesHeader() );
        
        -- Set Point to the top
        GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_RosterChangeLogScrollChildFrame.GRM_ChangesHeader:SetPoint ( "TOPLEFT" , GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_RosterChangeLogScrollChildFrame , 0 , - 5 );
        GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_RosterChangeLogScrollChildFrame.AllButtons[1][1]:SetPoint( "TOPLEFT" , GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_RosterChangeLogScrollChildFrame , 0 , - 5 - math.floor ( GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_RosterChangeLogScrollChildFrame.GRM_ChangesHeader:GetHeight() ) - 7 );
        GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_RosterChangeLogScrollChildFrame.GRM_ChangesHeader:Show();
    end
    return neededToAddChanges;
end

-- Method:          GRM.SetLogValues ( int , int )
-- What it Does:    Sets the fontstring values for the lineNumber count and the actual strings for display
-- Purpose:         So we have a functioning hybrid scrollframe on the core log.
GRM.SetLogValues = function ( indString , indLog )
    if indString <= #GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_RosterChangeLogScrollChildFrame.AllButtons then

        local logFontString = GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_RosterChangeLogScrollChildFrame.AllButtons[indString][2];
        local logCount = GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_RosterChangeLogScrollChildFrame.AllButtons[indString][3];
        local logEntry = GRM_G.fullLogMatch[indLog][2];
        local r , g , b = GRM.GetMessageRGB ( GRM_G.fullLogMatch[indLog][1] );
        GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_RosterChangeLogScrollChildFrame.AllButtons[indString][4] = indLog;

        -- Reset the sizing based on settings
        if GRM.S().showLineNumbers then
            
            if GRM_G.fullLogMatch[indLog][1] == 98 then
                logCount:SetTextColor ( 1 , 1 , 1 , 0 );
                GRM_G.OldLogHeaderIsOn = true;
            elseif GRM_G.fullLogMatch[indLog][1] == 97 then
                logCount:SetTextColor ( 1 , 1 , 1 , 0 );
            elseif GRM_G.fullLogMatch[indLog][3] and not ( indLog > 1 and GRM_G.fullLogMatch[indLog][4] == GRM_G.fullLogMatch[indLog - 1][4] and GRM_G.fullLogMatch[indLog - 1][1] ~= 97 ) then                                               -- if true it should be red, indicating selection
                logCount:SetTextColor ( 1 , 0 , 0 , 1 );
            elseif indLog > 1 and GRM_G.fullLogMatch[indLog][4] == GRM_G.fullLogMatch[indLog - 1][4] and GRM_G.fullLogMatch[indLog - 1][1] ~= 97 then
                -- Hide the count
                logCount:SetTextColor ( 1 , 1 , 1 , 0 );
            else
                logCount:SetTextColor ( 1 , 1 , 1 , 1) ;
            end
            
            logCount:SetText ( GRM_G.fullLogMatch[indLog][5] .. ")" );
            logCount:Show();
            if GRM_G.OldLogHeaderIsOn and indLog > ( #GRM.GetLog() - GRM_G.IndexOfLastLogEntry ) then
                indLog = indLog - 1;
            end
        else
            logCount:Hide();
        end

        logFontString:SetTextColor ( r , g , b , 1 );
        logFontString:SetText ( logEntry );
        logFontString:Show();

        GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_RosterChangeLogScrollChildFrame.AllButtons[indString][1]:Show();

        if GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_LogTooltip:IsVisible() and GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_RosterChangeLogScrollChildFrame.AllButtons[indString][1]:IsMouseOver() then 
            GRM.RefreshLogTooltip ( GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_RosterChangeLogScrollChildFrame.AllButtons[indString][1] );
        end
    end
end

-- Method:          GRM.GetOperatorsFromText ( string )
-- What it Does:    Adds operator controls to the search strings of the log
-- Purpose:         Quality of life improvement on searching the log
GRM.GetOperatorsFromText = function ( text )
    local operators = {};
    local operatorControls = { string.char (124) };

    for i = 1 , #operatorControls do
        if string.find ( text , operatorControls[i] , 1 , true ) ~= nil then
            table.insert ( operators , i );
            -- text = string.gsub ( text , operatorControls[i] , "" );     -- Clear Operator after having been found
        end
    end

    return GRM.Trim ( text ) , operators;
end

-- Method:          GRM.GetSearchLog ( bool , string )
-- What it Does:    Pre-builds all the values to display based on the various filter parameters.
-- Purpose:         Make building a hybridscrollframe for the log that much simpler, and keeps it from reprocessing over and over.
GRM.GetSearchLog = function ( isSearch , searchString , currentPosition , finalResult , TotalC )
    local result = {};
    if finalResult then
        result = finalResult;
    end
    local needsToAddSearchString = false;
    local trueString = false;
    local index = 0;
    local logTxt = "";
    local totalCount = 0;
    if TotalC then
        totalCount = TotalC;
    end
    local gLog = GRM.GetLog();
    local c = 0;

    if not gLog then
        return;
    end

    -- Keept it simple and reusable add tool
    local addLogEntry = function( tempLog , text , uneditedText , ind , point , count )
        if string.find ( text , "\n" ) ~= nil then
            while string.find ( text , "\n" ) ~= nil do
                table.insert ( tempLog , { ind , string.sub ( text , 1 , string.find ( text , "\n" ) -1 ) , false , point , count , uneditedText } );
                text = string.sub ( text , string.find ( text , "\n" ) + 1 );
            end
        end
        table.insert ( tempLog , { ind , text , false , point , count , uneditedText } );
        return tempLog;
    end

    -- Set possible first Entry
    if not currentPosition and GRM_G.ChangesFoundOnLoad and GRM_G.FirstTimeViewed and GRM_G.IndexOfLastLogEntry < #gLog and #gLog > 0 and GRM_G.IndexOfLastLogEntry ~= #gLog then
        table.insert ( result , { 97 , " " , false , 0 , 0 , GRM.AddNewChangesHeader() } );
        table.insert ( result , { 97 , GRM.AddNewChangesHeader() , false , 0 , 0 , GRM.AddNewChangesHeader() } );
    end

    local i = #gLog;
    if currentPosition then
        i = currentPosition;
    end
    local changesEndAdded = false;

    while i > 0 and ( not isSearch or isSearch and c < 12000 ) do
        trueString = false;
        needsToAddSearchString = false;
        if GRM_G.FirstTimeViewed and GRM_G.ChangesFoundOnLoad and not changesEndAdded and GRM_G.IndexOfLastLogEntry < #gLog and #gLog > 0 and i == GRM_G.IndexOfLastLogEntry and GRM_G.IndexOfLastLogEntry ~= #gLog then
            
            -- OLD LOG HEADER
            table.insert ( result , { 98 , GRM.AddOldLogHeader() , false , 0 , 0 , GRM.AddOldLogHeader() } );
            table.insert ( result , { 98 , " " , false , 0 , 0 , GRM.AddOldLogHeader() } );
            changesEndAdded = true;
        else
            -- Check buttons
            index = gLog[i][1];
            logTxt = gLog[i][2];

            -- first, determine if this is a searchString
            if isSearch and string.find ( logTxt , "\000" ) == nil and #searchString > 0 then
                -- Is this an operator search?
                if string.find ( searchString , "^" , 1 , true ) ~= nil and string.sub ( searchString , 1 , 1 ) == "^" then

                    -- Pending feature...
                    -- YES, this is operator control!!!
                    -- local operators = {};
                    searchString = GRM.GetOperatorsFromText ( string.sub ( searchString , 2 ) );

                    if string.find ( string.lower ( string.gsub ( logTxt , "|r" , "" ) ) , searchString , 1 , true ) ~= nil then -- Comparing 2 non-case-sensitive strings
                        needsToAddSearchString = true;
                    end

                elseif string.find ( string.lower ( string.gsub ( logTxt , "|r" , "" ) ) , searchString , 1 , true ) ~= nil or string.find ( string.lower ( GRM.RemoveSpecialCharacters ( logTxt ) ) , searchString , 1 , true ) ~= nil then -- Comparing 2 non-case-sensitive strings
                    needsToAddSearchString = true;
                end
            end

            if index == 1 and GRM.S().toLog.promotion then      -- Promotion 
                trueString = true;
            elseif index == 2 and GRM.S().toLog.demotion then  -- Demotion
                trueString = true;
            elseif index == 3 and GRM.S().toLog.leveled then  -- Leveled
                local num = "";
                if string.find ( logTxt , "***" ) == nil then
                    num = GRM.Trim ( string.match ( logTxt , " %d+ " ) );
                else
                    num = string.match ( string.match ( logTxt , "cffafffdc%d+" ) , "%d+" );
                end
                if tonumber ( num ) >= GRM.S().levelReportMin then
                    trueString = true;
                end
                
            elseif index == 4 and GRM.S().toLog.note then  -- Note
                trueString = true;
            elseif index == 5 and GRM.S().toLog.officerNote then  -- OfficerNote
                trueString = true;
            elseif index == 6 and GRM.S().toLog.rankRename then  -- rankRename
                trueString = true;
            elseif ( index == 7 or index == 8 ) and GRM.S().toLog.joined then  -- Join/Rejoin
                trueString = true;
            elseif index == 10 and GRM.S().toLog.left then -- Left Guild
                trueString = true;
            elseif index == 11 and GRM.S().toLog.nameChange then -- NameChange
                trueString = true;
            elseif index == 14 and GRM.S().toLog.inactiveReturn then -- Return from inactivity
                trueString = true;
            elseif index == 15 and GRM.S().toLog.eventAnnounce then -- Event Announcement
                trueString = true;
            elseif ( index == 16 or index == 22 or index == 23 ) and GRM.S().toLog.recommend then -- recommendations
                trueString = true;
            elseif ( index == 17 or index == 18 or index == 20 or index == 21 ) and GRM.S().toLog.banned then  -- ban info
                trueString = true;
            elseif ( index == 9 or index == 12 or index == 13 ) and GRM.S().toLog.joined then  -- Banned Rejoin
                trueString = true;
            elseif index == 24 and GRM.S().toLog.death then
                trueString = true;
            elseif index == 19 and GRM.S().toLog.customNote then
                trueString = true;
            end
            if trueString then
                if ( isSearch and needsToAddSearchString) or ( not isSearch ) then
                    totalCount = totalCount + 1;
                    result = addLogEntry ( result , logTxt , logTxt , index , i , totalCount );
                end
            end
            i = i - 1;
            c = c + 1;
        end
    end

    if isSearch and i > 0 then
        GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_LogEditBox.GRM_LogSearchPendingText:Show();
        C_Timer.After ( 1 , function()
            GRM.GetSearchLog ( isSearch , searchString , i , result , totalCount );
        end);
        return;
    elseif isSearch and i == 0 and currentPosition ~= nil then
        GRM.BuildLog ( "" , true , true , result , totalCount );
        GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_LogEditBox.GRM_LogSearchPendingText:Hide();
        return;
    end

    return result , totalCount;
end

-- Method:          GRM.SetColoredLines()
-- What it Does:    Sets all of the instances in the temp filtered log as true or false, indicating which lines should be red or not.
-- Purpose:         Line coloring!!!
GRM.SetColoredLines = function()
    local number = tonumber ( GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_LogExtraOptionsFrame.GRM_LogExtraEditBox1:GetText() );
    local number2 = tonumber ( GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_LogExtraOptionsFrame.GRM_LogExtraEditBox2:GetText() );
    local clearAll = false;

    if ( number2 < number) then
        clearAll = true;
    end

    if not ( number == 0 and number == number2 ) and number <= number2 or clearAll then
        for i = 1 , #GRM_G.fullLogMatch do
            if not clearAll and GRM_G.fullLogMatch[i][5] >= number and GRM_G.fullLogMatch[i][5] <= number2 then
                GRM_G.fullLogMatch[i][3] = true;
            else
                GRM_G.fullLogMatch[i][3] = false
            end
        end
    end   
end

-- Method:          GRM.BuildLogComplete()
-- What it Does:    Checks the editbox and sees whether to build the log normal, or to auto-rebuild the log based on the custom text filter.
-- Purpose:         The Call to rebuild the log is done about 50 times. This cleans up the code bloat.
GRM.BuildLogComplete = function( UIControl , fullRefresh )
    if GRM_UI.GRM_RosterChangeLogFrame:IsVisible() then

        if GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_LogEditBox:GetText() ~= "" and GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_LogEditBox:GetText() ~= GRM.L ( "Search Filter" ) then
            GRM.BuildLog ( GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_LogEditBox:GetText() , fullRefresh );
        else
            GRM.BuildLog( nil , fullRefresh );
        end
        
        -- Set Focus on the bar automatically...
        if GRM.S().autoFocusSearch and not GRM_G.OnFirstLoad and not UIControl and not GRM_G.SearchFocusControl then
            GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_LogEditBox:SetFocus();
            GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_LogEditBox:SetText ( "" );
        end
    end
end

-- Method:          GRM.BuildHybridLog( string , bool , bool , bool , table , int )
-- What it Does:    Builds the guildLog frame details for the scrollframe
-- Purpose:         You aren't tracking all of that info for nothing!
GRM.BuildLog = function ( searchString , fullRefresh , delayedSearch , fullLogMatch , TotalCount )
    local isSearch = false;
    local hybridScrollFrameButtonCount = 29;        -- Exactly 25 buttons
    local buttonHeight = 17.138
    local buttonWidth = GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_RosterChangeLogScrollFrame:GetWidth() - 5;

    if not delayedSearch then
        if searchString ~= nil and type ( searchString ) == "string" then
            searchString = string.lower ( searchString ); -- Remove case sensitivity
            isSearch = true;
        end

        -- Only rebuild the log if necessary based on new parameters.
        if fullRefresh then        
            GRM_G.fullLogMatch , GRM_G.CurrentTotalCount = GRM.GetSearchLog ( isSearch , searchString );
        end
    else
        GRM_G.fullLogMatch = fullLogMatch;
        GRM_G.CurrentTotalCount = TotalCount;
    end

    if GRM_G.fullLogMatch == nil then
        return;
    end

    local log = GRM_G.fullLogMatch;
    
    GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_RosterChangeLogScrollChildFrame.Offset = GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_RosterChangeLogScrollChildFrame.Offset or hybridScrollFrameButtonCount;

    if GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_RosterChangeLogScrollChildFrame.Offset < hybridScrollFrameButtonCount then
        GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_RosterChangeLogScrollChildFrame.Offset = hybridScrollFrameButtonCount;
    elseif GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_RosterChangeLogScrollChildFrame.Offset > hybridScrollFrameButtonCount and GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_RosterChangeLogScrollChildFrame.Offset > #log then
        GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_RosterChangeLogScrollChildFrame.Offset = #log;
    end

    GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_RosterChangeLogScrollChildFrame.AllButtons = GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_RosterChangeLogScrollChildFrame.AllButtons or {};
    
    for i = 1 , #log do
        -- Build HybridScrollFrame Buttons
        if i <= hybridScrollFrameButtonCount then
            if not GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_RosterChangeLogScrollChildFrame.AllButtons[i] then
                local button = CreateFrame ( "Button" , "LogButton" .. i , GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_RosterChangeLogScrollChildFrame );
                GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_RosterChangeLogScrollChildFrame.AllButtons[i] = {
                    button ,
                    button:CreateFontString ( nil ) ,
                    button:CreateFontString ( nil , "OVERLAY" , "GameFontWhiteTiny" ),
                    0   -- index of the log
                };

                if i == 1 then
                    button:SetPoint ( "TOP" , GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_RosterChangeLogScrollChildFrame , "TOP" , -1 , 0 );
                else 
                    button:SetPoint ( "TOPLEFT" , GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_RosterChangeLogScrollChildFrame.AllButtons[i-1][1] , "BOTTOMLEFT" , 0 , 0 );
                end

                GRM.BuildCoreLogFontstrings ( i , buttonHeight , buttonWidth );
            end
        end
        if ( i >= ( GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_RosterChangeLogScrollChildFrame.Offset - hybridScrollFrameButtonCount + 1 ) and i <= GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_RosterChangeLogScrollChildFrame.Offset ) then
            GRM.SetLogValues ( i - ( GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_RosterChangeLogScrollChildFrame.Offset - hybridScrollFrameButtonCount ) , i );
        end
    end

    -- Remove the buffer on one of them due to the top not needing it.
    -- Hide unused buttons...
    for i = 1 , #GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_RosterChangeLogScrollChildFrame.AllButtons do
        if i > #log then
            GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_RosterChangeLogScrollChildFrame.AllButtons[i][1]:Hide();
        else
            GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_RosterChangeLogScrollChildFrame.AllButtons[i][1]:Show();
        end
    end

    local DatabaseAvailable = function()
        local result = true;

        if GRM_G.fullLogMatch == nil then
            result = false;
        end

        return result;
    end

    GRM.SetHybridScrollFrameSliderParameters ( 
        GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_RosterChangeLogScrollChildFrame , GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_RosterChangeLogScrollFrame , GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_RosterChangeLogScrollFrameSlider , 
        buttonWidth , buttonHeight , buttonHeight * #log , #log , GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_RosterChangeLogScrollChildFrame.AllButtons , 
        GRM.LogToolHybridShiftDown , GRM.LogToolHybridShiftUP , hybridScrollFrameButtonCount , DatabaseAvailable
    );

    GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_RosterChangeLogFrameNumEntriesText:SetText ( GRM.L ( "Total Entries: {num}" , nil , nil , GRM_G.CurrentTotalCount ) );
end

-- Method:          GRM.BuildCoreLogFontstrings ( int , float , int )
-- What it Does:    Initiates the fontstring values for the Core Log
-- Purpose:         Compartmentalize the code for easier call back to.
GRM.BuildCoreLogFontstrings = function ( ind , size , buttonWidth , isResizeAction )
    local button = GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_RosterChangeLogScrollChildFrame.AllButtons[ind][1];
    local logFontString = GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_RosterChangeLogScrollChildFrame.AllButtons[ind][2];
    local logCount = GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_RosterChangeLogScrollChildFrame.AllButtons[ind][3];
    local modifier = 7;
    local stringWidth = buttonWidth - 5
    if GRM.S().showLineNumbers then
        modifier = 8.5;
        stringWidth = buttonWidth - 45
        logFontString:SetPoint ( "LEFT" , button , "LEFT" , 36 , 0 )
    else
        logFontString:SetPoint ( "LEFT" , button , "LEFT" , 0 , 0 )
    end

    logCount:SetPoint ( "LEFT" , button , "LEFT" , 0 , 0 );
    logCount:SetJustifyH ( "LEFT" );
    logCount:SetWidth ( 35 );
    logCount:SetTextColor ( 1 , 1 , 1 );
    logCount:SetWordWrap ( false );
    logCount:SetFont ( GRM_G.FontChoice , GRM.S().logFontSize + size - modifier );

    logFontString:SetJustifyH ( "LEFT" );
    logFontString:SetWidth ( stringWidth );
    logFontString:SetWordWrap ( false );

    logFontString:SetFont ( GRM_G.FontChoice , GRM.S().logFontSize + size - modifier );

    GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_LogTooltip.GRM_LogTooltipText1:SetFont ( GRM_G.FontChoice , GRM.S().logFontSize + size - modifier );

    if not isResizeAction then
        button:SetSize ( buttonWidth , size );
        button:RegisterForDrag ( "LeftButton" );
        
        -- Tooltips
        button:SetScript ( "OnEnter" , function ( self )
            GRM.RefreshLogTooltip ( self );
        end);
        button:SetScript ( "OnLeave" , function ()
            GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_LogTooltip:Hide();
        end);
        button:SetScript ( "OnDragStart" , function()
            GRM_UI.GRM_RosterChangeLogFrame:StartMoving();
        end);
        button:SetScript ( "OnDragStop" , function()
            GRM_UI.GRM_RosterChangeLogFrame:StopMovingOrSizing();
            GRM_UI.SaveCorePosition();
        end);

        -- Log One Click Behavior
        button:SetScript ( "OnClick" , function ( self , buttonClicked ) 
            if buttonClicked == "LeftButton" then
                if IsControlKeyDown() and IsShiftKeyDown() and GRM.S().shiftClickRemove and not GRM_UI.GRM_RosterConfirmFrame:IsVisible() then
                    for i = 1 , #GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_RosterChangeLogScrollChildFrame.AllButtons do
                        if GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_RosterChangeLogScrollChildFrame.AllButtons[i][1] == self then
                            if GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_RosterChangeLogScrollChildFrame.AllButtons[i][1]:IsMouseOver() then
                                GRM.RemoveItemFromLog ( GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_RosterChangeLogScrollChildFrame.AllButtons[i][4] , true , true );
                            end
                            break;
                        end
                    end
                end
            end
        end);
    end

end

-- Method:          GRM.RefreshLogTooltip()
-- What it Does:    Refreshes the tooltip of the button moused over in the log that has text that is too long
-- Purpose:         Enhanced log features
GRM.RefreshLogTooltip = function( button )
    if GRM.S().showTooltip then
        for i = 1 , #GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_RosterChangeLogScrollChildFrame.AllButtons do
            if GRM_G.fullLogMatch == nil then
                break;
            else
                if GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_RosterChangeLogScrollChildFrame.AllButtons[i][1] == button then
                    local text = GRM_G.fullLogMatch[GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_RosterChangeLogScrollChildFrame.AllButtons[i][4]][6];

                    GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_LogTooltip.GRM_LogTooltipText1:SetText ( text );
                    local width = GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_LogTooltip.GRM_LogTooltipText1:GetWidth();

                    local r , g , b = GRM.GetMessageRGB ( GRM_G.fullLogMatch[GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_RosterChangeLogScrollChildFrame.AllButtons[i][4]][1] );
                    GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_LogTooltip:SetOwner ( button , "ANCHOR_CURSOR" );
                    GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_LogTooltip:AddLine ( "|CFFE6CC7F" .. GRM.L ( "Full Log Message:" ) );
                    GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_LogTooltip:AddLine ( " " );

                    if width > ( GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_RosterChangeLogScrollChildFrame.AllButtons[i][2]:GetWidth() + 200 ) then
                        local index = string.find ( text , "%s" , math.floor ( #text / 2 ) );
                        GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_LogTooltip:AddLine ( string.sub ( text , 1 , index ) , r , g , b );
                        GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_LogTooltip:AddLine ( string.sub ( text , index + 1 ) , r , g , b );
                    else
                        GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_LogTooltip:AddLine ( text , r , g , b );
                    end

                    GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_LogTooltip:Show();
                    break;
                end
            end
        end
    end
end

-- Method:          GRM.ResetLogStringPoints ( bool )
-- What it Does:    Sets point of all the built fontstrings to account for spacing needed for the count or not and resets the size width
-- Purpose:         Aesthetics on the log
GRM.ResetLogStringPoints = function ( countEnabled )
    local position = 0;
    local modifier = 7;
    if GRM.S().showLineNumbers then
        modifier = 8.5;
    end
    local width = GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_RosterChangeLogScrollFrame:GetWidth() - 10;
    if countEnabled then
        position = 36;
        width = GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_RosterChangeLogScrollFrame:GetWidth() - 50;
    end

    for i = 1 , #GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_RosterChangeLogScrollChildFrame.AllButtons do
        GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_RosterChangeLogScrollChildFrame.AllButtons[i][2]:SetPoint ( "LEFT" , GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_RosterChangeLogScrollChildFrame.AllButtons[i][1] , "LEFT" , position , 0 );
        GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_RosterChangeLogScrollChildFrame.AllButtons[i][2]:SetWidth ( width );
        GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_RosterChangeLogScrollChildFrame.AllButtons[i][2]:SetFont ( GRM_G.FontChoice , GRM.S().logFontSize + 17.08 - modifier );
        GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_RosterChangeLogScrollChildFrame.AllButtons[i][3]:SetFont ( GRM_G.FontChoice , GRM.S().logFontSize + 17.08 - modifier );
        GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_LogTooltip.GRM_LogTooltipText1:SetFont ( GRM_G.FontChoice , GRM.S().logFontSize + 17.08 - modifier );
    end
end

-- Method:          GRM.AddOldLogHeader()
-- What it Does:    Returns the string of the Old Log header
-- Purpose:         Cleaner Log reporting.
GRM.AddOldLogHeader = function ()
    return ( "|cffffd600----------   " .. GRM.L ( "OLD LOG" ) .. "  ----------|r" );
end

-- Method:          GRM.AddNewChangesHeader()
-- What it Does:    Returns the string of the "Changes" header since last logged in the log
-- Purpose:         Cleaner log reporting
GRM.AddNewChangesHeader = function ()
    return ( "|cffffd600----------  " .. GRM.L ( "CHANGES" ) .. "  ----------|r" )
end

-- Method:          GRM.ExportMemberDetailsHeaders()
-- What it Does:    Creates a Headers Export
-- Purpose:         So player can easily build export headers for the data.
GRM.ExportMemberDetailsHeaders = function ( returnString )
    local scrollWidth = GRM_UI.GRM_ExportLogBorderFrame.GRM_ExportLogScrollFrame:GetWidth() - 3;
    local headerOrder = { "name","rank","level","class","race","sex","lastOnline","mainAlt","alts","joinDate","promoteDate","rankHist","bday","rep","note","oNote","cNote","mythicScore","faction","GUID"};

    local headers = { 
        GRM.L ( "Name" ) , 
        GRM.L ( "Rank" ) , 
        GRM.L ( "Level" ) , 
        GRM.L ( "Class" ) , 
        GRM.L ( "Race" ) , 
        GRM.L ( "Sex" ) , 
        GRM.L ( "Last Online (Days)" ) , 
        GRM.L ( "Main/Alt" ) , 
        GRM.L ( "Player Alts" ) , 
        GRM.L ( "Join Date" ) ,
        GRM.L ( "Promo Date" ) ,
        GRM.L ( "Rank History" ) ,
        GRM.L ( "Birthday" ) ,
        GRM.L ( "Guild Rep" ) ,
        GRM.L ( "Public Note" ) ,
        GRM.L ( "Officer Note" ) ,
        GRM.L ( "Custom Note" ) , 
        GRM.L ( "Mythic+ Score" ) ,
        GRM.L ( "Faction" ) ,
        GRM.L ( "Player GUID" )
    };

    local delimiter = "";
    if GRM.S().exportDelimiter[1] then
        delimiter = GRM.S().exportDelimiter[2];
    end

    local completeString = "";
    -- Build the string
    for i = 1 , #headerOrder do

        if GRM.S().exportFilters[headerOrder[i]] then
            if ( ( headerOrder[i] ~= "rep" and headerOrder[i] ~= "mythicScore" ) or ( ( headerOrder[i] == "rep" and GRM_G.BuildVersion >= 40000 ) or ( headerOrder[i] == "mythicScore" and GRM_G.BuildVersion >= 80000 ) ) ) then
                completeString = completeString .. headers[i] .. delimiter;
            end
        end
    end

    if #completeString > 0 then
        local modifier = 1;

        if delimiter == "||" or delimiter == "\\t" or delimiter == "::" then
            modifier = 2;
        end
        completeString = string.sub ( completeString , 1 , #completeString - modifier );  -- eliminate the last delimiter
    end

    if not returnString and completeString ~= "" then
        GRM_UI.GRM_ExportLogBorderFrame.GRM_ExportLogFrameEditBox:SetText ( completeString );
        GRM_UI.GRM_ExportLogBorderFrame.GRM_ExportLogFrameEditBox:HighlightText ( 0 );
        GRM_UI.GRM_ExportLogBorderFrame.GRM_ExportLogFrameEditBox:Show();
        GRM_UI.GRM_ExportLogBorderFrame.GRM_ExportLoadingText:Hide();
        C_Timer.After ( 2 , function()
            GRM.ExportScrollSliderConfigure( scrollWidth );
        end);

    elseif returnString then
        return completeString;
    end
end

-- Method:          GRM.convertToArrayFormat( string )
-- What it Does:    Converts the format into a usable one for sync and also exporting in a sorted, proper order.
-- Purpose:         Clean UI management for the user.
GRM.convertToArrayFormat = function( guildName )
    local finalGData = {};
    local formerGuildData = {};
    local altData = {};
    local G = guildName or GRM_G.guildName;
    local i = 1;

    -- Trigger cleanup of this issue
    GRM.AltModifiedIntegrityCheck();

    for _ , player in pairs ( GRM.GetGuild ( G ) ) do
        if type ( player ) == "table" then
            finalGData[i] = player;
            i = i + 1;
        end
    end
    sort ( finalGData , function ( a , b ) return a.name < b.name end );

    i = 1;
    for _ , player in pairs ( GRM.GetFormerMembers ( G ) ) do
        if type ( player ) == "table" then
            formerGuildData[i] = player;
            i = i + 1;
        end
    end
    sort ( formerGuildData , function ( a , b ) return a.name < b.name end );

    altData = GRM.DeepCopyArray ( GRM_Alts[G] );

    return finalGData , formerGuildData , altData;
end

-- Method:          GRM.BuildExportMemberDetails( int , string , string )
-- What it Does:    Exports the player details as a text stirng with a delimitter
-- Purpose:         Allow the player to easily export the information.
GRM.BuildExportMemberDetails = function( currentMembers , specificGuild )
    local scrollWidth = GRM_UI.GRM_ExportLogBorderFrame.GRM_ExportLogScrollFrame:GetWidth() - 3;
    local completeString = "";
    local delimiter = "";
    if GRM.S().exportDelimiter[1] then
        delimiter = GRM.S().exportDelimiter[2];
    end
    local altList = {};
    local alts = {};
    local altString = "";
    local isMergedRealm = GRM.IsMergedRealmServer();
    local playerDetails = "";

    local sex = "";
    local separator = ",";
    if delimiter == separator then
        separator = ";";
    end
    local rankHistory = "";
    local name = "";
    local currentRoster , formerRoster;

    -- Build the arrays to use.
    if specificGuild ~= nil then
        currentRoster , formerRoster = GRM.convertToArrayFormat( specificGuild );
    else
        currentRoster , formerRoster = GRM.convertToArrayFormat();
    end

    local roster = currentRoster;
     
    if not currentMembers then
        roster = formerRoster;
    end

    local num1 = tonumber ( GRM_UI.GRM_ExportLogBorderFrame.GRM_ExportRangeEditBox1:GetText() );
    local num2 = tonumber ( GRM_UI.GRM_ExportLogBorderFrame.GRM_ExportRangeEditBox2:GetText() );
    GRM_UI.GRM_ExportLogBorderFrame.GRM_ExportLogFrameEditBox:SetText ( "" );
    GRM_UI.GRM_ExportLogBorderFrame.GRM_ExportLogFrameEditBox:SetSize ( scrollWidth , 12 );   -- Default Size at one line

    local mainOnly , altOnly = false , false;

    if GRM.S().exportFilters.MainOrAlt then
        mainOnly = GRM.S().exportFilters.mainOnly;

        if not GRM.S().exportFilters.mainOnly then
            altOnly = true;
        end
    end

    -- Validates if it should be added to the string based on the conditions
    local isValid = function ( player )
        local result = true;

        if mainOnly and not player.isMain then
            result = false;
        elseif altOnly and ( player.isMain or ( not player.isMain and not GRM.PlayerIsAnAlt ( player ) ) ) then
            result = false;
        end

        if player.level < GRM.S().ExportLevelRange[1] or player.level > GRM.S().ExportLevelRange[2] then
            result = false;
        end

        return result;
    end

    if GRM.S().columnHeaders and num1 == 1 then
        completeString = GRM.ExportMemberDetailsHeaders ( true ) .. "\n";
    end

    for i = num1 , num2 do
        playerDetails = "";
        sex = "";
        if num1 <= #roster then
            
            if isValid ( roster[i] ) then

                if GRM.S().exportFilters.name then
                    
                    name = roster[i].name;

                    if GRM.S().specialCharRemoval then
                        name = GRM.RemoveSpecialCharacters ( name );
                    end

                    if isMergedRealm then
                        playerDetails = playerDetails .. name .. delimiter;                                   -- name
                    else
                        playerDetails = playerDetails .. GRM.SlimName ( name ) .. delimiter;                  -- name
                    end
                end
                if GRM.S().exportFilters.rank then
                    playerDetails = playerDetails .. roster[i].rankName .. delimiter;                                   -- rank
                end
                if GRM.S().exportFilters.level then
                    playerDetails = playerDetails .. roster[i].level .. delimiter;                                      -- level
                end
                if GRM.S().exportFilters.class then
                    playerDetails = playerDetails .. GRM.GetClassName ( roster[i].class ) .. delimiter;   -- class
                end
                if GRM.S().exportFilters.race then
                    if roster[i].race and roster[i].race ~= "" and raceIDEnum[roster[i].race] ~= nil then 
                        playerDetails = playerDetails .. C_CreatureInfo.GetRaceInfo ( raceIDEnum[roster[i].race] ).raceName .. delimiter;   -- Race
                    else
                        playerDetails = playerDetails .. GRM.L ( "Unknown" ) .. delimiter;
                    end
                end
                if GRM.S().exportFilters.sex then
                    if roster[i].sex ~= 1 then
                        sex = GRM.GetSex ( roster[i].sex );
                        playerDetails = playerDetails .. sex .. delimiter;   -- Sex
                    else
                        playerDetails = playerDetails .. GRM.L ( "Unknown" ) .. delimiter;
                    end
                end
                if GRM.S().exportFilters.lastOnline then
                    if roster[i].lastOnline < 24 then
                        playerDetails = playerDetails .. GRM.Round ( roster[i].lastOnline / 24 , 2 ) .. delimiter;         -- Last Online  (in days, round to 2)
                    else
                        playerDetails = playerDetails .. math.floor ( ( roster[i].lastOnline / 24 ) + 0.5 ) .. delimiter;  -- keep it rounded to the nearest integer
                    end
                end
                if GRM.S().exportFilters.mainAlt then                                   -- Main or Alt
                    if roster[i].isMain then
                        playerDetails = playerDetails .. GRM.L ( "Main" ) .. delimiter;
                    else

                        if GRM.PlayerIsAnAlt ( roster[i] ) then
                            playerDetails = playerDetails .. GRM.L ( "Alt" ) .. delimiter;
                        else
                            playerDetails = playerDetails .. delimiter;
                        end
                    end
                end
                if GRM.S().exportFilters.alts then                                  -- Player Alts

                    if ( currentMembers and GRM.PlayerHasAlts ( roster[i] ) ) or ( not currentMembers and GRM.LeftPlayerHasAlts ( roster[i] ) ) then

                        if currentMembers then
                            alts = GRM.GetListOfAlts ( roster[i] );
                        else
                            alts = roster[i].altsAtTimeOfLeaving;
                        end

                        altList = {};
                        altString = "";

                        for j = 1 , #alts do
                            table.insert ( altList , alts[j][1] );

                            if not roster[i].isMain and ( currentMembers and alts[j][1] == GRM.GetAltGroupMain ( roster[i].altGroup ) ) or ( not currentMembers and #roster[i].mainAtTimeOfLeaving > 0 and alts[j][1] == roster[i].mainAtTimeOfLeaving[1] ) then
                                altList[#altList] = altList[#altList] .. GRM.L ( "(main)" );
                            end
                        end
                        sort ( altList );
                        
                        for j = 1 , #altList do
                            if j < #altList then
                                altString = altString .. altList[j] .. separator;
                            else
                                altString = altString .. altList[j];            -- No need to add a comma at the end of the list
                            end
                        end

                        playerDetails = playerDetails .. altString .. delimiter;
                    else
                        playerDetails = playerDetails .. delimiter;
                    end
                end
                if GRM.S().exportFilters.joinDate then                                   -- Join Date
                    if roster[i].joinDateUnknown then
                        playerDetails = playerDetails .. GRM.L ( "Unknown" ) .. delimiter;
                    else
                        local pos = 1;
                        if roster[i].joinDateHist[1][7] == 2 then  -- Date left
                            pos = 2;
                        end

                        if #roster[i].joinDateHist[pos][4] == 1 then
                            playerDetails = playerDetails .. delimiter;
                        else
                            playerDetails = playerDetails .. ( GRM.DateUntrustedTag ( roster[i].joinDateHist[pos][6] ) .. GRM.FormatTimeStamp ( { roster[i].joinDateHist[pos][1] , roster[i].joinDateHist[pos][2] , roster[i].joinDateHist[pos][3] } , false ) ) .. delimiter;
                        end
                    end
                end
                if GRM.S().exportFilters.promoteDate then                                   -- Promo Date
                    if roster[i].promoteDateUnknown then
                        playerDetails = playerDetails .. GRM.L ( "Unknown" ) .. delimiter;
                    else

                        local pos = 1;
                        if roster[i].rankHist[1][8] == 2 then  -- Date left
                            pos = 2;
                        end

                        if #roster[i].rankHist[pos][5] == 1 then      --- Promotion has never been recorded!
                            playerDetails = playerDetails .. delimiter;
                        else
                            playerDetails = playerDetails .. ( GRM.DateUntrustedTag ( roster[i].rankHist[pos][7] ) .. GRM.FormatTimeStamp ( { roster[i].rankHist[pos][2] , roster[i].rankHist[pos][3] , roster[i].rankHist[pos][4] } , false ) ) .. delimiter;
                        end
                    end
                end
                if GRM.S().exportFilters.rankHist then                                   -- Rank History
                    rankHistory = GRM.GetRankHistory ( roster[i] , delimiter );
                    if #rankHistory == 0 then
                        playerDetails = playerDetails .. delimiter
                    else
                        playerDetails = playerDetails .. rankHistory .. delimiter;
                    end
                end
                if GRM.S().exportFilters.bday then                                   -- Birthday
                    if roster[i].birthdayUnknown then
                        playerDetails = playerDetails .. GRM.L ( "Unknown" ) .. delimiter;
                    else
                        -- Checking button vs text
                        if roster[i].events[2][1][1] ~= 0 then
                            playerDetails = playerDetails .. GRM.FormatTimeStamp ( roster[i].events[2][3] , false , true ) .. delimiter;
                        else
                            playerDetails = playerDetails .. delimiter;
                        end
                    end
                end                                                             -- Rep
                if GRM.S().exportFilters.rep and GRM_G.BuildVersion >= 40000 then
                    playerDetails = playerDetails .. GRM.GetReputationTextLevel ( roster[i].guildRep , false ) .. delimiter;
                end
                if GRM.S().exportFilters.note then                                  -- Public Note
                    if roster[i].note ~= nil and roster[i].note ~= "" then
                        playerDetails = playerDetails .. string.gsub ( roster[i].note , delimiter , "" ) .. delimiter;
                    else
                        playerDetails = playerDetails .. delimiter;
                    end
                end
                if GRM.S().exportFilters.oNote then                                  -- Officer Note
                    if GRM.CanViewOfficerNote() and roster[i].officerNote ~= nil and roster[i].officerNote ~= "" then
                        playerDetails = playerDetails .. string.gsub ( roster[i].officerNote , delimiter , "" ) .. delimiter;
                    else
                        playerDetails = playerDetails .. delimiter;
                    end
                end
                if GRM.S().exportFilters.cNote then                                  -- Custom Note
                    if roster[i].customNote[6] ~= "" then
                        playerDetails = playerDetails .. string.gsub ( string.gsub ( roster[i].customNote[6] , "\n" , separator ) , delimiter , "" ) .. delimiter;
                    else 
                        playerDetails = playerDetails .. delimiter;
                    end
                end
                if GRM.S().exportFilters.mythicScore and GRM_G.BuildVersion >= 80000 then             -- Mythic+ Score
                    if roster[i].MythicScore then
                        playerDetails = playerDetails .. roster[i].MythicScore .. delimiter;
                    else
                        playerDetails = playerDetails .. "0" .. delimiter;
                    end
                end
                if GRM.S().exportFilters.faction then             -- faction, Alliance or Horde

                    -- Due to old conversion placeholder of -1 was added in a patch.
                    if roster[i].faction == -1 and GRM_G.BuildVersion < 100000 then
                        roster[i].faction = GRM_G.faction;
                    end

                    if roster[i].faction == 0 then
                        playerDetails = playerDetails .. GRM.L ( "Horde" ) .. delimiter;
                    elseif roster[i].faction == 1 then
                        playerDetails = playerDetails .. GRM.L ( "Alliance" ) .. delimiter;
                    else
                        playerDetails = playerDetails .. GRM.L ( "Unknown" ) .. delimiter;
                    end

                end
                if GRM.S().exportFilters.GUID then                                  -- GUID
                    playerDetails = playerDetails .. roster[i].GUID .. delimiter;    
                end

                if #playerDetails > 0 then
                    local modifier = 1;

                    if delimiter == "||" or delimiter == "\\t" or delimiter == "::" then
                        modifier = 2;
                    end
                    playerDetails = string.sub ( playerDetails , 1 , #playerDetails - modifier );  -- eliminate the last delimiter
                    if i < num2 then
                        completeString = completeString .. playerDetails .. "\n";
                    else
                        completeString = completeString .. playerDetails;               -- Don't need to add the line break at the end.
                    end 
                end
            end
        else
            break;
        end
    end

    if completeString ~= "" then
        GRM_UI.GRM_ExportLogBorderFrame.GRM_ExportLogFrameEditBox:HighlightText ( 0 );
        GRM_UI.GRM_ExportLogBorderFrame.GRM_ExportLogFrameEditBox:Show();
        GRM_UI.GRM_ExportLogBorderFrame.GRM_ExportLogFrameEditBox:SetText ( completeString );
        GRM_UI.GRM_ExportLogBorderFrame.GRM_ExportLoadingText:Hide();
        
        C_Timer.After ( 2 , function()
            GRM.ExportScrollSliderConfigure( scrollWidth );
        end);
    end
end

-- Method:          GRM.DelimiterFix ( string , bool )
-- What it Does:    Replaces any commas with a semicolon
-- Purpose:         To allow comma delimiter in the export details
GRM.DelimiterFix = function ( entry , isComma )
    local result = "";

    if isComma then
        result = string.gsub ( entry , "," , ";" );     -- Use semicolon in place of all commas if player is using comma as delimiter
    else
        result = entry;
    end    

    return result;
end

-- Method:          GRM.BuildExportAnyText ( string )
-- What it Does:    Opens the export window and pastes whatever text this function is fed into there
-- Purpose:         Allow easy copying of various data.
GRM.BuildExportAnyText = function ( stringToExport )
    local scrollWidth = GRM_UI.GRM_ExportLogBorderFrame.GRM_ExportLogScrollFrame:GetWidth() - 3;

    -- Reset the text
    GRM_UI.GRM_ExportLogBorderFrame.GRM_ExportLogFrameEditBox:SetText ( "" );
    GRM_UI.GRM_ExportLogBorderFrame.GRM_ExportLogFrameEditBox:SetSize ( scrollWidth , 12 );   -- Default Size at one line

    if stringToExport ~= "" then
        GRM_UI.GRM_ExportLogBorderFrame.GRM_ExportLogFrameEditBox:SetText ( stringToExport );
        GRM_UI.GRM_ExportLogBorderFrame.GRM_ExportLogFrameEditBox:HighlightText ( 0 );
        GRM_UI.GRM_ExportLogBorderFrame.GRM_ExportLogFrameEditBox:Show();
        GRM_UI.GRM_ExportLogBorderFrame.GRM_ExportLoadingText:Hide();
        C_Timer.After ( 2 , function()
            GRM.ExportScrollSliderConfigure( scrollWidth );
        end);
    end

end

-- Method:          GRM.BuildExportLogFrame()
-- What it Does:    Exactly as named... adds the entire guild log from the given guild, parses out the coloring, and makes it easy to copy and paste it
-- Purpose:         To allow players the ability to export their logs to a file somewhere to keep their system from getting too clutters.
GRM.BuildExportLogFrame = function()
    local scrollWidth = GRM_UI.GRM_ExportLogBorderFrame.GRM_ExportLogScrollFrame:GetWidth() - 3;
    local completeString = "";
    local limit = 0;
    local delimiter = "";
    if GRM.S().exportDelimiter[1] then
        delimiter = GRM.S().exportDelimiter[2];
    end

    -- To be able to use comma as delimiter we will need to substitue something else in place of comma.
    local isComma = false;
    if delimiter == "," then
        isComma = true;
    end

    local num1 = tonumber ( GRM_UI.GRM_ExportLogBorderFrame.GRM_ExportRangeEditBox1:GetText() );
    local num2 = tonumber ( GRM_UI.GRM_ExportLogBorderFrame.GRM_ExportRangeEditBox2:GetText() );
    GRM_UI.GRM_ExportLogBorderFrame.GRM_ExportLogFrameEditBox:SetText ( "" );
    GRM_UI.GRM_ExportLogBorderFrame.GRM_ExportLogFrameEditBox:SetSize ( scrollWidth , 12 );   -- Default Size at one line

    local log = GRM_G.fullLogMatch;
    
    if #log > 0 then
        
        limit = num2;

        GRM_UI.GRM_ExportLogBorderFrame.GRM_ExportLoadingText:SetText ( GRM.L ( "Building Log for Export..." ) );
        
        
        local i = num1;
        local newCount = true;
        local j;

        -- Need to find a starting point.
        if i <= limit then
            for k = i , #log do
                if log[k][5] == num1 then
                    j = k;
                    break;
                end
            end
        end

        local additionalNotes = false;
        local entry = "";
        
        while i <= limit do
            newCount = true;
            additionalNotes = false;
            while j <= #log and ( log[j][5] == i or log[j][5] == 0 ) do

                if newCount and j <= #log and log[j][5] ~= 0 then
                    newCount = false;
                    entry = GRM.DelimiterFix ( log[j][2] , isComma );

                    if i == 1 then  --
                        if GRM.S().showLineNumbers then
                            
                            if additionalNotes or ( not additionalNotes and string.find ( entry , GRM.L ( "Additional Notes:" ) , 1 , true ) ~= nil ) then      -- Don't want to delimit breakup the custom note
                                additionalNotes = true;
                                completeString = completeString .. i .. ") " .. GRM.RemoveStringColoring ( entry );
                            else
                                completeString = completeString .. i .. ") " .. GRM.RemoveStringColoring ( entry ) .. delimiter;
                            end
                        else
                            completeString = completeString .. GRM.RemoveStringColoring ( entry ) .. delimiter;
                        end
                    else
                        if GRM.S().showLineNumbers then
                            
                            if additionalNotes or ( not additionalNotes and string.find ( entry , GRM.L ( "Additional Notes:" ) , 1 , true ) ~= nil ) then      -- Don't want to delimit breakup the custom note
                                additionalNotes = true;
                                completeString = completeString .. "\n" .. i .. ") " .. GRM.RemoveStringColoring ( entry );
                            else
                                completeString = completeString .. "\n" .. i .. ") " .. GRM.RemoveStringColoring ( entry ) .. delimiter;
                            end
                        else
                            completeString = completeString .. "\n" .. GRM.RemoveStringColoring ( entry ) .. delimiter;
                        end
                    end
                else
                    if log[j][5] ~= 0 then
                        entry = GRM.DelimiterFix ( log[j][2] , isComma );

                        if additionalNotes or ( not additionalNotes and string.find ( entry , GRM.L ( "Additional Notes:" ) , 1 , true ) ~= nil ) then
                            additionalNotes = true;
                            if string.find ( entry , GRM.L ( "Additional Notes:" ) , 1 , true ) ~= nil then
                                completeString = completeString .. GRM.RemoveStringColoring ( entry ) .. delimiter;
                            else
                                completeString = completeString .. GRM.RemoveStringColoring ( entry );
                            end
                        else
                            completeString = completeString .. GRM.RemoveStringColoring ( entry ) .. delimiter;
                        end
                    end
                end
                -- if j == #log or ( log[j+1] ~= nil and log[j+1][5] ~= i ) then
                --     completeString = string.sub ( completeString , 1 , #completeString - 1 );    -- Remove delimiter???
                -- end
                j = j + 1;
                
            end

            i = i + 1;
        end
    end

    if limit == 0 then
        GRM_UI.GRM_ExportLogBorderFrame.GRM_ExportLoadingText:SetText ( GRM.L ( "The Log is Currently Empty for This Guild" ) );
    end
    GRM_UI.GRM_ExportLogBorderFrame.GRM_ExportLogFrameEditBox:Hide();
    GRM_UI.GRM_ExportLogBorderFrame.GRM_ExportLoadingText:Show();
    if completeString ~= "" then
        GRM_UI.GRM_ExportLogBorderFrame.GRM_ExportLogFrameEditBox:SetText ( completeString );
        GRM_UI.GRM_ExportLogBorderFrame.GRM_ExportLogFrameEditBox:HighlightText ( 0 );
        GRM_UI.GRM_ExportLogBorderFrame.GRM_ExportLogFrameEditBox:Show();
        GRM_UI.GRM_ExportLogBorderFrame.GRM_ExportLoadingText:Hide();
        C_Timer.After ( 2 , function()
            GRM.ExportScrollSliderConfigure( scrollWidth );
        end);
    end
end

-- Method:          GRM.BuildExportDelimiterDropdownMenu()
-- What it Does:    Builds the dropdown menu values for the delimiters on the export window
-- Purpose:         Allow Delimiter Selection
GRM.BuildExportDelimiterDropdownMenu = function()
    local delimiters = { ";" , "~" , "," , "::" , "||" , "\\t" };
    local buffer = 6;
    local height = 0;

    -- Initiate the buttons holder
    GRM_UI.GRM_ExportLogBorderFrame.GRM_DelimiterDropdownMenu.Buttons = GRM_UI.GRM_ExportLogBorderFrame.GRM_DelimiterDropdownMenu.Buttons or {};

    for i = 1 , #GRM_UI.GRM_ExportLogBorderFrame.GRM_DelimiterDropdownMenu.Buttons do
        GRM_UI.GRM_ExportLogBorderFrame.GRM_DelimiterDropdownMenu.Buttons[i][1]:Hide();
    end
    
    for i = 1 , #delimiters do
        if not GRM_UI.GRM_ExportLogBorderFrame.GRM_DelimiterDropdownMenu.Buttons[i] then
            local tempButton = CreateFrame ( "Button" , "GRM_DelimiterButton" .. i , GRM_UI.GRM_ExportLogBorderFrame.GRM_DelimiterDropdownMenu );
            GRM_UI.GRM_ExportLogBorderFrame.GRM_DelimiterDropdownMenu.Buttons[i] = { tempButton , tempButton:CreateFontString ( nil , "OVERLAY" , "GameFontWhiteTiny" ) }
        end

        local DelimiterButton = GRM_UI.GRM_ExportLogBorderFrame.GRM_DelimiterDropdownMenu.Buttons[i][1];
        local DelimiterButtonText = GRM_UI.GRM_ExportLogBorderFrame.GRM_DelimiterDropdownMenu.Buttons[i][2];
        DelimiterButton:SetWidth ( 60 );
        DelimiterButton:SetHeight ( 16 );
        DelimiterButton:SetHighlightTexture ( "Interface\\Buttons\\UI-Panel-Button-Highlight" );
        
        DelimiterButtonText:SetText ( "|cffffd600\"|r " .. delimiters[i] .. " |cffffd600\"|r" );
        DelimiterButtonText:SetTextColor ( 0.0 , 0.8 , 1.0 , 1.0 );
        DelimiterButtonText:SetWidth ( 55 );
        DelimiterButtonText:SetWordWrap ( false );
        DelimiterButtonText:SetFont ( GRM_G.FontChoice , GRM_G.FontModifier + 16 );
        DelimiterButtonText:SetPoint ( "CENTER" , DelimiterButton );
        DelimiterButtonText:SetJustifyH ( "CENTER" );

        if i == 1 then
            DelimiterButton:SetPoint ( "TOP" , GRM_UI.GRM_ExportLogBorderFrame.GRM_DelimiterDropdownMenu , 0 , -7 );
            height = height + DelimiterButton:GetHeight();
        else
            DelimiterButton:SetPoint ( "TOP" , GRM_UI.GRM_ExportLogBorderFrame.GRM_DelimiterDropdownMenu.Buttons[i - 1][1] , "BOTTOM" , 0 , -buffer );
            height = height + DelimiterButton:GetHeight() + buffer;
        end

        DelimiterButton:SetScript ( "OnClick" , function( self , button ) 
            if button == "LeftButton" then
                local parsedNumber = tonumber ( string.match ( self:GetName() , "(%d+)" ) );

                GRM.S().exportDelimiter[2] = GRM.Trim ( string.gsub ( GRM_UI.GRM_ExportLogBorderFrame.GRM_DelimiterDropdownMenu.Buttons[parsedNumber][2]:GetText() , "|cffffd600\"|r" , "" ) );

                GRM_UI.GRM_ExportLogBorderFrame.GRM_DelimiterDropdownMenuSelected.GRM_DelimiterDropdownMenuText:SetText ( DelimiterButtonText:GetText() );
                GRM_UI.GRM_ExportLogBorderFrame.GRM_DelimiterDropdownMenu:Hide();
                GRM_UI.GRM_ExportLogBorderFrame.GRM_DelimiterDropdownMenuSelected:Show();
            end
        end);
        DelimiterButton:Show();
    end
    GRM_UI.GRM_ExportLogBorderFrame.GRM_DelimiterDropdownMenu:SetHeight ( height + 15 );
end

-- Method:          GRM.ExportScrollSliderConfigure ( int , float )
-- What it Does:    Used in the building of the xport frame for the log. This sets the slider values.
-- Purpose:         Kept seperate so it can run recrusively on re-checking if necessary.
GRM.ExportScrollSliderConfigure = function ( scrollWidth )
    local scrollHeight = GRM_UI.GRM_ExportLogBorderFrame.GRM_ExportLogFrameEditBox:GetHeight();
    GRM_UI.GRM_ExportLogBorderFrame.GRM_ExportLogFrameEditBox:SetSize ( scrollWidth , scrollHeight + 10 );
    local scrollMax = ( scrollHeight - ( GRM_UI.GRM_ExportLogBorderFrame.GRM_ExportLogScrollFrame:GetHeight() - 5 ) ) + GRM_G.FontModifier + 12;
    if scrollMax < 0 then
        scrollMax = 0;
    end
    GRM_UI.GRM_ExportLogBorderFrame.GRM_ExportLogScrollFrameSlider:SetMinMaxValues ( 0 , scrollMax );
    -- Mousewheel Scrolling Logic
    GRM_UI.GRM_ExportLogBorderFrame.GRM_ExportLogScrollFrame:EnableMouseWheel( true );
    GRM_UI.GRM_ExportLogBorderFrame.GRM_ExportLogScrollFrame:SetScript( "OnMouseWheel" , function( _ , delta )
        local current = GRM_UI.GRM_ExportLogBorderFrame.GRM_ExportLogScrollFrameSlider:GetValue();
        
        if IsShiftKeyDown() and delta > 0 then
            GRM_UI.GRM_ExportLogBorderFrame.GRM_ExportLogScrollFrameSlider:SetValue ( 0 );
        elseif IsShiftKeyDown() and delta < 0 then
            GRM_UI.GRM_ExportLogBorderFrame.GRM_ExportLogScrollFrameSlider:SetValue ( scrollMax );
        elseif delta < 0 and current < scrollMax then
            if IsControlKeyDown() then
                GRM_UI.GRM_ExportLogBorderFrame.GRM_ExportLogScrollFrameSlider:SetValue ( current + 60 );
            else
                GRM_UI.GRM_ExportLogBorderFrame.GRM_ExportLogScrollFrameSlider:SetValue ( current + 20 );
            end
        elseif delta > 0 and current > 1 then
            if IsControlKeyDown() then
                GRM_UI.GRM_ExportLogBorderFrame.GRM_ExportLogScrollFrameSlider:SetValue ( current - 60 );
            else
                GRM_UI.GRM_ExportLogBorderFrame.GRM_ExportLogScrollFrameSlider:SetValue ( current - 20 );
            end
        end
    end);
end

-- Method:          GRM.ReconfigureLogMessage()
-- What it Does:    Reprocesses some logic everytime the log filters are adjusted
-- Purpose:         Live frame manipulation and updates.
GRM.ReconfigureLogMessage = function()
    if #GRM_G.fullLogMatch == 0 then
        GRM_UI.GRM_ExportLogBorderFrame.GRM_ExportLoadingText:SetText ( GRM.L ( "The Log is Currently Empty for This Guild" ) );
        GRM_UI.GRM_ExportLogBorderFrame.GRM_ExportLoadingText:Show();
    elseif GRM_UI.GRM_ExportLogBorderFrame.GRM_ExportLoadingText:IsVisible() then
        GRM_UI.GRM_ExportLogBorderFrame.GRM_ExportLoadingText:Hide();
    end
end

-- Method:          GRM.BuildCustomNoteScrollFrame ( string )
-- What it Does:    Builds the custom note scroll frame
-- Purpose:         To have a customizable scrollable scrollframe!!!
GRM.BuildCustomNoteScrollFrame = function( customNote )
    if GRM_G.previousNote ~= customNote then
        GRM_G.previousNote = customNote;
        local scrollHeight = 0;
        local scrollWidth = 123;

        if customNote == "" and not GRM_UI.GRM_MemberDetailMetaData.GRM_CustomNoteEditBoxFrame.GRM_CustomNoteEditBox:HasFocus() then
            customNote = GRM.L ( "Click here to set Custom Notes" );
        end
        GRM_UI.GRM_MemberDetailMetaData.GRM_CustomNoteEditBoxFrame.GRM_CustomNoteEditBox:SetText ( customNote );

        -- Slight delay needed before you can do a GetHeight()
        C_Timer.After ( 0.05 , function()
            scrollHeight = GRM_UI.GRM_MemberDetailMetaData.GRM_CustomNoteEditBoxFrame.GRM_CustomNoteEditBox:GetHeight();
            GRM_UI.GRM_MemberDetailMetaData.GRM_CustomNoteEditBoxFrame.GRM_CustomNoteEditBox:SetSize ( scrollWidth , scrollHeight + 10 );

            local scrollMax = ( scrollHeight - 80 ) + GRM_G.FontModifier + 5;
            if scrollMax < 0 then
                scrollMax = 0;                
            end
            GRM_UI.GRM_MemberDetailMetaData.GRM_CustomNoteEditBoxFrame.GRM_CustomNoteScrollFrameSlider:SetMinMaxValues ( 0 , scrollMax );
            -- Mousewheel Scrolling Logic
            GRM_UI.GRM_MemberDetailMetaData.GRM_CustomNoteEditBoxFrame.GRM_CustomNoteScrollFrame:EnableMouseWheel( true );
            GRM_UI.GRM_MemberDetailMetaData.GRM_CustomNoteEditBoxFrame.GRM_CustomNoteScrollFrame:SetScript( "OnMouseWheel" , function( _ , delta )
                local current = GRM_UI.GRM_MemberDetailMetaData.GRM_CustomNoteEditBoxFrame.GRM_CustomNoteScrollFrameSlider:GetValue();
                
                if IsShiftKeyDown() and delta > 0 then
                    GRM_UI.GRM_MemberDetailMetaData.GRM_CustomNoteEditBoxFrame.GRM_CustomNoteScrollFrameSlider:SetValue ( 0 );
                elseif IsShiftKeyDown() and delta < 0 then
                    GRM_UI.GRM_MemberDetailMetaData.GRM_CustomNoteEditBoxFrame.GRM_CustomNoteScrollFrameSlider:SetValue ( scrollMax );
                elseif delta < 0 and current < scrollMax then
                    if IsControlKeyDown() then
                        GRM_UI.GRM_MemberDetailMetaData.GRM_CustomNoteEditBoxFrame.GRM_CustomNoteScrollFrameSlider:SetValue ( current + 60 );
                    else
                        GRM_UI.GRM_MemberDetailMetaData.GRM_CustomNoteEditBoxFrame.GRM_CustomNoteScrollFrameSlider:SetValue ( current + 20 );
                    end
                elseif delta > 0 and current > 1 then
                    if IsControlKeyDown() then
                        GRM_UI.GRM_MemberDetailMetaData.GRM_CustomNoteEditBoxFrame.GRM_CustomNoteScrollFrameSlider:SetValue ( current - 60 );
                    else
                        GRM_UI.GRM_MemberDetailMetaData.GRM_CustomNoteEditBoxFrame.GRM_CustomNoteScrollFrameSlider:SetValue ( current - 20 );
                    end
                end
            end);
        end);
    end
end

------------------------------------
---- BEGIN OF FRAME/UI LOGIC -------
---- General Framebuild Methods ----
------------------------------------


-- Method:          GRM.OnDropMenuClickDay()
-- What it Does:    Upon clicking any item in a drop down menu, this sets the ID of that item as defaulted choice
-- Purpose:         General use clicking logic for month based drop down menu.
GRM.OnDropMenuClickDay = function ()
    GRM_G.dayIndex = tonumber ( GRM_UI.GRM_MemberDetailMetaData.GRM_DayDropDownMenuSelected.GRM_DayText:GetText() );
    GRM.InitializeDropDownDay();
end

-- Method:          GRM.OnDropMenuClickMonth()
-- What it Does:    Recalculates the logic of number days to show.
-- Purpose:         General use clicking logic for month based drop down menu.
GRM.OnDropMenuClickMonth = function ()
    GRM_G.monthIndex = monthsFullnameEnum [ GRM.OrigL ( GRM_UI.GRM_MemberDetailMetaData.GRM_MonthDropDownMenuSelected.GRM_MonthText:GetText() ) ];
    GRM.InitializeDropDownDay();
end

-- Method:          GRM.OnDropMenuClickYear()
-- What it Does:    Upon clicking any item in a drop down menu, this sets the ID of that item as defaulted choice
-- Purpose:         General use clicking logic for year based drop down menu.
GRM.OnDropMenuClickYear = function ()
    GRM_G.yearIndex = tonumber ( GRM_UI.GRM_MemberDetailMetaData.GRM_YearDropDownMenuSelected.GRM_YearText:GetText() );
    GRM.InitializeDropDownDay();
end

-- Method:          GRM.InitializeDropDownDay ()
-- What it Does:    Initializes the Drop Down "Day" select window with values based on selected month
-- Purpose:         UI feature for easy date select.
GRM.InitializeDropDownDay = function ()
    local shortMonth = 30;
    local longMonth = 31;
    local febMonth = 28;
    local leapYear = 29;
    local yearDate = 0;

    yearDate = GRM_G.yearIndex;
    local isDateALeapyear = GRM.IsLeapYear(yearDate);
    local numDays;
    
    if GRM_G.monthIndex == 1 or GRM_G.monthIndex == 3 or GRM_G.monthIndex == 5 or GRM_G.monthIndex == 7 or GRM_G.monthIndex == 8 or GRM_G.monthIndex == 10 or GRM_G.monthIndex == 12 then
        numDays = longMonth;
    elseif GRM_G.monthIndex == 2 and isDateALeapyear then
        numDays = leapYear;
    elseif GRM_G.monthIndex == 2 then
        numDays = febMonth;
    else
        numDays = shortMonth;
    end
      
    -- populating the frames!
    local buffer = 3;
    local height = 0;
    GRM_UI.GRM_MemberDetailMetaData.GRM_DayDropDownMenu.Buttons = GRM_UI.GRM_MemberDetailMetaData.GRM_DayDropDownMenu.Buttons or {};

    -- Resetting the buttons!
    for i = 1 , #GRM_UI.GRM_MemberDetailMetaData.GRM_DayDropDownMenu.Buttons do
        GRM_UI.GRM_MemberDetailMetaData.GRM_DayDropDownMenu.Buttons[i][1]:Hide();
    end
    
    for i = 1 , numDays do
        if not GRM_UI.GRM_MemberDetailMetaData.GRM_DayDropDownMenu.Buttons[i] then
            local tempButton = CreateFrame ( "Button" , "DayOfTheMonth" .. i , GRM_UI.GRM_MemberDetailMetaData.GRM_DayDropDownMenu );
            GRM_UI.GRM_MemberDetailMetaData.GRM_DayDropDownMenu.Buttons[i] = { tempButton , tempButton:CreateFontString ( nil , "OVERLAY" , "GameFontWhiteTiny" ) }
        end

        local DayButtons = GRM_UI.GRM_MemberDetailMetaData.GRM_DayDropDownMenu.Buttons[i][1];
        local DayButtonsText = GRM_UI.GRM_MemberDetailMetaData.GRM_DayDropDownMenu.Buttons[i][2];
        DayButtons:SetWidth ( 24 );
        DayButtons:SetHeight ( 10 );
        DayButtons:SetHighlightTexture ( "Interface\\Buttons\\UI-Panel-Button-Highlight" );
        DayButtonsText:SetText ( i );
        DayButtonsText:SetWidth ( 25 );
        DayButtonsText:SetWordWrap ( false );
        DayButtonsText:SetFont ( GRM_G.FontChoice , GRM_G.FontModifier + 9 );
        DayButtonsText:SetPoint ( "CENTER" , DayButtons );
        DayButtonsText:SetJustifyH ( "CENTER" );

        if i == 1 then
            DayButtons:SetPoint ( "TOP" , GRM_UI.GRM_MemberDetailMetaData.GRM_DayDropDownMenu , 0 , -7 );
            height = height + DayButtons:GetHeight();
        else
            DayButtons:SetPoint ( "TOP" , GRM_UI.GRM_MemberDetailMetaData.GRM_DayDropDownMenu.Buttons[i - 1][1] , "BOTTOM" , 0 , -buffer );
            height = height + DayButtons:GetHeight() + buffer;
        end

        DayButtons:SetScript ( "OnClick" , function( _ , button ) 
            if button == "LeftButton" then
                GRM_UI.GRM_MemberDetailMetaData.GRM_DayDropDownMenuSelected.GRM_DayText:SetText ( DayButtonsText:GetText() );
                GRM_UI.GRM_MemberDetailMetaData.GRM_DayDropDownMenu:Hide();
                GRM_UI.GRM_MemberDetailMetaData.GRM_DayDropDownMenuSelected:Show();
                GRM.OnDropMenuClickDay();
            end
        end); 

        DayButtons:Show();
    end
    GRM_UI.GRM_MemberDetailMetaData.GRM_DayDropDownMenu:SetHeight ( height + 15 );
end

-- Method:          GRM.InitializeDropDownYear()
-- What it Does:    Initializes the year select drop-down OnDropMenuClick
-- Purpose:         Easy way to set when player joined the guild.         
GRM.InitializeDropDownYear = function ()
    -- Year Drop Down
    local currentYear = select ( 4 , GRM.GetTodaysDate() );
    local yearStamp = currentYear;

    -- populating the frames!
    local buffer = 2;
    local height = 0;
    GRM_UI.GRM_MemberDetailMetaData.GRM_YearDropDownMenu.Buttons = GRM_UI.GRM_MemberDetailMetaData.GRM_YearDropDownMenu.Buttons or {};

    -- Resetting the buttons!
    for i = 1 , #GRM_UI.GRM_MemberDetailMetaData.GRM_YearDropDownMenu.Buttons do
        GRM_UI.GRM_MemberDetailMetaData.GRM_YearDropDownMenu.Buttons[i][1]:Hide();
    end
    
    -- Game wasn't released until early 2004
    for i = 1 , currentYear - 2003 do
        if not GRM_UI.GRM_MemberDetailMetaData.GRM_YearDropDownMenu.Buttons[i] then
            local tempButton = CreateFrame ( "Button" , "YearIndexButton" .. i , GRM_UI.GRM_MemberDetailMetaData.GRM_YearDropDownMenu );
            GRM_UI.GRM_MemberDetailMetaData.GRM_YearDropDownMenu.Buttons[i] = { tempButton , tempButton:CreateFontString ( nil , "OVERLAY" , "GameFontWhiteTiny" ) }
        end

        local YearButtons = GRM_UI.GRM_MemberDetailMetaData.GRM_YearDropDownMenu.Buttons[i][1];
        local YearButtonsText = GRM_UI.GRM_MemberDetailMetaData.GRM_YearDropDownMenu.Buttons[i][2];
        YearButtons:SetWidth ( 40 );
        YearButtons:SetHeight ( 10 );
        YearButtons:SetHighlightTexture ( "Interface\\Buttons\\UI-Panel-Button-Highlight" );
        YearButtonsText:SetText ( yearStamp );
        YearButtonsText:SetWidth ( 32 );
        YearButtonsText:SetWordWrap ( false );
        YearButtonsText:SetFont ( GRM_G.FontChoice , GRM_G.FontModifier + 9 );
        YearButtonsText:SetPoint ( "CENTER" , YearButtons );
        YearButtonsText:SetJustifyH ( "CENTER" );

        if i == 1 then
            YearButtons:SetPoint ( "TOP" , GRM_UI.GRM_MemberDetailMetaData.GRM_YearDropDownMenu , 0 , -7 );
            height = height + YearButtons:GetHeight();
        else
            YearButtons:SetPoint ( "TOP" , GRM_UI.GRM_MemberDetailMetaData.GRM_YearDropDownMenu.Buttons[i - 1][1] , "BOTTOM" , 0 , -buffer );
            height = height + YearButtons:GetHeight() + buffer;
        end

        YearButtons:SetScript ( "OnClick" , function( _ , button ) 
            if button == "LeftButton" then
                GRM_UI.GRM_MemberDetailMetaData.GRM_YearDropDownMenuSelected.GRM_YearText:SetText ( YearButtonsText:GetText() );
                GRM_UI.GRM_MemberDetailMetaData.GRM_YearDropDownMenu:Hide();
                GRM_UI.GRM_MemberDetailMetaData.GRM_YearDropDownMenuSelected:Show();
                GRM.OnDropMenuClickYear();
            end
        end); 
        yearStamp = yearStamp - 1                       -- Descending the year by 1
        YearButtons:Show();
    end
    GRM_UI.GRM_MemberDetailMetaData.GRM_YearDropDownMenu:SetHeight ( height + 15 );

end

-- Method:          GRM.InitializeDropDownMonth(self,level)
-- What it Does:    Initializes month drop select menu
-- Purpose:         Date select for Officer Note "Join Date"
GRM.InitializeDropDownMonth = function ()
    -- Month Drop Down
    local months = { "January" , "February" , "March" , "April" , "May" , "June" , "July" , "August" , "September" , "October" , "November" , "December" };
    
    -- populating the frames!
    local buffer = 3;
    local height = 0;
    GRM_UI.GRM_MemberDetailMetaData.GRM_MonthDropDownMenu.Buttons = GRM_UI.GRM_MemberDetailMetaData.GRM_MonthDropDownMenu.Buttons or {};

    -- Resetting the buttons!
    for i = 1 , #GRM_UI.GRM_MemberDetailMetaData.GRM_MonthDropDownMenu.Buttons do
        GRM_UI.GRM_MemberDetailMetaData.GRM_MonthDropDownMenu.Buttons[i][1]:Hide();
    end
    
    for i = 1 , #months do
        if not GRM_UI.GRM_MemberDetailMetaData.GRM_MonthDropDownMenu.Buttons[i] then
            local tempButton = CreateFrame ( "Button" , "monthIndex" .. i , GRM_UI.GRM_MemberDetailMetaData.GRM_MonthDropDownMenu );
            GRM_UI.GRM_MemberDetailMetaData.GRM_MonthDropDownMenu.Buttons[i] = { tempButton , tempButton:CreateFontString ( nil , "OVERLAY" , "GameFontWhiteTiny" ) }
        end

        local MonthButtons = GRM_UI.GRM_MemberDetailMetaData.GRM_MonthDropDownMenu.Buttons[i][1];
        local MonthButtonsText = GRM_UI.GRM_MemberDetailMetaData.GRM_MonthDropDownMenu.Buttons[i][2];
        MonthButtons:SetWidth ( 83 );
        MonthButtons:SetHeight ( 10 );
        MonthButtons:SetHighlightTexture ( "Interface\\Buttons\\UI-Panel-Button-Highlight" );
        MonthButtonsText:SetText ( GRM.L ( months[i] ) );
        MonthButtonsText:SetWidth ( 83 );
        MonthButtonsText:SetWordWrap ( false );
        MonthButtonsText:SetFont ( GRM_G.FontChoice , GRM_G.FontModifier + 9 );
        MonthButtonsText:SetPoint ( "CENTER" , MonthButtons );
        MonthButtonsText:SetJustifyH ( "CENTER" );

        if i == 1 then
            MonthButtons:SetPoint ( "TOP" , GRM_UI.GRM_MemberDetailMetaData.GRM_MonthDropDownMenu , 0 , -7 );
            height = height + MonthButtons:GetHeight();
        else
            MonthButtons:SetPoint ( "TOP" , GRM_UI.GRM_MemberDetailMetaData.GRM_MonthDropDownMenu.Buttons[i - 1][1] , "BOTTOM" , 0 , -buffer );
            height = height + MonthButtons:GetHeight() + buffer;
        end

        MonthButtons:SetScript ( "OnClick" , function( _ , button ) 
            if button == "LeftButton" then
                GRM_UI.GRM_MemberDetailMetaData.GRM_MonthDropDownMenuSelected.GRM_MonthText:SetText ( MonthButtonsText:GetText() );
                GRM_UI.GRM_MemberDetailMetaData.GRM_MonthDropDownMenu:Hide();
                GRM_UI.GRM_MemberDetailMetaData.GRM_MonthDropDownMenuSelected:Show();
                GRM.OnDropMenuClickMonth();
            end
        end); 

        MonthButtons:Show();
    end
    GRM_UI.GRM_MemberDetailMetaData.GRM_MonthDropDownMenu:SetHeight ( height + 15 );
end

-- Method:          GRM.SetJoinDate()
-- What it Does:    Sets the player's join date properly, be it the first time, a modified time, or an edit.
-- Purpose:         For so many uses! Anniversary tracking, for editing the date, and so on...
GRM.SetJoinDate = function ( name , dayJoined , monthJoined , yearJoined  )
    name = name or GRM_G.currentName;
    dayJoined = dayJoined or tonumber ( GRM_UI.GRM_MemberDetailMetaData.GRM_DayDropDownMenuSelected.GRM_DayText:GetText() );
    monthJoined = monthJoined or monthsFullnameEnum [ GRM.OrigL ( GRM_UI.GRM_MemberDetailMetaData.GRM_MonthDropDownMenuSelected.GRM_MonthText:GetText() ) ];
    yearJoined = yearJoined or tonumber ( GRM_UI.GRM_MemberDetailMetaData.GRM_YearDropDownMenuSelected.GRM_YearText:GetText() );

    if GRM.IsValidSubmitDate ( dayJoined , monthJoined , yearJoined, GRM.IsLeapYear ( yearJoined ) ) then
        local rankButton = false;
        local showBdayText = false;
        local formatBdayStamp = "";
        local player = GRM.GetPlayer ( name );

        if player then

            -- For metadata tracking
            if GRM_UI.GRM_MemberDetailMetaData.GRM_DateSubmitButtonTxt:GetText() == GRM.L ( "Edit Join Date" ) or #player.joinDateHist[1][4] == 1 then
                table.remove ( player.joinDateHist , 1 );  -- Removing previous instance to replace
            end

            table.insert ( player.joinDateHist , 1 , { dayJoined , monthJoined , yearJoined , GRM.ConvertToStandardFormatDate ( dayJoined , monthJoined , yearJoined ) , time() , true , 1 } );

            -- If it was unKnown before
            player.joinDateUnknown = false;

            if player.events[2][1][1] ~= 0 then
                showBdayText = true;
                formatBdayStamp = GRM.FormatTimeStamp ( player.events[2][3] , false , true );
            end

            -- For UI
            local finalTStamp = GRM.FormatTimeStamp ( { dayJoined , monthJoined , yearJoined } , false , false , false );
            GRM_UI.GRM_MemberDetailMetaData.GRM_JoinDateText:SetText ( finalTStamp );
            
            -- Update timestamp to note.
            GRM.AddTimeStampToNote ( name , finalTStamp );

            -- Gotta update the event tracker date too!
            player.events[1][1][1] = dayJoined;
            player.events[1][1][2] = monthJoined;
            player.events[1][1][3] = yearJoined;
            player.events[1][2] = false;  -- Gotta Reset the "reported already" boolean!
            GRM.RemoveFromCalendarQue ( name , 1 , nil );

            -- Should definitely refresh the frame here if necessary... prevent mouse tooltip errors
            if GRM_UI.GRM_RosterChangeLogFrame.GRM_EventsFrame:IsVisible() then
                GRM.RefreshAddEventFrame()
            end

            if #player.rankHist[1][5] == 0 and not player.promoteDateUnknown then
                rankButton = true;
            end

            -- Need player index to get this info.
            if player.isOnline then
                if player.zone ~= nil then
                    GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailMetaZoneInfoZoneText:SetText ( player.zone );                                       -- Zone
                    GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailMetaZoneInfoTimeText2:SetText ( GRM.GetTimePassedInZone ( player.timeEnteredZone ) );                 -- Time Passed
                end
                GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailMetaZoneInfoText:Show();
                GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailMetaZoneInfoZoneText:Show();
                GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailMetaZoneInfoTimeText1:Show();
                GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailMetaZoneInfoTimeText2:Show();
            end

            -- Let's send the changes out as well!
            if GRM.S().syncEnabled then
                local syncRankFilter = GRM.S().syncRank;
                if GRM.S().exportAllRanks then
                    syncRankFilter = GuildControlGetNumRanks() - 1;
                end
                GRMsync.SendMessage ( "GRM_SYNC" , GRM_G.PatchDayString .. "?GRM_JD?" .. syncRankFilter .. "?" .. name .. "?" .. tostring ( player.joinDateHist[1][5] ) .. "?" .. player.joinDateHist[1][4] .. "?" .. tostring ( GRM.S().joinDateDestination ) , "GUILD");
                
            end
        end

        GRM_UI.GRM_MemberDetailMetaData.GRM_DayDropDownMenuSelected:Hide();
        GRM_UI.GRM_MemberDetailMetaData.GRM_MonthDropDownMenuSelected:Hide();
        GRM_UI.GRM_MemberDetailMetaData.GRM_YearDropDownMenuSelected:Hide();
        GRM_UI.GRM_MemberDetailMetaData.GRM_DateSubmitCancelButton:Hide();
        GRM_UI.GRM_MemberDetailMetaData.GRM_DateSubmitButton:Hide();
        GRM_UI.GRM_MemberDetailMetaData.GRM_JoinDateText:Show();
        if rankButton then
            GRM_UI.GRM_MemberDetailMetaData.GRM_SetPromoDateButton:Show();
        else
            GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailRankDateTxt:Show();
        end

        -- Birthday Logic restoration
        if GRM.S().showBDay and not GRM_UI.GRM_MemberDetailMetaData.GRM_BirthdayText:IsVisible() and not GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailBirthdayButton:IsVisible() then
            if showBdayText then
                GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailBirthdayButton:Hide();
                GRM_UI.GRM_MemberDetailMetaData.GRM_BirthdayText:SetText ( formatBdayStamp );
                GRM_UI.GRM_MemberDetailMetaData.GRM_BirthdayText:Show();
            else
                GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailBirthdayButton:Show();
                GRM_UI.GRM_MemberDetailMetaData.GRM_BirthdayText:Hide();
            end
        end

        -- Show if there are alts to unify join dates
        if GRM.PlayerOrAltHasJD ( GRM_G.currentName ) then
            if GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailJoinDateButton:IsVisible() then
                GRM_UI.GRM_MemberDetailMetaData.GRM_SyncDateArrowButton:ClearAllPoints();
                GRM_UI.GRM_MemberDetailMetaData.GRM_SyncDateArrowButton:SetPoint ( "LEFT" , GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailJoinDateButton , "RIGHT" , 0 , 0 );
            elseif GRM_UI.GRM_MemberDetailMetaData.GRM_JoinDateText:IsVisible() then
                GRM_UI.GRM_MemberDetailMetaData.GRM_SyncDateArrowButton:ClearAllPoints();
                GRM_UI.GRM_MemberDetailMetaData.GRM_SyncDateArrowButton:SetPoint ( "LEFT" , GRM_UI.GRM_MemberDetailMetaData.GRM_JoinDateText , "RIGHT" , 8 , -0.5 );
            end
            GRM_UI.GRM_MemberDetailMetaData.GRM_SyncDateArrowButton:Show();
        else
            GRM_UI.GRM_MemberDetailMetaData.GRM_SyncDateArrowButton:Hide();
        end

        GRM_UI.Unpause();
        -- Update the Audit Frames!
        if GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame:IsVisible() then
            GRM.RefreshAuditFrames ( true , true );
        end
    end
end

-- Method:          GRM.PlayerHasJoinDate ( string )
-- What it Does:    Returns true if the current selected player has a listed Join Date, with the given JoinDate
-- Purpose:         For the Join Date selection, this will let us know if an option to sync to the selected player's join date should be given.
GRM.PlayerHasJoinDate = function ( playerName )
    local result = { false , "" };
    local player = GRM.GetPlayer ( playerName );

    if player then
        if #player.joinDateHist[1][4] > 1 then       -- Player Has a join date!
            result = { true , GRM.FormatTimeStamp ( { player.joinDateHist[1][1] , player.joinDateHist[1][2] , player.joinDateHist[1][3] } , false , false ) };
        end
    end
    return result;
end

-- Method:          GRM.SetPromoDate()
-- What it Does:    Set's the date the player was promoted to the current rank
-- Purpose:         Date tracking and control of rank promotions.
GRM.SetPromoDate = function ( name , day , month , year , isManual )
    name = name or GRM_G.currentName;
    day = day or tonumber ( GRM_UI.GRM_MemberDetailMetaData.GRM_DayDropDownMenuSelected.GRM_DayText:GetText() );
    month = month or monthsFullnameEnum [ GRM.OrigL ( GRM_UI.GRM_MemberDetailMetaData.GRM_MonthDropDownMenuSelected.GRM_MonthText:GetText() ) ];
    year = year or tonumber ( GRM_UI.GRM_MemberDetailMetaData.GRM_YearDropDownMenuSelected.GRM_YearText:GetText() );
    
    if GRM.IsValidSubmitDate ( day , month , year, GRM.IsLeapYear ( year ) ) then
        local player = GRM.GetPlayer ( name );

        if player then

            -- Promo Save Data
            player.rankHist[1][1] = player.rankName;
            player.rankHist[1][2] = day;
            player.rankHist[1][3] = month;
            player.rankHist[1][4] = year;
            player.rankHist[1][5] = GRM.ConvertToStandardFormatDate ( day , month , year );
            player.rankHist[1][6] = time();
            player.rankHist[1][7] = true;
            player.rankHist[1][8] = 1;
            
            -- If player had it set to "unknown before"
            player.promoteDateUnknown = false;

            if name == GRM_G.currentName and GRM_UI.GRM_MemberDetailMetaData:IsVisible() then
            
                GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailRankDateTxt:SetText ( GRM.L ( "Promoted:" ) .. " " .. GRM.FormatTimeStamp ( { player.rankHist[1][2] , player.rankHist[1][3] , player.rankHist[1][4] } , false ) );

                if player.isOnline then
                    if player.zone ~= nil then
                        GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailMetaZoneInfoZoneText:SetText ( player.zone );                                     -- Zone
                        GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailMetaZoneInfoTimeText2:SetText ( GRM.GetTimePassedInZone ( player.timeEnteredZone ) );              -- Time Passed
                    end
                    GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailMetaZoneInfoText:Show();
                    GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailMetaZoneInfoZoneText:Show();
                    GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailMetaZoneInfoTimeText1:Show();
                    GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailMetaZoneInfoTimeText2:Show();
                end
            end

            if not isManual then
                -- Send the details out for others to pickup!
                if GRM.S().syncEnabled then
                    local syncRankFilter = GRM.S().syncRank;
                    if GRM.S().exportAllRanks then
                        syncRankFilter = GuildControlGetNumRanks() - 1;
                    end
                    GRMsync.SendMessage ( "GRM_SYNC" , GRM_G.PatchDayString .. "?GRM_PD?" .. syncRankFilter .. "?" .. name .. "?" .. tostring ( player.rankHist[1][5] ) .. "?" .. tostring( player.rankHist[1][6] ) , "GUILD" );
                end
            end
        end

        if name == GRM_G.currentName and GRM_UI.GRM_MemberDetailMetaData:IsVisible() then
            GRM_UI.GRM_MemberDetailMetaData.GRM_DayDropDownMenuSelected:Hide();
            GRM_UI.GRM_MemberDetailMetaData.GRM_MonthDropDownMenuSelected:Hide();
            GRM_UI.GRM_MemberDetailMetaData.GRM_YearDropDownMenuSelected:Hide();
            GRM_UI.GRM_MemberDetailMetaData.GRM_DateSubmitCancelButton:Hide();
            GRM_UI.GRM_MemberDetailMetaData.GRM_DateSubmitButton:Hide();
            GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailRankDateTxt:Show();

            GRM_UI.Unpause();
            -- Update Audit Frames.
            if GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame:IsVisible() then
                GRM.RefreshAuditFrames ( true , true );
            end
        end
    end
end

-- Method:          GRM.SetAllIncompleteJoinUnknown()
-- What it Does:    Sets the join date of every player in the guild who does not have it yet set as "unknown"
-- Purpose:         More just quality of life information and UI feature. Useful than manually going to them all to set as unknown...
GRM.SetAllIncompleteJoinUnknown = function()
    if not ( GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_SetJoinUnkownButton.GRM_SetJoinUnkownButtonText:GetText() == GRM.L ( "All Complete" ) ) then
        if time() - GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_SetJoinUnkownButton.timer >= 2 then

            if GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_SetJoinUnkownButton.GRM_SetJoinUnkownButtonText:GetText() == GRM.L ( "Set Incomplete to Unknown" ) then
                -- Ok, let's go through ALL guildies and clear it!
                for _ , player in pairs ( GRM.GetGuild() ) do
                    if type ( player ) == "table" then

                        -- if not "unknown" already, and if it doesn't have an established join date
                        if not player.joinDateUnknown and #player.joinDateHist[1][4] == 1 then
                            GRM.ClearJoinDateHistory ( player.name , true );
                            GRM.DateSubmitCancelResetLogic( true , "join" , true , player.name );
                        elseif GRM_UI.GRM_MemberDetailMetaData:IsVisible() and GRM_G.currentName == player.name then
                            GRM_G.pause = false;
                            GRM.ClearAllFrames( true );
                            GRM.PopulateMemberDetails ( player.name );
                            GRM_UI.GRM_MemberDetailMetaData:Show();
                            if GRM_UI.MemberDetailFrame and GRM_UI.MemberDetailFrame:IsVisible() then
                                GRM_UI.MemberDetailFrame:Hide();
                            end
                            if GuildFrame and GRM_UI.MemberDetailFrameClassic and GRM_UI.MemberDetailFrameClassic:IsVisible() then
                                GRM_UI.MemberDetailFrameClassic:Hide();
                            end
                            GRM_G.pause = true;
                        end
                    end
                end
                GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_SetJoinUnkownButton.GRM_SetJoinUnkownButtonText:SetText ( GRM.L ( "Clear All Unknown" ) );
            else
                for _ , player in pairs ( GRM.GetGuild() ) do
                    if type ( player ) == "table" then

                        -- if not "unknown" already, and if it doesn't have an established join date
                        if player.joinDateUnknown then
                            GRM.ClearJoinDateHistory ( player.name , false );
                            GRM.DateSubmitCancelResetLogic( false , "join" , true , player.name );
                        elseif GRM_UI.GRM_MemberDetailMetaData:IsVisible() and GRM_G.currentName == player.name then
                            GRM_G.pause = false;
                            GRM.ClearAllFrames( true );
                            GRM.PopulateMemberDetails ( player.name );
                            GRM_UI.GRM_MemberDetailMetaData:Show();
                            if GRM_UI.MemberDetailFrame and GRM_UI.MemberDetailFrame:IsVisible() then
                                GRM_UI.MemberDetailFrame:Hide();
                            end
                            if GuildFrame and GRM_UI.MemberDetailFrameClassic and GRM_UI.MemberDetailFrameClassic:IsVisible() then
                                GRM_UI.MemberDetailFrameClassic:Hide();
                            end
                            GRM_G.pause = true;
                        end
                    end
                end
                GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_SetJoinUnkownButton.GRM_SetJoinUnkownButtonText:SetText ( GRM.L ( "Set Incomplete to Unknown" ) );
            end
            GRM.RefreshAuditFrames ( true , true );
            GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_SetJoinUnkownButton.timer = time();
        else
            GRM.Report ( GRM.L ( "Please Wait {num} more Seconds" , nil , nil , math.floor ( 2 - ( time() - GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_SetJoinUnkownButton.timer ) ) ) );
        end
    end
end

-- Method:          GRM.SetAllIncompletePromoUnknown()
-- What it Does:    Sets the promo date of every player in the guild who does not have it yet set to an unknown value
-- Purpose:         More just quality of life information and UI feature. Useful than manually going to them all...
GRM.SetAllIncompletePromoUnknown = function()
    if not ( GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_SetPromoUnkownButton.GRM_SetPromoUnkownButtonText:GetText() == GRM.L ( "All Complete" ) ) then
        if time() - GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_SetPromoUnkownButton.timer >= 2 then

            if GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_SetPromoUnkownButton.GRM_SetPromoUnkownButtonText:GetText() == GRM.L ( "Set Incomplete to Unknown" ) then
                for _ , player in pairs ( GRM.GetGuild() ) do
                    if type ( player ) == "table" then

                        -- if not "unknown" already, and if it doesn't have an established join date
                        if not player.promoteDateUnknown and not player.rankHist[1][7] then
                            GRM.ClearPromoDateHistory ( player.name , true );
                            GRM.DateSubmitCancelResetLogic( true , "promo" , true , player.name );
                        end
                    end
                end
                GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_SetPromoUnkownButton.GRM_SetPromoUnkownButtonText:SetText ( GRM.L ( "Clear All Unknown" ) );
            else
                for _ , player in pairs ( GRM.GetGuild() ) do
                    if type ( player ) == "table" then

                        if player.promoteDateUnknown then
                            GRM.ClearPromoDateHistory ( player.name , false );
                            GRM.DateSubmitCancelResetLogic( false , "promo" , true , player.name );
                        end
                    end
                end
                GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_SetPromoUnkownButton.GRM_SetPromoUnkownButtonText:SetText ( GRM.L ( "Set Incomplete to Unknown" ) );
            end
            GRM.RefreshAuditFrames ( true , true );
            GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_SetPromoUnkownButton.timer = time();
        else
            GRM.Report ( GRM.L ( "Please Wait {num} more Seconds" , nil , nil , math.floor ( 2 - ( time() - GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_SetPromoUnkownButton.timer ) ) ) );
        end
    end
end

-- Method:          GRM.SetAllIncompleteBdayUnknown()
-- What it Does:    Sets the Birth date of every player in the guild who does not have it yet set to an unknown value
-- Purpose:         More just quality of life information and UI feature. Useful than manually going to them all...
GRM.SetAllIncompleteBdayUnknown = function()
    if not ( GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_SetBdayUnkownButton.GRM_SetBdayUnkownButtonText:GetText() == GRM.L ( "All Complete" ) ) then
        if time() - GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_SetBdayUnkownButton.timer >= 3 then

            if GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_SetBdayUnkownButton.GRM_SetBdayUnkownButtonText:GetText() == GRM.L ( "Set Incomplete to Unknown" ) then
                for _ , player in pairs ( GRM.GetGuild() ) do
                    if type ( player ) == "table" then

                        -- if not "unknown" already, and if it doesn't have an established bday
                        if not player.birthdayUnknown and player.events[2][1][1] == 0 then
                            player.birthdayUnknown = true
                            if GRM_UI.GRM_MemberDetailMetaData:IsVisible() and GRM_G.currentName == player.name then
                                GRM_G.pause = false;
                                GRM.ClearAllFrames( true );
                                GRM.PopulateMemberDetails ( player.name );
                                GRM_UI.GRM_MemberDetailMetaData:Show();
                                if GRM_UI.MemberDetailFrame and GRM_UI.MemberDetailFrame:IsVisible() then
                                    GRM_UI.MemberDetailFrame:Hide();
                                end
                                if GuildFrame and GRM_UI.MemberDetailFrameClassic and GRM_UI.MemberDetailFrameClassic:IsVisible() then
                                    GRM_UI.MemberDetailFrameClassic:Hide();
                                end
                                GRM_G.pause = true;
                            end
                        end
                    end
                end
                GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_SetBdayUnkownButton.GRM_SetBdayUnkownButtonText:SetText ( GRM.L ( "Clear All Unknown" ) );
            else
                for _ , player in pairs ( GRM.GetGuild() ) do
                    if type ( player ) == "table" then

                        player.birthdayUnknown = false;
                        if GRM_UI.GRM_MemberDetailMetaData:IsVisible() and GRM_G.currentName == player.name then
                            GRM_G.pause = false;
                            GRM.ClearAllFrames( true );
                            GRM.PopulateMemberDetails ( player.name );
                            GRM_UI.GRM_MemberDetailMetaData:Show();
                            if GRM_UI.MemberDetailFrame and GRM_UI.MemberDetailFrame:IsVisible() then
                                GRM_UI.MemberDetailFrame:Hide();
                            end
                            if GuildFrame and GRM_UI.MemberDetailFrameClassic and GRM_UI.MemberDetailFrameClassic:IsVisible() then
                                GRM_UI.MemberDetailFrameClassic:Hide();
                            end
                            GRM_G.pause = true;
                        end
                    end
                end
                GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_SetBdayUnkownButton.GRM_SetBdayUnkownButtonText:SetText ( GRM.L ( "Set Incomplete to Unknown" ) );
            end
            GRM.RefreshAuditFrames ( true , true );
            GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_SetBdayUnkownButton.timer = time();
        else
            GRM.Report ( GRM.L ( "Please Wait {num} more Seconds" , nil , nil , math.floor ( 2 - ( time() - GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_SetBdayUnkownButton.timer ) ) ) );
        end
    end
end

-- Method:          GRM.DateSubmitCancelResetLogic( boolean , string , boolean , string )
-- What it Does:    Resets the logic on what occurs with the cancel button, since it will have multiple uses.
-- Purpose:         Resource efficiency. No need to make new buttons for everything! This reuses the button, just resets the click logic in join date submit cancel event.
GRM.DateSubmitCancelResetLogic = function( isUnknown , date , isAudit , playerName )
    local buttonText = GRM_UI.GRM_MemberDetailMetaData.GRM_DateSubmitButtonTxt:GetText();
    local joinDateText = GRM.L ( "Set Join Date" );
    local promoDateText = GRM.L ( "Set Promo Date" );
    local bDayDateText = GRM.L ( "Set Birthday" );
    local editDateText = GRM.L ( "Edit Promo Date" );
    local editJoinText = GRM.L ( "Edit Join Date" );
    local name = GRM_G.currentName;
    local showJoinText = false;
    local showBdayText = false;
    local formatBdayStamp = "";

    -- For the audit
    if isAudit then
        if date == "join" then
            buttonText = joinDateText;
        elseif date == "promo" then
            buttonText = promoDateText;
        elseif date == "bday" then
            buttonText = bDayDateText;
        end
    end

    -- To save values properly.
    if isAudit and playerName ~= nil then
        name = playerName;
    end
    
    local player = GRM.GetPlayer ( name );
    -- Need player index to get this info.

    if player then
        if player.name == GRM_G.currentName then
            if ( player.promoteDateUnknown or player.rankHist[1][7] ) then
                GRM_G.rankDateSet = true;
            end
            if player.joinDateUnknown or #player.joinDateHist[1][4] > 1 then
                showJoinText = true;
            end
            
            if isUnknown and date == "bday" then
                player.birthdayUnknown = true
            end
            if player.birthdayUnknown or player.events[2][1][1] ~= 0 then
                showBdayText = true;
                if not player.birthdayUnknown then
                    formatBdayStamp = GRM.FormatTimeStamp ( { player.events[2][1][1] , player.events[2][1][2] , player.events[2][1][3] } , false , true );
                else
                    formatBdayStamp = GRM.L ( "Unknown" );
                end
            end
        end
            
        if isUnknown then
            if date == "join" then
                player.joinDateUnknown = true;
            elseif date == "promo" then
                player.promoteDateUnknown = true
                if player.name == GRM_G.currentName then
                    GRM_G.rankDateSet = true;
                end
            end
        end

        if not isAudit or ( GRM_UI.GRM_MemberDetailMetaData:IsVisible() and GRM_G.currentName == playerName ) then
            if player.isOnline then
                if player.zone ~= nil then
                    GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailMetaZoneInfoZoneText:SetText ( player.zone );                                     -- Zone
                    GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailMetaZoneInfoTimeText2:SetText ( GRM.GetTimePassedInZone ( player.timeEnteredZone ) );              -- Time Passed
                end
                GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailMetaZoneInfoText:Show();
                GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailMetaZoneInfoZoneText:Show();
                GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailMetaZoneInfoTimeText1:Show();
                GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailMetaZoneInfoTimeText2:Show();
            end
        end
    end

    -- Determine which information needs to repopulate.
    if GRM_UI.GRM_MemberDetailMetaData:IsVisible() and name == GRM_G.currentName then

        -- Join Date
        if joinDateText == buttonText or editJoinText == buttonText then
            if isUnknown and date == "join" then
                GRM_UI.GRM_MemberDetailMetaData.GRM_JoinDateText:SetText( GRM.L ( "Unknown" ) );
                GRM_UI.GRM_MemberDetailMetaData.GRM_JoinDateText:Show();
                GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailJoinDateButton:Hide();
            else
                if buttonText == editJoinText then
                    GRM_UI.GRM_MemberDetailMetaData.GRM_JoinDateText:Show();
                else
                    GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailJoinDateButton:Show();
                end
            end
            
        -- Promo Date
        elseif buttonText == promoDateText then
            if not isUnknown then
                GRM_UI.GRM_MemberDetailMetaData.GRM_SetPromoDateButton:Show();
            elseif date == "promo" then
                GRM_UI.GRM_MemberDetailMetaData.GRM_SetPromoDateButton:Hide();
                GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailRankDateTxt:SetText ( GRM.L ( "Promoted:" ) .. " " .. GRM.L ( "Unknown" ) );
                GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailRankDateTxt:Show();
            end

            if name == GRM_G.currentName then
                if showJoinText then
                    GRM_UI.GRM_MemberDetailMetaData.GRM_JoinDateText:Show();
                else
                    GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailJoinDateButton:Show();
                end
            end
            
        -- promo Date - Edit
        elseif buttonText == editDateText then
            if isUnknown and date == "promo" then
                GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailRankDateTxt:SetText ( GRM.L ( "Promoted:" ) .. " " .. GRM.L ( "Unknown" ) );
            end
            GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailRankDateTxt:Show();
        end
        -- Birthday Logic
        if GRM.S().showBDay and not GRM_UI.GRM_MemberDetailMetaData.GRM_BirthdayText:IsVisible() and not GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailBirthdayButton:IsVisible() then
            if showBdayText then
                GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailBirthdayButton:Hide();
                GRM_UI.GRM_MemberDetailMetaData.GRM_BirthdayText:SetText ( formatBdayStamp );
                GRM_UI.GRM_MemberDetailMetaData.GRM_BirthdayText:Show();
            else
                GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailBirthdayButton:Show();
                GRM_UI.GRM_MemberDetailMetaData.GRM_BirthdayText:Hide();
            end
        end

        --RANK PROMO DATE
        if not GRM_G.rankDateSet then      --- Promotion has never been recorded!
            GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailRankDateTxt:Hide();
            GRM_UI.GRM_MemberDetailMetaData.GRM_SetPromoDateButton:Show();
        else
            GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailRankDateTxt:Show();
        end

        if not isAudit then
            GRM_UI.Unpause();
        end
    end

    if GRM.PlayerOrAltHasJD ( GRM_G.currentName ) then
        if GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailJoinDateButton:IsVisible() then
            GRM_UI.GRM_MemberDetailMetaData.GRM_SyncDateArrowButton:ClearAllPoints();
            GRM_UI.GRM_MemberDetailMetaData.GRM_SyncDateArrowButton:SetPoint ( "LEFT" , GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailJoinDateButton , "RIGHT" , 0 , 0 );
        elseif GRM_UI.GRM_MemberDetailMetaData.GRM_JoinDateText:IsVisible() then
            GRM_UI.GRM_MemberDetailMetaData.GRM_SyncDateArrowButton:ClearAllPoints();
            GRM_UI.GRM_MemberDetailMetaData.GRM_SyncDateArrowButton:SetPoint ( "LEFT" , GRM_UI.GRM_MemberDetailMetaData.GRM_JoinDateText , "RIGHT" , 8 , -0.5 );
        end
        GRM_UI.GRM_MemberDetailMetaData.GRM_SyncDateArrowButton:Show();
    else
        GRM_UI.GRM_MemberDetailMetaData.GRM_SyncDateArrowButton:Hide();
    end

    -- Close the rest
    GRM_UI.GRM_MemberDetailMetaData.GRM_MonthDropDownMenuSelected:Hide();
    GRM_UI.GRM_MemberDetailMetaData.GRM_YearDropDownMenuSelected:Hide();
    GRM_UI.GRM_MemberDetailMetaData.GRM_DayDropDownMenuSelected:Hide();
    GRM_UI.GRM_MemberDetailMetaData.GRM_DateSubmitButton:Hide();
    GRM_UI.GRM_MemberDetailMetaData.GRM_DateSubmitCancelButton:Hide();
end

-- Method:          GRM.SetDateButtonConfiguration ( int )
-- What it Does:    Formats the date submit configuration of buttons for clean submission
-- Purpose:         Only some date inputs need ALL, including the year. Birthday only needs day and month.
GRM.SetDateButtonConfiguration = function ( formatNum )
    if formatNum == 1 then
        if GRM_G.formatNumber ~= formatNum then
            GRM_G.formatNumber = formatNum;
            
            -- Formatting
            GRM_UI.GRM_MemberDetailMetaData.GRM_MonthDropDownMenuSelected:SetPoint ( "TOP" , GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailRankTxt , "BOTTOM" , -86.5 , -4 );
            GRM_UI.GRM_MemberDetailMetaData.GRM_DateSubmitButton:SetPoint ( "TOP" , GRM_UI.GRM_MemberDetailMetaData.GRM_MonthDropDownMenuSelected , "BOTTOM" , -22 , -3 );
            GRM_UI.GRM_MemberDetailMetaData.GRM_DateSubmitCancelButton:SetPoint ( "LEFT" , GRM_UI.GRM_MemberDetailMetaData.GRM_SetUnknownButton , "RIGHT" , 6 , 0 );

        end
        GRM_UI.GRM_MemberDetailMetaData.GRM_YearDropDownMenuSelected:Show();
        GRM_UI.GRM_MemberDetailMetaData.GRM_SetUnknownButton:Show();
    elseif formatNum == 2 then
        if GRM_G.formatNumber ~= formatNum then
            GRM_G.formatNumber = formatNum;

            -- Formatting
            GRM_UI.GRM_MemberDetailMetaData.GRM_MonthDropDownMenuSelected:SetPoint ( "TOP" , GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailRankTxt , "BOTTOM" , -20 , -4 );
            GRM_UI.GRM_MemberDetailMetaData.GRM_DateSubmitButton:SetPoint ( "TOP" , GRM_UI.GRM_MemberDetailMetaData.GRM_MonthDropDownMenuSelected , "BOTTOM" , -86.5 , -3 );
            GRM_UI.GRM_MemberDetailMetaData.GRM_DateSubmitCancelButton:SetPoint ( "LEFT" , GRM_UI.GRM_MemberDetailMetaData.GRM_SetUnknownButton , "RIGHT" , 3 , 0 );            

        end
        GRM_UI.GRM_MemberDetailMetaData.GRM_YearDropDownMenuSelected:Hide();
        GRM_UI.GRM_MemberDetailMetaData.GRM_SetUnknownButton:Show();
    end

    GRM_UI.GRM_MemberDetailMetaData.GRM_DayDropDownMenuSelected:Show();
    GRM_UI.GRM_MemberDetailMetaData.GRM_MonthDropDownMenuSelected:Show();
    GRM_UI.GRM_MemberDetailMetaData.GRM_DateSubmitButton:Show();
    GRM_UI.GRM_MemberDetailMetaData.GRM_DateSubmitCancelButton:Show();
end

-- Method:          GRM.GetRecordedDate ( string )
-- What it Does:    Returns either today's date, if no date of the corresponding date is stored, or, returns the date of the stored item
-- Purpose:         Continuity on editing dates and presenting dates.
GRM.GetRecordedDate = function( buttonName )
    local month , day , currentYear = select ( 2 , GRM.GetTodaysDate() );
    local player = GRM.GetPlayer ( GRM_G.currentName );
    
    if buttonName == "PromoRank" and not player.promoteDateUnknown and player.rankHist[1][7] then
        day = player.rankHist[1][2];
        month = player.rankHist[1][3];
        currentYear = player.rankHist[1][4];
    elseif buttonName == "JoinDate" and not player.joinDateUnknown and player.joinDateHist[1][1] > 0 then
        day = player.joinDateHist[1][1];
        month = player.joinDateHist[1][2];
        currentYear = player.joinDateHist[1][3];
    elseif buttonName == "Birthday" and not player.birthdayUnknown and player.events[2][1][1] ~= 0 then
        day = player.events[2][1][1];
        month = player.events[2][1][2];
    end

    return day , month , currentYear;
end

-- Method:          GRM.SetDateSelectFrame( string , frameObject, string )
-- What it Does:    On Clicking the "Set Join Date" button this logic presents itself
-- Purpose:         Handle the event to modify when a player joined the guild. This is useful for anniversary date tracking.
--                  It is also necessary because upon starting the addon, it is unknown a person's true join date. This allows the gleader to set a general join date.
GRM.SetDateSelectFrame = function ( buttonName )
    local day , month , currentYear = GRM.GetRecordedDate ( buttonName );
    local months = { "January" , "February" , "March" , "April" , "May" , "June" , "July" , "August" , "September" , "October" , "November" , "December" };
    local formatNumber = 0;

    -- Day
    GRM_UI.GRM_MemberDetailMetaData.GRM_DayDropDownMenuSelected.GRM_DayText:SetText ( day );
    GRM_G.dayIndex = day;

    -- Month
    GRM_UI.GRM_MemberDetailMetaData.GRM_MonthDropDownMenuSelected.GRM_MonthText:SetText ( GRM.L ( months [ month ] ) );
    GRM_G.monthIndex = month;
    
    -- Year
    GRM_UI.GRM_MemberDetailMetaData.GRM_YearDropDownMenuSelected.GRM_YearText:SetText ( currentYear );
    GRM_G.yearIndex = currentYear;
    
    -- Set function of the buttons to corresponding action.
    if buttonName == "PromoRank" then
        formatNumber = 1;

        GRM_UI.GRM_MemberDetailMetaData.GRM_DateSubmitButtonTxt:SetText ( GRM.L ( "Set Promo Date" ) );
        GRM_UI.GRM_MemberDetailMetaData.GRM_DateSubmitButton:SetScript("OnClick" , function( _ , button )
            if button == "LeftButton" and not GRM_UI.GRM_MemberDetailMetaData.GRM_MonthDropDownMenu:IsVisible() then
                GRM.SetPromoDate();
            end
        end);
    elseif buttonName == "JoinDate" then
        formatNumber = 1;
        GRM_UI.GRM_MemberDetailMetaData.GRM_DateSubmitButtonTxt:SetText ( GRM.L ( "Set Join Date" ) );
        GRM_UI.GRM_MemberDetailMetaData.GRM_DateSubmitButton:SetScript("OnClick" , function( _ , button )
            if button == "LeftButton" then
                GRM.SetJoinDate();
            end
        end);
    elseif buttonName == "Birthday" then
        formatNumber = 2;
        GRM_UI.GRM_MemberDetailMetaData.GRM_DateSubmitButtonTxt:SetText ( GRM.L ( "Set Birthday" ) );
        GRM_UI.GRM_MemberDetailMetaData.GRM_DateSubmitButton:SetScript("OnClick" , function( _ , button )
            if button == "LeftButton" then
                GRM.SetBirthdayFrameLogic();
            end
        end);
    end

    GRM.SetDateButtonConfiguration ( formatNumber );
end

-- Method:          GRM.IsGuildieAnOfficer ( string , int )
-- What it Does:    It returns true if the player is tagged as an officer in the guild. It does this by grabbing their current rank status, getting the flags of that rank permission, returning index 9
-- Purpose:         Useful to know if player is an officer.
GRM.IsGuildieAnOfficer = function ( name , rank )
    local id = rank or GRM.GetGuildMemberRankID ( name );

    -- If can edit both public and officer notes is where I set the standard
    return ( C_GuildInfo.GuildControlGetRankFlags ( id + 1 )[10] and C_GuildInfo.GuildControlGetRankFlags ( id + 1 )[12] ); -- It has to be + 1 as the indexing starts at 1, though the rank ID starts at 0;
end

-- Method:          GRM.GetPlayerRankPermissions ( string , int )
-- What it Does:    Returns the rank permission of the player/rank for promoting, demoting, or kicking
-- Purpose:         For the macro tool this is important ot know who to allow sync with. 
GRM.GetPlayerRankPermissions = function ( name , rank )
    local id = rank or GRM.GetGuildMemberRankID ( name );
    local permissions = C_GuildInfo.GuildControlGetRankFlags ( id + 1 );

    return permissions[5] , permissions[6] , permissions[8];    -- Promote , demote , kick
end

-- Method:          GRM.IsPlayerAnOfficer ()
-- What it Does:    Returns true if the player is an officer
-- Purpose:         The old API no longer applies and works right. Now, all officers have access to 
GRM.IsPlayerAnOfficer = function()
    return GRM.CanEditOfficerNote();
end

-- Method:          GRM.GetRankIndex ( string , 2Darray )
-- What it Does:    Returns the index of the guild rank...
-- Purpose:         Flow control of drop down menus.
GRM.GetRankIndex = function ( rankName , button )
    GRM.BuildRankList();
    local index = -1;
    
    if button == nil then
        for i = 1 , #GuildRanks do
            if GuildRanks[i] == rankName then
                index = i - 1;
                break;
            end
        end
    else
        local buttonName = button:GetName();
        if tonumber ( string.sub ( buttonName , #buttonName - 1 ) ) == nil then -- If nil then it is only 1 number
            index = tonumber ( string.sub ( buttonName , #buttonName ) ) - 1;
        else
            index = tonumber ( string.sub ( buttonName , #buttonName - 1 ) ) - 1;
        end
    end
    return index;
end

-- Method:          GRM.BuildRankList()
-- What it Does:    It builds into an array all of the dropdown buttons from the guild rank dropdown.
-- Purpose:         Needed to initialize dropdown logic...
GRM.BuildRankList = function()
    -- Let's put all of the buttons in an array, and let's set some rules.
    for i = 1 , GuildControlGetNumRanks() do
        GuildRanks[i] = GuildControlGetRankName( i );
    end
end

-- Method:          GRM.OnRankChange ( string , string , string , string )
-- What it Does:    Logic on Rank Drop down select in main frame
-- Purpose:         UI feature and UX
GRM.OnRankChange = function ( formerRank , newRank , promotedName , promoterName )
    -- Build Buttons Profile
    local recorded = false;
    local newRankIndex = GRM.GetRankIndex ( newRank , nil );
    local formerRankIndex = GRM.GetRankIndex ( formerRank , nil );

    if newRankIndex ~= formerRankIndex then
        -- Save the data!
        local timestamp , dates = GRM.GetTimestamp();
        local epochTime = time();
        local player = GRM.GetPlayer ( promotedName );

        if player then
            local formerRankName = player.rankName;                               -- For the reporting string!
            local standardDate = GRM.ConvertToStandardFormatDate ( dates[1] , dates[2] , dates[3] );

            if player.rankHist[1][6] == 0 then

                player.rankHist[1][1] = formerRankName;
                player.rankHist[1][2] = dates[1];
                player.rankHist[1][3] = dates[2];
                player.rankHist[1][4] = dates[3];
                player.rankHist[1][5] = standardDate;
                player.rankHist[1][6] = 0;
                player.rankHist[1][7] = false;
                player.rankHist[1][8] = 1;

            end

            player.rankName = newRank                                         -- rank name
            player.rankIndex = newRankIndex;                                           -- rank index!

            -- If player had it set to "unknown before"
            player.promoteDateUnknown = false;

            -- For SYNC
            player.rankHist[1][6] = time();
            player.rankHist[1][7] = true;

            -- For history
            table.insert ( player.rankHist , 1 , { player.rankName , dates[1] , dates[2] , dates[3] , standardDate , time() , true , 1 } );

            -- Let's update it on the fly!
            local simpleName = GRM.GetStringClassColorByName ( promotedName ) .. GRM.SlimName ( promotedName ) .. "|r";
            local playerSimpleName = GRM.GetStringClassColorByName ( promoterName ) .. GRM.SlimName ( promoterName ) .. "|r";
            local logReport , logReportWithTime = "" , "";
            local tempTimeStamp = select ( 2 , GRM.GetTimestamp() );

            -- Promotion Obtained
            if newRankIndex < formerRankIndex then

                logReportWithTime , logReport = GRM.GetPromotionLogString ( true , playerSimpleName , simpleName , formerRankName , newRank , tempTimeStamp );
                -- Cleans up reporting
                -- report the changes!
                if ( not GRM_UI.GRM_ToolCoreFrame:IsVisible() or ( GRM_UI.GRM_ToolCoreFrame:IsVisible() and not GRM.S().disableMacroToolLogSpam ) ) and GRM.S()["toChat"].promotion then
                    GRM.PrintLog ( { 1 , logReport } );
                end
                GRM.AddLog ( { 1 , logReportWithTime , true , playerSimpleName , simpleName , formerRankName , newRank , tempTimeStamp } );

                if player.name == GRM_G.addonUser then
                    GRM.AddonPlayerRankChange ( newRankIndex );
                end
                recorded = true;
            -- Demotion Obtained
            elseif newRankIndex > formerRankIndex then
                logReportWithTime , logReport = GRM.GetDemotionLogString  ( true , playerSimpleName , simpleName , formerRankName , newRank , tempTimeStamp );

                -- reporting the changes!
                if ( not GRM_UI.GRM_ToolCoreFrame:IsVisible() or ( GRM_UI.GRM_ToolCoreFrame:IsVisible() and not GRM.S().disableMacroToolLogSpam ) ) and GRM.S()["toChat"].demotion then
                    GRM.PrintLog ( { 2 , logReport } );                          
                end
                GRM.AddLog ( { 2 , logReportWithTime , true , playerSimpleName , simpleName , formerRankName , newRank , tempTimeStamp } );

                if player.name == GRM_G.addonUser then
                    GRM.AddonPlayerRankChange ( newRankIndex );
                end
                recorded = true;
            end
            if GRM_UI.GRM_MemberDetailMetaData:IsVisible() and promotedName == GRM_G.currentName then
                GRM.PopulateMemberDetails ( GRM_G.currentName );
            end
        end

        if GRM_G.BuildVersion >= 80000 and CommunitiesFrame ~= nil and CommunitiesFrame.GuildMemberDetailFrame:IsVisible() and promotedName == GRM_G.currentName then
            CommunitiesFrame.GuildMemberDetailFrame.RankDropdown.Text:SetText ( newRank );
        end

        -- Now, let's make the changes immediate for the button date.
        if GRM_UI.GRM_MemberDetailMetaData.GRM_SetPromoDateButton:IsVisible() then
            GRM_UI.GRM_MemberDetailMetaData.GRM_SetPromoDateButton:Hide();
            GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailRankDateTxt:SetText ( GRM.L ( "Promoted:" ) .. " " .. GRM.Trim ( string.sub ( timestamp , 1 , 10 ) ) );
            GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailRankDateTxt:Show();
        end

        -- Only want to refresh these things when NOT using the macro tool - the macro tool will do its own refresh.
        if promoterName ~= GRM_G.addonUser or ( promoterName == GRM_G.addonUser and GRM_UI.GRM_ToolCoreFrame ~= nil and not GRM_UI.GRM_ToolCoreFrame:IsVisible() ) then
            C_Timer.After ( 1 , function()
                GRM.RefreshSelectHybridFrames ( true , true , true , true );
            end);
        end

        if GRM_UI.GRM_RosterFrame and GRM_UI.GRM_RosterFrame:IsVisible() then
            GRM_R.RefreshRosterName();
        end

    end
    return recorded;
end

-- Method:          GRM.RemoveOldRosterButtonHighlights()
-- What it Does:    Removes the button highlight from the click action
-- Purpose:         Purely aesthetics.
GRM.RemoveOldRosterButtonHighlights = function ()
    local rosterB;
    for i = 1 , GRM_UI.ContainerButtonCount do
        rosterB = GetClickFrame ( GRM_UI.OldRosterButtonName .. i );
        if rosterB then
            rosterB:UnlockHighlight();
        end
    end

    if GRM_G.BuildVersion < 40000 then
        for i = 1 , GRM_UI.ContainerButtonCount do
            rosterB = _G[ "GuildFrameGuildStatusButton" .. i ];

            rosterB:UnlockHighlight();
        end
    end
end

-- Method:          GRM.PopulateOptionsRankDropDown ()
-- What it Does:    Adds all the guild ranks to the drop down menu
-- Purpose:         UI Feature
GRM.PopulateOptionsRankDropDown = function ()
    -- populating the frames!
    local buffer = 3;
    local height = 0;
    GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_SyncOptionsFrame.GRM_RosterSyncRankDropDownMenu.Buttons = GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_SyncOptionsFrame.GRM_RosterSyncRankDropDownMenu.Buttons or {};

    -- Resetting the buttons!
    for i = 1 , #GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_SyncOptionsFrame.GRM_RosterSyncRankDropDownMenu.Buttons do
        GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_SyncOptionsFrame.GRM_RosterSyncRankDropDownMenu.Buttons[i][1]:Hide();
    end
    
    local i = 1;
    for count = 1 , GuildControlGetNumRanks() do
        if not GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_SyncOptionsFrame.GRM_RosterSyncRankDropDownMenu.Buttons[i] then
            local tempButton = CreateFrame ( "Button" , "rankIndex" .. i , GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_SyncOptionsFrame.GRM_RosterSyncRankDropDownMenu );
            GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_SyncOptionsFrame.GRM_RosterSyncRankDropDownMenu.Buttons[i] = { tempButton , tempButton:CreateFontString ( nil , "OVERLAY" , "GameFontWhiteTiny" ) }
        end

        local RankButtons = GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_SyncOptionsFrame.GRM_RosterSyncRankDropDownMenu.Buttons[i][1];
        local RankButtonsText = GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_SyncOptionsFrame.GRM_RosterSyncRankDropDownMenu.Buttons[i][2];
        RankButtons:SetWidth ( 110 );
        RankButtons:SetHeight ( 11 );
        RankButtons:SetHighlightTexture ( "Interface\\Buttons\\UI-Panel-Button-Highlight" );
        RankButtonsText:SetText ( GuildControlGetRankName ( count ) );
        RankButtonsText:SetWidth ( 110 );
        RankButtonsText:SetWordWrap ( false );
        RankButtonsText:SetFont ( GRM_G.FontChoice , GRM_G.FontModifier + 12 );
        RankButtonsText:SetPoint ( "CENTER" , RankButtons );
        RankButtonsText:SetJustifyH ( "CENTER" );
        RankButtonsText:SetTextColor ( 0 , 0.8 , 1 , 1 );

        if i == 1 then
            RankButtons:SetPoint ( "TOP" , GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_SyncOptionsFrame.GRM_RosterSyncRankDropDownMenu , 0 , -7 );
            height = height + RankButtons:GetHeight();
        else
            RankButtons:SetPoint ( "TOP" , GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_SyncOptionsFrame.GRM_RosterSyncRankDropDownMenu.Buttons[i - 1][1] , "BOTTOM" , 0 , -buffer );
            height = height + RankButtons:GetHeight() + buffer;
        end

        RankButtons:SetScript ( "OnClick" , function( self , button ) 
            if button == "LeftButton" then
                GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_SyncOptionsFrame.GRM_RosterSyncRankDropDownMenu:Hide();
                GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_SyncOptionsFrame.GRM_RosterSyncRankDropDownSelected:Show();
                local selectedRank = GRM.GetRankIndex ( GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_SyncOptionsFrame.GRM_RosterSyncRankDropDownSelectedText:GetText() , self );
                local isRestricted , rankIndex = GRM.IsSyncRankGuildLeaderRestricted ( 2 );

                -- Now, are they different? If they are different, that is a problem!
                if not isRestricted or CanEditGuildInfo() or ( isRestricted and rankIndex == selectedRank ) then
                    GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_SyncOptionsFrame.GRM_RosterSyncRankDropDownSelectedText:SetText ( RankButtonsText:GetText() );
                    GRM.S().syncRank = selectedRank;

                    GRM.UpdateGuildInfoWithNewValue ( 2 , selectedRank );

                    -- ban list check
                    if GRM.S().syncRank < GRM.S().syncRankBanList then
                        GRM.Report ( GRM.L ( "Warning! Ban List rank threshold is below the overall sync rank. Changing from \"{name}\" to \"{name2}\"" , GuildControlGetRankName ( GRM.S().syncRankBanList + 1 ) ,  RankButtonsText:GetText() ) );

                        -- Saving the data
                        GRM.S().syncRankBanList = GRM.S().syncRank;
                        GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_SyncOptionsFrame.GRM_RosterBanListDropDownSelectedText:SetText ( RankButtonsText:GetText() );

                        GRM.UpdateGuildInfoWithNewValue ( 3 , GRM.S().syncRank );

                    end
                   
                    -- Retrigger active addon users... Very important to know permissions
                    if not GRM_UI.GRM_RosterChangeLogFrame.GRM_AddonUsersFrame:IsVisible() then
                        GRM.RegisterGuildAddonUsersRefresh();
                    end

                    --Let's re-initiate syncing!
                    if GRM.S().syncEnabled and not GRMsyncGlobals.currentlySyncing and GRM_G.HasAccessToGuildChat then
                        GRMsync.TriggerFullReset();
                        -- Now, let's add a brief delay, 3 seconds, to trigger sync again
                        C_Timer.After ( 3 , GRMsync.Initialize );
                    end
                    -- Determine if player has access to guild chat or is in restricted chat rank
                    GRM_G.HasAccessToOfficerChat = false;
                    GRM.RegisterGuildChatPermission();
                else
                    -- Report to player about Guild Leader restriction
                    GRM.ReportRankRestriction ( rankIndex );
                end                
            end
        end); 
        RankButtons:Show();
        i = i + 1;
    end
    GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_SyncOptionsFrame.GRM_RosterSyncRankDropDownMenu:SetHeight ( height + 15 );
end

-- Method:          GRM.PopulateBanListOptionsDropDown ()
-- What it Does:    Adds all the guild ranks to the drop down menu for ban changes
-- Purpose:         UI Feature in options - greater control to keep sync of ban list to officers only, whilst allowing great sync with all guildies.
GRM.PopulateBanListOptionsDropDown = function ()
    -- populating the frames!
    local buffer = 3;
    local height = 0;
    local color1 = { 1 , 0 , 0 };
    local color2 = { 0 , 0.8 , 1 };

    GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_SyncOptionsFrame.GRM_RosterBanListDropDownMenu.Buttons = GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_SyncOptionsFrame.GRM_RosterBanListDropDownMenu.Buttons or {};

    -- Resetting the buttons!
    for i = 1 , #GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_SyncOptionsFrame.GRM_RosterBanListDropDownMenu.Buttons do
        GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_SyncOptionsFrame.GRM_RosterBanListDropDownMenu.Buttons[i][1]:Hide();
    end
    
    local i = 1;
    for count = 1 , GuildControlGetNumRanks() do
        if not GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_SyncOptionsFrame.GRM_RosterBanListDropDownMenu.Buttons[i] then
            local tempButton = CreateFrame ( "Button" , "rankIndex" .. i , GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_SyncOptionsFrame.GRM_RosterBanListDropDownMenu );
            GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_SyncOptionsFrame.GRM_RosterBanListDropDownMenu.Buttons[i] = { tempButton , tempButton:CreateFontString ( nil , "OVERLAY" , "GameFontWhiteTiny" ) }
        end

        local RankButtons = GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_SyncOptionsFrame.GRM_RosterBanListDropDownMenu.Buttons[i][1];
        local RankButtonsText = GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_SyncOptionsFrame.GRM_RosterBanListDropDownMenu.Buttons[i][2];
        RankButtons:SetWidth ( 110 );
        RankButtons:SetHeight ( 11 );
        RankButtons:SetHighlightTexture ( "Interface\\Buttons\\UI-Panel-Button-Highlight" );
        RankButtonsText:SetText ( GuildControlGetRankName ( count ) );
        RankButtonsText:SetWidth ( 110 );
        RankButtonsText:SetWordWrap ( false );
        RankButtonsText:SetFont ( GRM_G.FontChoice , GRM_G.FontModifier + 12 );
        RankButtonsText:SetPoint ( "CENTER" , RankButtons );
        RankButtonsText:SetJustifyH ( "CENTER" );
        if i - 1 <= GRM.S().syncRank then
            RankButtonsText:SetTextColor ( color2[1] , color2[2] , color2[3] , 1 );
        else
            RankButtonsText:SetTextColor ( color1[1] , color1[2] , color1[3] , 1 );
        end

        if i == 1 then
            RankButtons:SetPoint ( "TOP" , GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_SyncOptionsFrame.GRM_RosterBanListDropDownMenu , 0 , -7 );
            height = height + RankButtons:GetHeight();
        else
            RankButtons:SetPoint ( "TOP" , GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_SyncOptionsFrame.GRM_RosterBanListDropDownMenu.Buttons[i - 1][1] , "BOTTOM" , 0 , -buffer );
            height = height + RankButtons:GetHeight() + buffer;
        end

        RankButtons:SetScript ( "OnClick" , function( self , button ) 
            if button == "LeftButton" then
                GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_SyncOptionsFrame.GRM_RosterBanListDropDownMenu:Hide();
                GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_SyncOptionsFrame.GRM_RosterBanListDropDownSelected:Show();
                local selectedRank = GRM.GetRankIndex ( GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_SyncOptionsFrame.GRM_RosterBanListDropDownSelectedText:GetText() , self );
                local isRestricted , rankIndex = GRM.IsSyncRankGuildLeaderRestricted ( 3 );

                -- Now, are they different? If they are different, that is a problem!
                if not isRestricted or CanEditGuildInfo() or ( isRestricted and rankIndex == selectedRank ) then

                    if GRM.S().syncRank < selectedRank then

                        GRM.S().syncRankBanList = GRM.S().syncRank;
                        GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_SyncOptionsFrame.GRM_RosterBanListDropDownSelectedText:SetText ( GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_SyncOptionsFrame.GRM_RosterSyncRankDropDownSelectedText:GetText() );
                        GRM.Report ( GRM.L ( "Warning! Unable to select a Ban List rank below \"{name}\"" , GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_SyncOptionsFrame.GRM_RosterSyncRankDropDownSelectedText:GetText() )  .. "\n" .. GRM.L ( "Setting to match core filter rank" ) );

                        GRM.UpdateGuildInfoWithNewValue ( 3 , GRM.S().syncRank );
                    else
                        GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_SyncOptionsFrame.GRM_RosterBanListDropDownSelectedText:SetText ( RankButtonsText:GetText() );
                        GRM.S().syncRankBanList = selectedRank;

                        GRM.UpdateGuildInfoWithNewValue ( 3 , selectedRank );
                    end

                    -- Re-trigger addon users permissions
                    if not GRM_UI.GRM_RosterChangeLogFrame.GRM_AddonUsersFrame:IsVisible() then
                        GRM.RegisterGuildAddonUsersRefresh();
                    end

                    --Let's re-initiate syncing!
                    if GRM.S().syncEnabled and GRM.S().syncBanList and not GRMsyncGlobals.currentlySyncing and GRM_G.HasAccessToGuildChat then
                        GRMsync.TriggerFullReset();
                        -- Now, let's add a brief delay, 3 seconds, to trigger sync again
                        C_Timer.After ( 3 , GRMsync.Initialize );
                    end
                else
                    -- Report to player about Guild Leader restriction
                    GRM.ReportRankRestriction ( rankIndex );
                end
            end
        end);
        RankButtons:Show();
        i = i + 1;
    end
    GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_SyncOptionsFrame.GRM_RosterBanListDropDownMenu:SetHeight ( height + 15 );
end

-- Method:          GRM.PopulateDefaultDropDownRankMenu()
-- What it Does:    Adds all the guild ranks to the drop down menu for custom default
-- Purpose:         UI Feature in options - greater control to keep custom note sync display on each character neat.
GRM.PopulateDefaultDropDownRankMenu = function ()
    -- populating the frames!
    local buffer = 3;
    local height = 0;
    local color2 = { 0 , 0.8 , 1 };
    GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_SyncOptionsFrame.GRM_DefaultCustomRankDropDownMenu.Buttons = GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_SyncOptionsFrame.GRM_DefaultCustomRankDropDownMenu.Buttons or {};

    -- Resetting the buttons!
    for i = 1 , #GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_SyncOptionsFrame.GRM_DefaultCustomRankDropDownMenu.Buttons do
        GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_SyncOptionsFrame.GRM_DefaultCustomRankDropDownMenu.Buttons[i][1]:Hide();
    end
    
    local i = 1;
    for count = 1 , GuildControlGetNumRanks() do
        if not GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_SyncOptionsFrame.GRM_DefaultCustomRankDropDownMenu.Buttons[i] then
            local tempButton = CreateFrame ( "Button" , "rankIndex" .. i , GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_SyncOptionsFrame.GRM_DefaultCustomRankDropDownMenu );
            GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_SyncOptionsFrame.GRM_DefaultCustomRankDropDownMenu.Buttons[i] = { tempButton , tempButton:CreateFontString ( nil , "OVERLAY" , "GameFontWhiteTiny" ) }
        end

        local RankButtons = GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_SyncOptionsFrame.GRM_DefaultCustomRankDropDownMenu.Buttons[i][1];
        local RankButtonsText = GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_SyncOptionsFrame.GRM_DefaultCustomRankDropDownMenu.Buttons[i][2];
        RankButtons:SetWidth ( 110 );
        RankButtons:SetHeight ( 11 );
        RankButtons:SetHighlightTexture ( "Interface\\Buttons\\UI-Panel-Button-Highlight" );
        RankButtonsText:SetText ( GuildControlGetRankName ( count ) );
        RankButtonsText:SetWidth ( 110 );
        RankButtonsText:SetWordWrap ( false );
        RankButtonsText:SetFont ( GRM_G.FontChoice , GRM_G.FontModifier + 12 );
        RankButtonsText:SetPoint ( "CENTER" , RankButtons );
        RankButtonsText:SetJustifyH ( "CENTER" );
        RankButtonsText:SetTextColor ( color2[1] , color2[2] , color2[3] , 1 );

        if i == 1 then
            RankButtons:SetPoint ( "TOP" , GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_SyncOptionsFrame.GRM_DefaultCustomRankDropDownMenu , 0 , -7 );
            height = height + RankButtons:GetHeight();
        else
            RankButtons:SetPoint ( "TOP" , GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_SyncOptionsFrame.GRM_DefaultCustomRankDropDownMenu.Buttons[i - 1][1] , "BOTTOM" , 0 , -buffer );
            height = height + RankButtons:GetHeight() + buffer;
        end

        RankButtons:SetScript ( "OnClick" , function( self , button ) 
            if button == "LeftButton" then
                GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_SyncOptionsFrame.GRM_DefaultCustomRankDropDownMenu:Hide();
                GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_SyncOptionsFrame.GRM_DefaultCustomSelected:Show();
                local selectedRank = GRM.GetRankIndex ( GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_SyncOptionsFrame.GRM_DefaultCustomSelectedText:GetText() , self );
                local isRestricted , rankIndex = GRM.IsSyncRankGuildLeaderRestricted ( 4 );

                -- Now, are they different? If they are different, that is a problem!
                if not isRestricted or CanEditGuildInfo() or ( isRestricted and rankIndex == selectedRank ) then

                    GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_SyncOptionsFrame.GRM_DefaultCustomSelectedText:SetText ( RankButtonsText:GetText() );
                    GRM.S().syncRankCustom = selectedRank;
                    GRM.UpdateGuildInfoWithNewValue ( 4 , selectedRank );
                    GRM.ResetAllUnmodifiedDefaulCustomNoteFilters();

                else
                    -- Report to player about Guild Leader restriction
                    GRM.ReportRankRestriction ( rankIndex );
                end
            end
        end);
        RankButtons:Show();
        i = i + 1;
    end
    GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_SyncOptionsFrame.GRM_DefaultCustomRankDropDownMenu:SetHeight ( height + 15 );
end

-- Method:          GRM.ResetAllUnmodifiedDefaulCustomNoteFilters()
-- What it Does:    Checks if the filter has ever been modified, and if it hasn't, then resets it to the default
-- Purpose:         Quality of life controls over the filters!
GRM.ResetAllUnmodifiedDefaulCustomNoteFilters = function ()
    for _ , player in pairs ( GRM.GetGuild() ) do
        if type ( player ) == "table" then
            if not player.customNote[5] then
                player.customNote[4] = GRM.S().syncRankCustom;
            end
        end
    end
end

-- Method:          GRM.CreateRankDropDownMenu ( frame , fontstring , frame , int , int , function() )
-- What it Does:    It creates a dropdown menu that has all of the current guild ranks, with highest rank in guild on top
-- Purpose:         To create a generic, reusable dropdown menu for rank creation
GRM.CreateRankDropDownMenu = function ( SelectedFrame , Menu , fontSize , buttonHeight , logic )
    -- populating the frames!
    local buffer = 3;
    local height = 0;
    Menu.Buttons = Menu.Buttons or {};

    -- Resetting the buttons!
    for i = 1 , #Menu.Buttons do
        Menu.Buttons[i][1]:Hide();
    end
    
    local i = 1;
    for count = 1 , GuildControlGetNumRanks() do
        if not Menu.Buttons[i] then
            local tempButton = CreateFrame ( "Button" , Menu:GetName() .. "RankIndex_" .. i , Menu );
            Menu.Buttons[i] = { tempButton , tempButton:CreateFontString ( nil , "OVERLAY" , "GameFontWhiteTiny" ) }
        end

        local RankButtons = Menu.Buttons[i][1];
        local RankButtonsText = Menu.Buttons[i][2];
        RankButtons:SetWidth ( SelectedFrame:GetWidth() - 20 );
        RankButtons:SetHeight ( buttonHeight );
        RankButtons:SetHighlightTexture ( "Interface\\Buttons\\UI-Panel-Button-Highlight" );
        RankButtonsText:SetText ( GuildControlGetRankName ( count ) );
        RankButtonsText:SetWidth ( SelectedFrame:GetWidth() - 20 );
        RankButtonsText:SetWordWrap ( false );
        RankButtonsText:SetFont ( GRM_G.FontChoice , GRM_G.FontModifier + fontSize );
        RankButtonsText:SetPoint ( "CENTER" , RankButtons );
        RankButtonsText:SetJustifyH ( "CENTER" );

        if i == 1 then
            RankButtons:SetPoint ( "TOP" , Menu , 0 , -7 );
            height = height + RankButtons:GetHeight();
        else
            RankButtons:SetPoint ( "TOP" , Menu.Buttons[i - 1][1] , "BOTTOM" , 0 , -buffer );
            height = height + RankButtons:GetHeight() + buffer;
        end

        RankButtons:SetScript ( "OnClick" , function( self , button ) 
            if button == "LeftButton" then
                logic( self , RankButtonsText );
            end
        end);
        RankButtons:Show();
        i = i + 1;
    end
    Menu:SetHeight ( height + 15 );
end

-- Method:          GRM.CreateDropDownMenu ( frame , fontstring , frame , int , string  int ,  array , function() )
-- What it Does:    It creates a dropdown menu given the specific variables
-- Purpose:         To create a generic, reusable dropdown menus
GRM.CreateDropDownMenu = function ( SelectedFrame , Menu , fontSize , buttonHeight , fontModifier , textList , logic )
    -- populating the frames!
    local buffer = 3;
    local height = 0;
    Menu.Buttons = Menu.Buttons or {};

    -- Resetting the buttons!
    for i = 1 , #Menu.Buttons do
        Menu.Buttons[i][1]:Hide();
    end
    
    for i = 1 , #textList do
        if not Menu.Buttons[i] then
            local tempButton = CreateFrame ( "Button" , Menu:GetName() .. "_" .. i , Menu );
            Menu.Buttons[i] = { tempButton , tempButton:CreateFontString ( nil , "OVERLAY" , "GameFontWhiteTiny" ) }
        end

        local RankButtons = Menu.Buttons[i][1];
        local RankButtonsText = Menu.Buttons[i][2];
        RankButtons:SetWidth ( SelectedFrame:GetWidth() - 5 );
        RankButtons:SetHeight ( buttonHeight );
        RankButtons:SetHighlightTexture ( "Interface\\Buttons\\UI-Panel-Button-Highlight" );
        RankButtonsText:SetText ( textList[i] );
        RankButtonsText:SetWidth ( SelectedFrame:GetWidth() - 20 );
        RankButtonsText:SetWordWrap ( false );
        RankButtonsText:SetFont ( GRM_G.FontChoice , GRM_G.FontModifier + fontSize , fontModifier );
        RankButtonsText:SetPoint ( "CENTER" , RankButtons );
        RankButtonsText:SetJustifyH ( "CENTER" );

        if i == 1 then
            RankButtons:SetPoint ( "TOP" , Menu , 0 , -7 );
            height = height + RankButtons:GetHeight();
        else
            RankButtons:SetPoint ( "TOP" , Menu.Buttons[i - 1][1] , "BOTTOM" , 0 , -buffer );
            height = height + RankButtons:GetHeight() + buffer;
        end

        RankButtons:SetScript ( "OnClick" , function( self , button ) 
            if button == "LeftButton" then
                logic( self , i , RankButtonsText );
            end
        end);
        RankButtons:Show();
    end
    Menu:SetHeight ( height + 15 );
end

-- Method:          GRM.PopulateClassDropDownMenu ()
-- What it Does:    Adds all the player CLASSES to the drop down menu
-- Purpose:         This is useful for player selection of the class when manually adding a player's info to the metadata, like adding someone to a ban list.
GRM.PopulateClassDropDownMenu = function()
    -- populating the frames!
    local buffer = 3;
    local height = 0;
    GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_AddBanFrame.GRM_AddBanDropDownMenu.Buttons = GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_AddBanFrame.GRM_AddBanDropDownMenu.Buttons or {};

    -- Resetting the buttons!
    for i = 1 , #GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_AddBanFrame.GRM_AddBanDropDownMenu.Buttons do
        GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_AddBanFrame.GRM_AddBanDropDownMenu.Buttons[i][1]:Hide();
    end
    
    local j = 1;


    for i = 1 , #AllClasses do

        if ( AllClasses[i] ~= "Deathknight" and AllClasses[i] ~= "Monk" and AllClasses[i] ~= "Demonhunter" and AllClasses[i] ~= "Evoker" ) or ( ( AllClasses[i] == "Deathknight" and GRM_G.BuildVersion >= 30000 ) or ( AllClasses[i] == "Monk" and GRM_G.BuildVersion >= 50000 ) or ( AllClasses[i] == "Demonhunter" and GRM_G.BuildVersion >= 70000 ) or ( AllClasses[i] == "Evoker" and GRM_G.BuildVersion >= 100000 ) ) then

            local class = string.upper ( AllClasses[i] );
            local classColor = RAID_CLASS_COLORS[ class ];

            if classColor then
            
                local className = GRM.GetClassName ( class );
                
                if not GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_AddBanFrame.GRM_AddBanDropDownMenu.Buttons[i] then
                    local tempButton = CreateFrame ( "Button" , "ClassButton" .. j , GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_AddBanFrame.GRM_AddBanDropDownMenu );
                    GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_AddBanFrame.GRM_AddBanDropDownMenu.Buttons[j] = { tempButton , tempButton:CreateFontString ( nil , "OVERLAY" , "GameFontWhiteTiny" ) }
                    if j == 1 then
                        GRM_G.DropDownHighlightLockIndex = 1;
                        GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_AddBanFrame.GRM_AddBanDropDownMenu.Buttons[j][1]:LockHighlight();
                    end
                end

                local ClassButtons = GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_AddBanFrame.GRM_AddBanDropDownMenu.Buttons[j][1];
                local ClassButtonsText = GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_AddBanFrame.GRM_AddBanDropDownMenu.Buttons[j][2];
                

                ClassButtons:SetWidth ( 110 );
                ClassButtons:SetHeight ( 11 );
                ClassButtons:SetHighlightTexture ( "Interface\\Buttons\\UI-Panel-Button-Highlight" );
                ClassButtonsText:SetText ( className );
                ClassButtonsText:SetTextColor ( classColor.r , classColor.g , classColor.b , 1 );
                ClassButtonsText:SetWidth ( 110 );
                ClassButtonsText:SetWordWrap ( false );
                ClassButtonsText:SetFont ( GRM_G.FontChoice , GRM_G.FontModifier + 10 );
                ClassButtonsText:SetPoint ( "CENTER" , ClassButtons );
                ClassButtonsText:SetJustifyH ( "CENTER" );

                if j == 1 then
                    ClassButtons:SetPoint ( "TOP" , GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_AddBanFrame.GRM_AddBanDropDownMenu , 0 , -7 );
                    height = height + ClassButtons:GetHeight();
                else
                    ClassButtons:SetPoint ( "TOP" , GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_AddBanFrame.GRM_AddBanDropDownMenu.Buttons[j - 1][1] , "BOTTOM" , 0 , -buffer );
                    height = height + ClassButtons:GetHeight() + buffer;
                end

                ClassButtons:SetScript ( "OnClick" , function( self , button ) 
                    if button == "LeftButton" then
                        GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_AddBanFrame.GRM_AddBanDropDownClassSelectedText:SetText ( ClassButtonsText:GetText() );
                        GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_AddBanFrame.GRM_AddBanDropDownClassSelectedText:SetTextColor ( classColor.r , classColor.g , classColor.b , 1 );
                        GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_AddBanFrame.GRM_AddBanDropDownMenu:Hide();
                        GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_AddBanFrame.GRM_AddBanDropDownClassSelected:Show();
                        GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_AddBanFrame.GRM_AddBanReasonEditBox:SetFocus();
                        GRM_G.tempAddBanClass = class;
                    end
                end);
                ClassButtons:Show();
                j = j + 1;
            end
        end
    end
    GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_AddBanFrame.GRM_AddBanDropDownMenu:SetHeight ( height + 15 );
end

-- Method:          GRM.PopulateMainTagDropdown()
-- What it Does:    Creates a dropdown menu including options to choose from for main tag formatting in guild chat
-- Purpose:         Options, options, options! Customization to make it pleasing for all players in the formatting.
GRM.PopulateMainTagDropdown = function()
    local buffer = 3;
    local height = 0;
    local tagChoices = GRM.GetMainTags ( true );
    -- Initiate the buttons holder
    GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_MainTagFormatMenu.Buttons = GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_MainTagFormatMenu.Buttons or {};

    for i = 1 , #GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_MainTagFormatMenu.Buttons do
        GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_MainTagFormatMenu.Buttons[i][1]:Hide();
    end

    for i = 1 , #tagChoices do
        if not GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_MainTagFormatMenu.Buttons[i] then
            local tempButton = CreateFrame ( "Button" , "MainTagOption" .. i , GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_MainTagFormatMenu );
            GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_MainTagFormatMenu.Buttons[i] = { tempButton , tempButton:CreateFontString ( nil , "OVERLAY" , "GameFontWhiteTiny" ) }
        end

        local TagButton = GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_MainTagFormatMenu.Buttons[i][1];
        local TagButtonText = GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_MainTagFormatMenu.Buttons[i][2];
        TagButton:SetWidth ( 85 );
        TagButton:SetHeight ( 11 );
        TagButton:SetHighlightTexture ( "Interface\\Buttons\\UI-Panel-Button-Highlight" );
        if i == 7 then
            TagButtonText:SetText ( GRM.L ( "No Tag" ) );
        else
            TagButtonText:SetText ( tagChoices[i] );
        end
        TagButtonText:SetTextColor ( GRM.S().mainTagColor.r , GRM.S().mainTagColor.g , GRM.S().mainTagColor.b , 1 );
        TagButtonText:SetWidth ( 85 );
        TagButtonText:SetWordWrap ( false );
        TagButtonText:SetFont ( GRM_G.FontChoice , GRM_G.FontModifier + 10 );
        TagButtonText:SetPoint ( "CENTER" , TagButton );
        TagButtonText:SetJustifyH ( "CENTER" );

        if i == 1 then
            TagButton:SetPoint ( "TOP" , GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_MainTagFormatMenu , 0 , -7 );
            height = height + TagButton:GetHeight();
        else
            TagButton:SetPoint ( "TOP" , GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_MainTagFormatMenu.Buttons[i - 1][1] , "BOTTOM" , 0 , -buffer );
            height = height + TagButton:GetHeight() + buffer;
        end

        TagButton:SetScript ( "OnClick" , function( self , button ) 
            if button == "LeftButton" then
                local parsedNumber = tonumber ( string.match ( self:GetName() , "(%d+)" ) );

                GRM.S().mainTagIndex = parsedNumber;
                GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_MainTagFormatSelected.GRM_TagText:SetText ( TagButtonText:GetText() );
                GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_MainTagFormatSelected.GRM_TagText:SetTextColor ( GRM.S().mainTagColor.r , GRM.S().mainTagColor.g , GRM.S().mainTagColor.b , 1 );
                GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_MainTagFormatMenu:Hide();
                GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_MainTagFormatSelected:Show();

                GRM_G.mainTag = GRM.GetCurrentMainTag();
                GRM_G.altTag = GRM.GetCurrentAltTag();
            end
        end);
        TagButton:Show();
    end
    GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_MainTagFormatMenu:SetHeight ( height + 15 );
end

-- Method:          GRM.PopulateDefaultTabDropdown()
-- What it Does:    Creates a dropdown menu including options to choose from the GRM tabs as to which is default
-- Purpose:         Quality of Life preference control option
GRM.PopulateDefaultTabDropdown = function()
    local buffer = 3;
    local height = 0;
    local tabChoices = { GRM.L ( "LOG" ) , GRM.L ( "EVENTS" ) , GRM.L ( "BAN LIST" ) , GRM.L ( "SYNC USERS" ) , string.upper ( GRM.L ( "Options" ) ) , GRM.L ( "AUDIT" ) };

    -- Initiate the buttons holder
    GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_DefaultTabMenu.Buttons = GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_DefaultTabMenu.Buttons or {};

    for i = 1 , #GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_DefaultTabMenu.Buttons do
        GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_DefaultTabMenu.Buttons[i][1]:Hide();
    end

    for i = 1 , #tabChoices do
        if not GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_DefaultTabMenu.Buttons[i] then
            local tempButton = CreateFrame ( "Button" , "DefaultTabButton" .. i , GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_DefaultTabMenu );
            GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_DefaultTabMenu.Buttons[i] = { tempButton , tempButton:CreateFontString ( nil , "OVERLAY" , "GameFontWhiteTiny" ) }
        end

        local TabButton = GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_DefaultTabMenu.Buttons[i][1];
        local TabButtonText = GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_DefaultTabMenu.Buttons[i][2];
        TabButton:SetWidth ( 105 );
        TabButton:SetHeight ( 11 );
        TabButton:SetHighlightTexture ( "Interface\\Buttons\\UI-Panel-Button-Highlight" );
        TabButtonText:SetText ( tabChoices[i] );
        TabButtonText:SetWidth ( 105 );
        TabButtonText:SetWordWrap ( false );
        TabButtonText:SetFont ( GRM_G.FontChoice , GRM_G.FontModifier + 9.5 );
        TabButtonText:SetPoint ( "CENTER" , TabButton );
        TabButtonText:SetJustifyH ( "CENTER" );

        if i == 1 then
            TabButton:SetPoint ( "TOP" , GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_DefaultTabMenu , 0 , -7 );
            height = height + TabButton:GetHeight();
        else
            TabButton:SetPoint ( "TOP" , GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_DefaultTabMenu.Buttons[i - 1][1] , "BOTTOM" , 0 , -buffer );
            height = height + TabButton:GetHeight() + buffer;
        end

        TabButton:SetScript ( "OnClick" , function( self , button ) 
            if button == "LeftButton" then
                GRM.S().defaultTabSelection[2] = tonumber ( string.match ( self:GetName() , "%d+" ) );
                GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_DefaultTabSelected.GRM_DefaultTabSelectedText:SetText ( TabButtonText:GetText() );
                GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_DefaultTabMenu:Hide();
                GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_DefaultTabSelected:Show();
            end
        end);
        TabButton:Show();
    end
    GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_DefaultTabMenu:SetHeight ( height + 15 );
end

-- Method:          GRM.PopulateLanguageDropdown()
-- What it Does:    Populates a dropdown select menu with all of the available languages to choose from...
-- Purpose:         To give the player the option to manually select and change which language the addon is using.
GRM.PopulateLanguageDropdown = function()
    local buffer = 3;
    local height = 0;
    GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_LanguageDropDownMenu.Buttons = GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_LanguageDropDownMenu.Buttons or {};

    for i = 1 , #GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_LanguageDropDownMenu.Buttons do
        GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_LanguageDropDownMenu.Buttons[i][1]:Hide();
    end

    for i = 1 , #GRML.Languages do
        if not GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_LanguageDropDownMenu.Buttons[i] then
            local tempButton = CreateFrame ( "Button" , "GRM_Language_" .. i , GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_LanguageDropDownMenu );
            GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_LanguageDropDownMenu.Buttons[i] = { tempButton , tempButton:CreateFontString ( nil , "OVERLAY" , "GameFontWhiteTiny" ) }
        end

        local LangButton = GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_LanguageDropDownMenu.Buttons[i][1];
        local LangButtonText = GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_LanguageDropDownMenu.Buttons[i][2];
        LangButton:SetWidth ( 110 );
        LangButton:SetHeight ( 11 );
        LangButton:SetHighlightTexture ( "Interface\\Buttons\\UI-Panel-Button-Highlight" );
        LangButtonText:SetText ( GRM.L ( GRML.Languages[i] ) );
        LangButtonText:SetWidth ( 105 );
        LangButtonText:SetWordWrap ( false );
        LangButtonText:SetFont ( GRM_G.FontChoice , GRM_G.FontModifier + 10 );
        LangButtonText:SetPoint ( "CENTER" , LangButton );
        LangButtonText:SetJustifyH ( "CENTER" );

        if i == 1 then
            LangButton:SetPoint ( "TOP" , GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_LanguageDropDownMenu , 0 , -7 );
            height = height + LangButton:GetHeight();
        else
            LangButton:SetPoint ( "TOP" , GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_LanguageDropDownMenu.Buttons[i - 1][1] , "BOTTOM" , 0 , -buffer );
            height = height + LangButton:GetHeight() + buffer;
        end

        LangButton:SetScript ( "OnClick" , function( self , button ) 
            if button == "LeftButton" then
                local parsedNumber = tonumber ( string.match ( self:GetName() , "(%d+)" ) );
                GRM.S().selectedLang = parsedNumber;
                GRM_G.LocalizedIndex = parsedNumber;
                GRM.S().selectedFont = GRML.GetFontChoiceIndex ( parsedNumber );
                GRML.SetNewLanguage( GRM.S().selectedLang , false , false );

                local HourFormat = { GRM.L ( "24 Hour" ) , GRM.L ( "12 Hour (am/pm)" ) };
                local tabChoices = { GRM.L ( "LOG" ) , GRM.L ( "EVENTS" ) , GRM.L ( "BAN LIST" ) , GRM.L ( "SYNC USERS" ) , string.upper ( GRM.L ( "Options" ) ) , GRM.L ( "AUDIT" ) };

                GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_LanguageSelected.GRM_LanguageSelectedText:SetText ( GRM.L ( GRML.Languages[parsedNumber] ) );
                GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_FontSelected.GRM_FontSelectedText:SetText ( GRML.FontNames[GRM.S().selectedFont] );
                GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_FontSelected.GRM_FontSelectedText:SetFont ( GRML.listOfFonts[GRM.S().selectedFont] , GRM_G.FontModifier + 11 );
                local month , day , year = select ( 2 , GRM.GetTodaysDate() );
                GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_NonGlobalTimestampSelected.GRM_NonGlobalTimestampSelectedText:SetText( GRM.FormatTimeStamp ( { day , month , year } , false , false , GRM.S().dateFormat ) );
                GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_DefaultTabSelected.GRM_DefaultTabSelectedText:SetText ( tabChoices[GRM.S().defaultTabSelection[2]] );
                if GRM.S().twentyFourHrScale then
                    GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_24HrSelected.GRM_24HrSelectedText:SetText ( HourFormat[1] );
                else
                    GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_24HrSelected.GRM_24HrSelectedText:SetText ( HourFormat[2] );
                end

                -- Macro Tool open
                if GRM_UI.GRM_ToolCoreFrame.GRM_ToolCustomRulesFrame:IsVisible() then
                    local matchString = GRM.L ( "Click to Set" );
                    if GRM_UI.GRM_ToolCoreFrame.GRM_ToolCustomRulesFrame.rule.customLog and #GRM_UI.GRM_ToolCoreFrame.GRM_ToolCustomRulesFrame.rule.customLogMsg > 0  then
                        matchString = GRM_UI.GRM_ToolCoreFrame.GRM_ToolCustomRulesFrame.rule.customLogMsg;
                    end 
                    GRM_UI.GRM_ToolCoreFrame.GRM_ToolCustomRulesFrame.GRM_CustomLogMessageEditBox:SetText ( matchString );
                    GRM_UI.GRM_ToolCoreFrame.GRM_ToolCustomRulesFrame.GRM_CustomLogMessageEditBox.stringPattern = matchString;

                    if GRM_UI.GRM_ToolCoreFrame.GRM_ToolCustomRulesFrame.rule.isMonths then
                        GRM_UI.GRM_ToolCoreFrame.GRM_ToolCustomRulesFrame.GRM_TimeScaleSelected.GRM_TimeScaleSelectedText:SetText ( GRM.L ( "Months") );
                    else
                        GRM_UI.GRM_ToolCoreFrame.GRM_ToolCustomRulesFrame.GRM_TimeScaleSelected.GRM_TimeScaleSelectedText:SetText ( GRM.L ( "Days") );
                    end
                    if GRM_UI.GRM_ToolCoreFrame.GRM_ToolCustomRulesFrame.rule.rankSpecialIsMonths then
                        GRM_UI.GRM_ToolCoreFrame.GRM_ToolCustomRulesFrame.GRM_KickEvenIfActiveTimeSelected.GRM_KickEvenIfActiveTimeSelectedText:SetText ( GRM.L ( "Months") );
                    else
                        GRM_UI.GRM_ToolCoreFrame.GRM_ToolCustomRulesFrame.GRM_KickEvenIfActiveTimeSelected.GRM_KickEvenIfActiveTimeSelectedText:SetText ( GRM.L ( "Days") );
                    end
                    if GRM_UI.GRM_ToolCoreFrame.GRM_ToolCustomRulesFrame.rule.repFilter then
                        GRM_UI.GRM_ToolCoreFrame.GRM_ToolCustomRulesFrame.GRM_GuildRepRanksSelected.GRM_GuildRepRanksSelectedText:SetText ( GRM.GetReputationTextLevel ( GRM_UI.GRM_ToolCoreFrame.GRM_ToolCustomRulesFrame.rule.rep , true ) );
                    else
                        GRM_UI.GRM_ToolCoreFrame.GRM_ToolCustomRulesFrame.GRM_GuildRepRanksSelected.GRM_GuildRepRanksSelectedText:SetText ( GRM.GetReputationTextLevel ( GRM_UI.GRM_ToolCoreFrame.GRM_ToolCustomRulesFrame.rule.rep , false ) );
                    end
                    if GRM_UI.GRM_ToolCoreFrame.GRM_ToolCustomRulesFrame.rule.noteMatch then
                        if GRM_UI.GRM_ToolCoreFrame.GRM_ToolCustomRulesFrame.rule.matchingString == "" then
                            matchString = GRM.L ( "Click to Set" );
                        else
                            matchString = GRM_UI.GRM_ToolCoreFrame.GRM_ToolCustomRulesFrame.rule.matchingString;
                        end
        
                        GRM_UI.GRM_ToolCoreFrame.GRM_ToolCustomRulesFrame.GRM_NoteSearchEditBox:SetText ( matchString );
                        GRM_UI.GRM_ToolCoreFrame.GRM_ToolCustomRulesFrame.GRM_NoteSearchEditBox.stringPattern = matchString;
                    end
                end

                GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_LanguageDropDownMenu:Hide();
                GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_LanguageSelected:Show();
                GRM_UI.ElvUIReset = true;
                GRM_UI.ElvUIReset2 = true;
                -- Check the language count!
                local count = GRML.GetNumberUntranslatedLines ( GRM.S().selectedLang );
                if GRM_G.Region == "enUS" then
                    count = count - 10;
                end
                if count > 0 and not GRML.TranslationStatusEnum[ GRML.Languages [ GRM.S().selectedLang ] ] then
                    GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_LanguageCountText:SetText ( GRM.L ( "{num} phrases still need translation to {name}" , GRM.L ( GRML.Languages[GRM.S().selectedLang] ) , nil , count ) );
                    GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_LanguageCountText:Show();
                else
                    GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_LanguageCountText:Hide();
                end

                if IsAddOnLoaded ( "AddOnSkins" ) then
                    GRM_UI.GRM_RosterChangeLogFrame:Hide();
                    GRM_UI.GRM_RosterChangeLogFrame:Show();
                    if GRM_UI.GRM_MemberDetailMetaData:IsVisible() then
                        GRM_UI.GRM_MemberDetailMetaData:Hide();
                        GRM_G.pause = true;
                        GRM_UI.GRM_MemberDetailMetaData:Show();
                    end
                end

                if parsedNumber == GRM_G.LocalizedIndex then
                    GRM.Report ( GRM.L ( "Font has been Reset to DEFAULT." ) );
                end
                GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_ScanningOptionsFrame.GRM_LevelRange:SetText ( GRM.GetLevelRange() );

                -- Let's reprocess the language!
                GRM.ReprocessAllLogEntriesToCurrentLanguage();

                if #GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_RosterChangeLogScrollChildFrame.AllButtons > 0 then
                    GRM.ResetLogStringPoints ( GRM.S().showLineNumbers );
                end
            end
        end);
        LangButton:Show();
    end
    GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_LanguageDropDownMenu:SetHeight ( height + 15 );
end

-- Method:          GRM.PopulateFontDropdown()
-- What it Does:    Builds the font dropdown box
-- Purpose:         Give the user more customizability over the addon.
GRM.PopulateFontDropdown = function()
    local buffer = 3;
    local height = 0;
    GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_FontDropDownMenu.Buttons = GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_FontDropDownMenu.Buttons or {};

    for i = 1 , #GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_FontDropDownMenu.Buttons do
        GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_FontDropDownMenu.Buttons[i][1]:Hide();
    end

    for i = 1 , #GRML.FontNames do
        if not GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_FontDropDownMenu.Buttons[i] then
            local tempButton = CreateFrame ( "Button" , "GRM_Font" .. i , GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_FontDropDownMenu );
            GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_FontDropDownMenu.Buttons[i] = { tempButton , tempButton:CreateFontString ( nil , "OVERLAY" , "GameFontWhiteTiny" ) }
        end

        local FontButton = GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_FontDropDownMenu.Buttons[i][1];
        local FontButtonText = GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_FontDropDownMenu.Buttons[i][2];
        local additionalModifier = 0;
        if i == 4 then                             -- China
            additionalModifier = 0.5;
        elseif i == 5 then                         -- Taiwan
            additionalModifier = 2;
        elseif i == 6 then                         -- Action Man
            additionalModifier = 1;
        elseif i == 7 then                         -- Ancient
            additionalModifier = 2;
        elseif i == 9 then                         -- Cardinal
            additionalModifier = 2;
        elseif i == 10 then                        -- Continuum
            additionalModifier = 1;
        elseif i == 11 then                        -- Espressway
            additionalModifier = 1;
        elseif i == 13 then                        -- PT Sans
            additionalModifier = 2;
        elseif i == 14 then                        -- Roboto
            additionalModifier = 1;
        end
        FontButton:SetWidth ( 110 );
        FontButton:SetHeight ( 11 );
        FontButton:SetHighlightTexture ( "Interface\\Buttons\\UI-Panel-Button-Highlight" );
        FontButtonText:SetText ( GRML.FontNames[i] );
        FontButtonText:SetWidth ( 105 );
        FontButtonText:SetWordWrap ( false );
        FontButtonText:SetFont ( GRML.listOfFonts[i] , GRM_G.FontModifier + additionalModifier + 10 );
        FontButtonText:SetPoint ( "CENTER" , FontButton );
        FontButtonText:SetJustifyH ( "CENTER" );

        if i == 1 then
            FontButton:SetPoint ( "TOP" , GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_FontDropDownMenu , 0 , -7 );
            height = height + FontButton:GetHeight();
        else
            FontButton:SetPoint ( "TOP" , GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_FontDropDownMenu.Buttons[i - 1][1] , "BOTTOM" , 0 , -buffer );
            height = height + FontButton:GetHeight() + buffer;
        end

        FontButton:SetScript ( "OnClick" , function( self , button ) 
            if button == "LeftButton" then
                local parsedNumber = tonumber ( string.match ( self:GetName() , "(%d+)" ) );

                GRM.S().selectedFont = parsedNumber;
                GRML.SetNewFont ( parsedNumber );
                GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_FontSelected.GRM_FontSelectedText:SetText ( FontButtonText:GetText() );
                GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_FontSelected.GRM_FontSelectedText:SetFont ( GRML.listOfFonts[parsedNumber] , GRM_G.FontModifier + 11 );
                GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_FontDropDownMenu:Hide();
                GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_FontSelected:Show();

                -- Additional frame check...
                GRM_UI.ElvUIReset = true;
                GRM_UI.ElvUIReset2 = true;
                if IsAddOnLoaded ( "AddOnSkins" ) then
                    GRM_UI.GRM_RosterChangeLogFrame:Hide();
                    GRM_UI.GRM_RosterChangeLogFrame:Show();
                    if GRM_UI.GRM_MemberDetailMetaData:IsVisible() then
                        GRM_UI.GRM_MemberDetailMetaData:Hide();
                        GRM_G.pause = true;
                        GRM_UI.GRM_MemberDetailMetaData:Show();
                    end
                end
            end
        end);
        FontButton:Show();
    end
    GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_FontDropDownMenu:SetHeight ( height + 15 );
end

-- Method:          GRM.PopulateTimestampFormatDropDown()
-- What it Does:    Builds a dropdown menu displaying the various format options
-- Purpose:         To give the player the ability to adjust timestamp formats
GRM.PopulateTimestampFormatDropDown = function( nonGlobal )
    local buffer = 4;
    local height = 0;
    local dropDownMenu;
    local selectedFrame;
    local selectedText;
    local nameText = "";

    if nonGlobal then
        dropDownMenu = GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_NonGlobalTimestampSelectedDropDownMenu;
        selectedFrame = GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_NonGlobalTimestampSelected;
        selectedText = GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_NonGlobalTimestampSelected.GRM_NonGlobalTimestampSelectedText;
        nameText = "GRM_timeStampNonGlobalButton"
    else
        dropDownMenu = GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_OfficerOptionsFrame.GRM_TimestampSelectedDropDownMenu;
        selectedFrame = GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_OfficerOptionsFrame.GRM_TimestampSelected;
        selectedText = GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_OfficerOptionsFrame.GRM_TimestampSelected.GRM_TimestampSelectedText;
        nameText = "GRM_timeStampButton"
    end

    dropDownMenu.Buttons = dropDownMenu.Buttons or {};

    for i = 1 , #dropDownMenu do
        dropDownMenu.Buttons[i][1]:Hide();
    end

    local month , day , year = select ( 2 , GRM.GetTodaysDate() );

    for i = 1 , 17 do
        if not dropDownMenu.Buttons[i] then
            local tempButton = CreateFrame ( "Button" , nameText .. i , dropDownMenu );
            dropDownMenu.Buttons[i] = { tempButton , tempButton:CreateFontString ( nil , "OVERLAY" , "GameFontWhiteTiny" ) }
        end
        local timeStampButton = dropDownMenu.Buttons[i][1];
        local timeStampButtonText = dropDownMenu.Buttons[i][2];
        timeStampButton:SetWidth ( 110 );
        timeStampButton:SetHeight ( 11 );
        timeStampButton:SetHighlightTexture ( "Interface\\Buttons\\UI-Panel-Button-Highlight" );
        timeStampButtonText:SetText ( GRM.FormatTimeStamp ( { day , month , year } , false , false , i ) );
        timeStampButtonText:SetWidth ( 105 );
        timeStampButtonText:SetWordWrap ( false );
        timeStampButtonText:SetFont ( GRM_G.FontChoice , GRM_G.FontModifier + 11 );
        timeStampButtonText:SetPoint ( "CENTER" , timeStampButton , 5 , 0 );
        timeStampButtonText:SetJustifyH ( "LEFT" );

        if i == 1 then
            timeStampButton:SetPoint ( "TOP" , dropDownMenu , 0 , -7 );
            height = height + timeStampButton:GetHeight();
        else
            timeStampButton:SetPoint ( "TOP" , dropDownMenu.Buttons[i - 1][1] , "BOTTOM" , 0 , -buffer );
            height = height + timeStampButton:GetHeight() + buffer;
        end

        if nonGlobal then
            timeStampButton:SetScript ( "OnClick" , function( self , button ) 
                if button == "LeftButton" then
                    local parsedNumber = tonumber ( string.match ( self:GetName() , "(%d+)" ) );
            
                    GRM.S().dateFormat = parsedNumber;
                    -- if not GRM.IsSyncRankGuildLeaderRestricted then
                    --     GRM.S().globalDateFormat = parsedNumber;  -- Set global if not set. 

                    -- end
                    GRM.ReprocessAllLogEntriesToCurrentLanguage();
                    selectedText:SetText ( timeStampButtonText:GetText() );
                    dropDownMenu:Hide();
                    selectedFrame:Show();
                end
            end);
        else
            timeStampButton:SetScript ( "OnClick" , function( self , button ) 
                if button == "LeftButton" then
                    local parsedNumber = tonumber ( string.match ( self:GetName() , "(%d+)" ) );

                    GRM.S().globalDateFormat = parsedNumber;
                    GRM.UpdateGuildInfoWithNewValue ( 1 , parsedNumber );
                    GRM.ReprocessAllLogEntriesToCurrentLanguage();

                    selectedText:SetText ( timeStampButtonText:GetText() );
                    dropDownMenu:Hide();
                    selectedFrame:Show();
                end
            end);
        end
        timeStampButton:Show();
    end
    if nonGlobal then
        GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_NonGlobalTimestampSelectedDropDownMenu:SetHeight ( height + 15 );
    else
        GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_OfficerOptionsFrame.GRM_TimestampSelectedDropDownMenu:SetHeight ( height + 15 );
    end
end

-- Method:          GRM.CreateServerSelectionDropdown ( array )
-- What it Does:    Builds a dropdown menu of all the connected realms for ban player creation
-- Purpose:         To ensure players accurately add players.
GRM.CreateServerSelectionDropdown = function ( theList )
    local buffer = 4;
    local height = 0; 
    local name = "Realm";
    GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_AddBanFrame.GRM_BanServerDropDownMenu.Buttons = GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_AddBanFrame.GRM_BanServerDropDownMenu.Buttons or {};

    for i = 1 , #theList do
        if not GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_AddBanFrame.GRM_BanServerDropDownMenu.Buttons[i] then
            local tempButton = CreateFrame ( "Button" , name .. "_Button" .. i , GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_AddBanFrame.GRM_BanServerDropDownMenu );
            GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_AddBanFrame.GRM_BanServerDropDownMenu.Buttons[i] = { tempButton , tempButton:CreateFontString ( nil , "OVERLAY" , "GameFontWhiteTiny" ) }
            if i == 1 then
                GRM_G.DropDownHighlightLockIndex = 1;
                GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_AddBanFrame.GRM_BanServerDropDownMenu.Buttons[i][1]:LockHighlight();
            end
        end
        local Button = GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_AddBanFrame.GRM_BanServerDropDownMenu.Buttons[i][1];
        local ButtonText = GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_AddBanFrame.GRM_BanServerDropDownMenu.Buttons[i][2];
        Button:SetWidth ( GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_AddBanFrame.GRM_BanServerSelected:GetWidth() );
        Button:SetHeight ( 11 );
        Button:SetHighlightTexture ( "Interface\\Buttons\\UI-Panel-Button-Highlight" );
        ButtonText:SetText ( theList[i] );
        ButtonText:SetWidth ( GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_AddBanFrame.GRM_BanServerSelected:GetWidth() - 5 );
        ButtonText:SetWordWrap ( false );
        ButtonText:SetFont ( GRM_G.FontChoice , GRM_G.FontModifier + 10 );
        ButtonText:SetPoint ( "CENTER" , Button );
        ButtonText:SetJustifyH ( "CENTER" );

        if i == 1 then
            Button:SetPoint ( "TOP" , GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_AddBanFrame.GRM_BanServerDropDownMenu , 0 , -7 );
            height = height + Button:GetHeight();
        else
            Button:SetPoint ( "TOP" , GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_AddBanFrame.GRM_BanServerDropDownMenu.Buttons[i - 1][1] , "BOTTOM" , 0 , -buffer );
            height = height + Button:GetHeight() + buffer;
        end

        Button:SetScript ( "OnClick" , function()
            GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_AddBanFrame.GRM_BanServerSelected.GRM_BanServerSelectedText:SetText ( ButtonText:GetText() );
            GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_AddBanFrame.GRM_BanServerSelected:Show();

            GRM_UI.CheckForBanPlayerAutoSelect ( true , true );
        end);
        Button:Show();
    end
    
    for i = #theList + 1 , #GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_AddBanFrame.GRM_BanServerDropDownMenu.Buttons do
        GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_AddBanFrame.GRM_BanServerDropDownMenu.Buttons[i][1]:Hide();
    end
    GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_AddBanFrame.GRM_BanServerDropDownMenu:SetHeight ( height + 15 );
end

-- Method:          GRM.Populate24HrDropDown()
-- What it Does:    Builds the 2 options in 24 hr timescale vs 12 hr
-- Purpose:         To give the player the option to set it to a 12hr scale or 24hr scale.
GRM.Populate24HrDropDown = function()
    local buffer = 4;
    local height = 0;
    GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_24HrSelectedDropDownMenu.Buttons = GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_24HrSelectedDropDownMenu.Buttons or {};

    for i = 1 , #GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_24HrSelectedDropDownMenu.Buttons do
        GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_24HrSelectedDropDownMenu.Buttons[i][1]:Hide();
    end

    local HourFormat = { GRM.L ( "24 Hour" ) , GRM.L ( "12 Hour (am/pm)" ) };

    for i = 1 , 2 do
        if not GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_24HrSelectedDropDownMenu.Buttons[i] then
            local tempButton = CreateFrame ( "Button" , "GRM_HrButton" .. i , GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_24HrSelectedDropDownMenu );
            GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_24HrSelectedDropDownMenu.Buttons[i] = { tempButton , tempButton:CreateFontString ( nil , "OVERLAY" , "GameFontWhiteTiny" ) }
        end
        local HrButton = GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_24HrSelectedDropDownMenu.Buttons[i][1];
        local HrButtonText = GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_24HrSelectedDropDownMenu.Buttons[i][2];
        HrButton:SetWidth ( 110 );
        HrButton:SetHeight ( 11 );
        HrButton:SetHighlightTexture ( "Interface\\Buttons\\UI-Panel-Button-Highlight" );
        HrButtonText:SetText ( HourFormat[i] );
        HrButtonText:SetWidth ( 105 );
        HrButtonText:SetWordWrap ( false );
        HrButtonText:SetFont ( GRM_G.FontChoice , GRM_G.FontModifier + 11 );
        HrButtonText:SetPoint ( "CENTER" , HrButton );
        HrButtonText:SetJustifyH ( "CENTER" );

        if i == 1 then
            HrButton:SetPoint ( "TOP" , GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_24HrSelectedDropDownMenu , 0 , -7 );
            height = height + HrButton:GetHeight();
        else
            HrButton:SetPoint ( "TOP" , GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_24HrSelectedDropDownMenu.Buttons[i - 1][1] , "BOTTOM" , 0 , -buffer );
            height = height + HrButton:GetHeight() + buffer;
        end

        HrButton:SetScript ( "OnClick" , function( self , button ) 
            if button == "LeftButton" then
                local parsedNumber = tonumber ( string.match ( self:GetName() , "(%d+)" ) );

                if parsedNumber == 1 then
                    GRM.S().twentyFourHrScale = true;
                else
                    GRM.S().twentyFourHrScale = false;
                end
                GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_24HrSelected.GRM_24HrSelectedText:SetText ( HrButtonText:GetText() );
                GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_24HrSelectedDropDownMenu:Hide();
                GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_24HrSelected:Show();
                GRM.ReprocessAllLogEntriesToCurrentLanguage();
            end
        end);
        HrButton:Show();
    end
    GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_24HrSelectedDropDownMenu:SetHeight ( height + 15 );
end

-- Method:          GRM.SetGroupInviteButton ( string )
-- What it Does:    Invites a selected guildie to your group
-- Purpose:         Continuity on previous Blizz default frames to these
GRM.SetGroupInviteButton = function ( handle )

    local setButtonAction = function()
        -- Player is not in any group, thus inviting them will create new group.
        
        GRM_UI.GRM_MemberDetailMetaData.GRM_GroupInviteButton:SetScript ( "OnClick" , function ( _ , button )
            if button == "LeftButton" then
                C_PartyInfo.InviteUnit ( handle );
            end
        end);
    end

    if GetNumGroupMembers() > 0  then  -- If > 0 then player is in either a raid or a party. (1 will show if in an instance by oneself)
        local isGroupLeader = UnitIsGroupLeader ( "PLAYER" );                                       -- Party or Group
        local isInRaidWithAssist = UnitIsGroupAssistant ( "PLAYER" , LE_PARTY_CATEGORY_HOME );      -- Player Has Assist in Raid group
            
        if isGroupLeader or isInRaidWithAssist then                                         -- Player has the ability to invite to group
            setButtonAction();
        else            -- Player is in a group but does not have invite privileges
            GRM_UI.GRM_MemberDetailMetaData.GRM_GroupInviteButton.GRM_GroupInviteButtonText:SetText ( GRM.L ( "No Invite" ) );
            GRM_UI.GRM_MemberDetailMetaData.GRM_GroupInviteButton:SetScript ( "OnClick" , function ( _ , button )
                if button == "LeftButton" then
                    GRM.Report ( GRM.L ( "Player should try to obtain group invite privileges." ) );
                end
            end);
        end
    else
        setButtonAction();
    end

    if GRM_UI.GRM_MemberDetailMetaData.GRM_GroupInviteButton.GRM_GroupInviteButtonText:GetText() ~= nil then
        GRM_UI.ScaleFontStringToObjectSize ( true , GRM_UI.GRM_MemberDetailMetaData.GRM_GroupInviteButton:GetWidth() , GRM_UI.GRM_MemberDetailMetaData.GRM_GroupInviteButton.GRM_GroupInviteButtonText , 4 );
    end
end

-- Method:          GRM.CreateOptionsRankDropDown()
-- What it Does:    Builds the final rank drop down product for options panel
-- Purpose:         UI Feature for options to be able to filter who you will accept shared data from.
GRM.CreateOptionsRankDropDown = function ()
    GRM.PopulateOptionsRankDropDown();
    GRM.PopulateBanListOptionsDropDown();
    GRM.PopulateDefaultDropDownRankMenu();

    local numRanks = GuildControlGetNumRanks() - 1;
    local HourFormat = { GRM.L ( "24 Hour" ) , GRM.L ( "12 Hour (am/pm)" ) };
    local tabChoices = { GRM.L ( "LOG" ) , GRM.L ( "EVENTS" ) , GRM.L ( "BAN LIST" ) , GRM.L ( "SYNC USERS" ) , string.upper ( GRM.L ( "Options" ) ) , GRM.L ( "AUDIT" ) };
    
    -- General sync restriction
    if GRM.S().syncRank > numRanks then       -- There's been a change since the player last logged in...
        GRM.S().syncRank = numRanks;
        GRM.UpdateGuildInfoWithNewValue ( 2 , numRanks );
    end
    -- Ban List Sync restriction
    if GRM.S().syncRankBanList > numRanks then       -- There's been a change since the player last logged in...
        GRM.S().syncRankBanList = numRanks;
        GRM.UpdateGuildInfoWithNewValue ( 3 , numRanks );
    end
    -- Custom Note Sync Restriction
    if GRM.S().syncRankCustom > numRanks then       -- There's been a change since the player last logged in...
        GRM.S().syncRankCustom = numRanks;
        GRM.UpdateGuildInfoWithNewValue ( 4 , numRanks );
    end

    local setRankName = GuildControlGetRankName ( GRM.S().syncRank + 1 );
    local setRankNameBanList = GuildControlGetRankName ( GRM.S().syncRankBanList + 1 );
    local setCustomDefaultName = GuildControlGetRankName ( GRM.S().syncRankCustom + 1 );
    
    if setRankName == nil or setRankName == "" then
        setRankName = GuildControlGetRankName ( 1 )     -- Default it to guild leader. This scenario could happen if the rank was removed or you change guild but still have old settings.
    end
    if setRankNameBanList == nil or setRankNameBanList == "" then
        setRankNameBanList = GuildControlGetRankName ( 1 )     -- Default it to guild leader. This scenario could happen if the rank was removed or you change guild but still have old settings.
    end

    GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_SyncOptionsFrame.GRM_RosterSyncRankDropDownSelectedText:SetText( setRankName );
    GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_SyncOptionsFrame.GRM_RosterBanListDropDownSelectedText:SetText ( setRankNameBanList );
    GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_SyncOptionsFrame.GRM_DefaultCustomSelectedText:SetText ( setCustomDefaultName );

    local TagText = GRM.GetMainTags ( false , GRM.S().mainTagIndex );
    if TagText == "" then
        GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_MainTagFormatSelected.GRM_TagText:SetText ( GRM.L ( "No Tag" ) );
    else
        GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_MainTagFormatSelected.GRM_TagText:SetText ( TagText );
    end

    GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_MainTagFormatSelected.GRM_TagText:SetTextColor ( GRM.S().mainTagColor.r , GRM.S().mainTagColor.g , GRM.S().mainTagColor.b , 1 );
    GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_LanguageSelected.GRM_LanguageSelectedText:SetText ( GRM.L ( GRML.Languages[GRM.S().selectedLang] ) );
    GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_ColorSelectOptionsFrame.GRM_OptionsTexture:SetColorTexture ( GRM.S().mainTagColor.r , GRM.S().mainTagColor.b , GRM.S().mainTagColor.g , 1 );
    GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_FontSelected.GRM_FontSelectedText:SetFont ( GRM_G.FontChoice , GRM_G.FontModifier + 11 );
    GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_FontSelected.GRM_FontSelectedText:SetText ( GRML.FontNames[ GRM.S().selectedFont ] );
    local month , day , year = select ( 2 , GRM.GetTodaysDate() );
    GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_OfficerOptionsFrame.GRM_TimestampSelected.GRM_TimestampSelectedText:SetText( GRM.FormatTimeStamp ( { day , month , year } , false , false , GRM.S().globalDateFormat ) );
    if GRM.S().twentyFourHrScale then
        GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_24HrSelected.GRM_24HrSelectedText:SetText ( HourFormat[1] );
    else
        GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_24HrSelected.GRM_24HrSelectedText:SetText ( HourFormat[2] );
    end

    GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_DefaultTabSelected.GRM_DefaultTabSelectedText:SetText ( tabChoices[GRM.S().defaultTabSelection[2]] );
    GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_NonGlobalTimestampSelected.GRM_NonGlobalTimestampSelectedText:SetText( GRM.FormatTimeStamp ( { day , month , year } , false , false , GRM.S().dateFormat ) );
    

    -- Now that initial values set, let's display them!
    GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_SyncOptionsFrame.GRM_RosterSyncRankDropDownSelected:Show();
    GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_SyncOptionsFrame.GRM_RosterBanListDropDownSelected:Show();
    GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_SyncOptionsFrame.GRM_DefaultCustomSelected:Show();
    GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_MainTagFormatSelected:Show();
    GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_LanguageSelected:Show();
    GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_FontSelected:Show();
    GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_OfficerOptionsFrame.GRM_TimestampSelected:Show();
    GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_24HrSelected:Show();
    GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_DefaultTabSelected:Show();
    GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame.GRM_NonGlobalTimestampSelected:Show();
end

-- Method:              GRM.ClearPromoDateHistory ( string , bool )
-- What it Does:        Purges history of promotions as if they had just joined the guild.
-- Purpose:             Editing ability in case of user error.
GRM.ClearPromoDateHistory = function ( name , isUnknown , member )
    local player = member or GRM.GetPlayer ( name );

    if player then
        -- Ok, let's clear the history now!
        if not isUnknown then
            GRM_G.rankDateSet = false;
        end
        player.rankHist = nil;
        player.rankHist = { { player.rankName , 0 , 0 , 0 , "0" , 0 , false , 1 } };

        player.promoteDateUnknown = false;

        if name == GRM_G.currentName and GRM_UI.GRM_MemberDetailMetaData:IsVisible() then
            GRM_UI.GRM_MemberDetailMetaData.GRM_altDropDownOptions:Hide();
            if not isUnknown then
                GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailRankDateTxt:Hide();
                GRM_UI.GRM_MemberDetailMetaData.GRM_SetPromoDateButton:Show();
            end
        end
    end
end

-- Method:              GRM.ClearJoinDateHistory ( string )
-- What it Does:        Clears the player's history on when they joined/left/rejoined the guild to be as if they were  a new member
-- Purpose:             Micromanagement of toons metadata.
GRM.ClearJoinDateHistory = function ( name , isUnknown , member )
    local player = member or  GRM.GetPlayer ( name );

    if player then
        -- Ok, let's clear the history now!
        player.joinDateHist = nil;
        player.joinDateHist = { { 0 , 0 , 0 , "0" , 0 , false , 1 } };
        player.joinDateUnknown = false;
        if name == GRM_G.currentName and GRM_UI.GRM_MemberDetailMetaData:IsVisible() then
            GRM_UI.GRM_MemberDetailMetaData.GRM_JoinDateText:Hide();
            GRM_UI.GRM_MemberDetailMetaData.GRM_altDropDownOptions:Hide();
            if not isUnknown then
                GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailJoinDateButton:Show();
            end

            if GRM.PlayerOrAltHasJD ( GRM_G.currentName ) then
                if GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailJoinDateButton:IsVisible() then
                    GRM_UI.GRM_MemberDetailMetaData.GRM_SyncDateArrowButton:ClearAllPoints();
                    GRM_UI.GRM_MemberDetailMetaData.GRM_SyncDateArrowButton:SetPoint ( "LEFT" , GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailJoinDateButton , "RIGHT" , 0 , 0 );
                elseif GRM_UI.GRM_MemberDetailMetaData.GRM_JoinDateText:IsVisible() then
                    GRM_UI.GRM_MemberDetailMetaData.GRM_SyncDateArrowButton:ClearAllPoints();
                    GRM_UI.GRM_MemberDetailMetaData.GRM_SyncDateArrowButton:SetPoint ( "LEFT" , GRM_UI.GRM_MemberDetailMetaData.GRM_JoinDateText , "RIGHT" , 8 , -0.5 );
                end
                GRM_UI.GRM_MemberDetailMetaData.GRM_SyncDateArrowButton:Show();
            else
                GRM_UI.GRM_MemberDetailMetaData.GRM_SyncDateArrowButton:Hide();
            end
        end
    end
end

-- Method:              GRM.ResetPlayerMetaData ( string , string )
-- What it Does:        Purges all metadata from an alt up to that point and resets them as if they were just added to the guild roster
-- Purpose:             Metadata player management. QoL feature if ever needed.
GRM.ResetPlayerMetaData = function ( playerName )
    local player =  GRM.GetPlayer ( playerName );

    if player then
        local classedName = GRM.GetStringClassColorByName ( playerName ) .. GRM.SlimName ( playerName ) .. "|r";
        GRM.Report ( GRM.L ( "{name}'s saved data has been wiped!" , classedName ) );

        GRM.GuildRoster();

        local member = {};
        for i = 1 , GRM.GetNumGuildies() do
            local name , rank , rankInd , level , _ , zone , _ , _ , online , status , class , achievementPoints , _ , isMobile , _ , rep , GUID = GetGuildRosterInfo ( i );
            if name == playerName then

                member.name = name                                    -- 1
                member.rankName = rank;                               -- 2
                member.rankIndex = rankInd;                           -- 3
                member.level = level;                                 -- 4
                member.note = player.note;                                   -- 5
                member.officerNote = player.officerNote;                 -- 6

                member.class = class;                                 -- 7
                member.lastOnline = GRM.GetHoursSinceLastOnline ( i , online ); -- 8 Time since they last logged in in hours.
                member.zone = zone;                                   -- 9
                member.achievementPoints = achievementPoints;         -- 10
                member.isMobile = isMobile;                           -- 11
                member.rep = rep;                                     -- 12
                member.isOnline = online;                             -- 13
                member.status = status;                               -- 14
                member.GUID = GUID;                                   -- 15

                local race , sex = select ( 4 , GetPlayerInfoByGUID ( GUID ) );
                if race == nil or sex == nil then
                    race , sex = select ( 4 , GetPlayerInfoByGUID ( GUID ) );   -- Call a second time... sometimes the server is weird and the first call produces nil, but the immediate 2nd does respond.
                    if race == nil or sex == nil then
                        race = "";
                        sex = 1;
                    end
                end

                member.race = race;                                   -- 16
                member.sex = sex;                                     -- 17
                member.rosterSelection = i;                           -- 18
                member.faction = player.faction;

                if GRM_G.BuildVersion >= 80000 then
                    local player = GRM.GetClubMemberInfo ( member.name )

                    if player then
                        if player.overallDungeonScore then
                            member.MythicScore = player.overallDungeonScore;
                        else
                            member.MythicScore = 0;
                        end

                    end
                end
                
                break;
            end
        end

        if GRM.PlayerHasAlts ( player ) then
            GRM.RemoveAlt ( playerName , false , 0 );
        end

        GRM_GuildMemberHistory_Save[GRM_G.guildName][playerName] = nil;         -- Remove the player!

        if member.name ~= nil then
            GRM.AddMemberRecord ( member , false , nil )     -- Re-Add the player!
        end

        GRM_UI.GRM_MemberDetailMetaData:Hide();        
    end
end

-- Method:          GRM.ResetAllSavedData()
-- What it Does:    Purges literally ALL saved data, then rebuilds it from scratch as if addon was just installed.
-- Purpose:         Clear data for any purpose needed.
GRM.ResetAllSavedData = function()
    GRM.Report ( GRM.L ( "Wiping all Saved Roster Data Account Wide! Rebuilding from Scratch..." ) );

    GRM_GuildMemberHistory_Save = nil;
    GRM_GuildMemberHistory_Save = {};

    GRM_PlayersThatLeftHistory_Save = nil;
    GRM_PlayersThatLeftHistory_Save = {};

    GRM_LogReport_Save = nil;
    GRM_LogReport_Save = {};

    GRM_PlayerListOfAlts_Save = nil;
    GRM_PlayerListOfAlts_Save = {};

    GRM_GuildDataBackup_Save = nil;
    GRM_GuildDataBackup_Save = {};

    GRM_CalendarAddQue_Save = nil;
    GRM_CalendarAddQue_Save = {};

    GRM_DebugLog_Save = nil;
    GRM_DebugLog_Save = {};

    GRM_Misc = nil;
    GRM_Misc = {};

    GRM_Alts = nil;
    GRM_Alts = {};
    
    GRM.ConfigureAnnounceOnLogin ( true );

    -- Hide the window frame so it can quickly be reloaded.
    GRM_UI.GRM_MemberDetailMetaData:Hide();

    -- Now, let's rebuild...
    if IsInGuild() then
        GRM.BuildNewRoster( true , true );
    end
    -- Update the logFrame if it was open at the time too
    if GRM_UI.GRM_RosterChangeLogFrame:IsVisible() then
        GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_LogEditBox:SetText ( GRM.L ( "Search Filter" ) );
        GRM.BuildLog();
    end

    -- Update the ban list too!
    if GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame:IsVisible() then
        GRM.RefreshBanListFrames();
    end

    if GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame:IsVisible() then
        GRM.RefreshAuditFrames ( true , true );
    end

    -- Trigger Sync
    --Let's re-initiate syncing!
    if GRM.S().syncEnabled and not GRMsyncGlobals.currentlySyncing and GRM_G.HasAccessToGuildChat then
        GRMsync.TriggerFullReset();
        -- Now, let's add a brief delay, 3 seconds, to trigger sync again
        C_Timer.After ( 3 , GRMsync.Initialize );
    end
end

-- Method:          GRM.ResetGuildSavedData( string )
-- What it Does:    Purges all saved data from the guild and only the guild...
-- Purpose:         Sometimes you don't want to reset everything... just the guild.
GRM.ResetGuildSavedData = function ( guildName )
    GRM.Report ( GRM.L ( "Wiping all saved Guild data! Rebuilding from scratch..." ) );

    -- Removing Players that left saved metadaa
    GRM_PlayersThatLeftHistory_Save[guildName] = nil;

    -- removing Player Saved metadata of the guild
    GRM_GuildMemberHistory_Save[guildName] = nil;
    
    -- Clearing the Guild Log...Resetting the add to calendar que
    GRM_CalendarAddQue_Save[guildName] = nil;

    -- Clearing the Guild Log...
    GRM_LogReport_Save[guildName] = nil;

    -- Clear the backups... they gotta go too!
    GRM_GuildDataBackup_Save[guildName] = nil;

    GRM_Alts[guildName] = nil;

    GRM.ConfigureAnnounceOnLogin ( true );

    -- Hide the window frame so it can quickly be reloaded.
    GRM_UI.GRM_MemberDetailMetaData:Hide();

    GRM_G.BackupLoadedOnce = false;

    -- Now, let's rebuild...
    if IsInGuild() then
        GRM.BuildNewRoster();
    end

    C_Timer.After ( 3 , function()
        -- Update the logFrame if it was open at the time too
        if GRM_UI.GRM_RosterChangeLogFrame:IsVisible() then
            GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_LogEditBox:SetText ( GRM.L ( "Search Filter" ) );
            GRM.BuildLog();
        end

        -- Update the ban list too!
        if GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame:IsVisible() then
            GRM.RefreshBanListFrames();
        end

        if GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame:IsVisible() then
            GRM.RefreshAuditFrames ();
        end

        if GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_UIOptionsFrame:IsVisible() then
            GRM_G.BackupLoadedOnce = true;
            GRM.BuildBackupScrollFrame ();
        end
        
        --Let's re-initiate syncing!
        if GRM.S().syncEnabled and not GRMsyncGlobals.currentlySyncing and GRM_G.HasAccessToGuildChat and not GRM_G.OnFirstLoad then
            GRMsync.TriggerFullReset();
            -- Now, let's add a brief delay, 3 seconds, to trigger sync again
            C_Timer.After ( 3 , GRMsync.Initialize );
        end
    end);
end

-- Method:          GRM.CheckForNewPlayer ( string )
-- What it Does:    Live checks when a player joins the guild and reports on it
-- Purpose:         For live detection use separate than on scheduled scan
GRM.CheckForNewPlayer = function ( name )
    local rosterName , rank , rankInd , level , zone , note , oNote , classFile , pts , rep , guid , _ ;
    local isFound = false;
    local rosterIndex = 0;

    -- Error protection if player leaves guild within the 1 second someone joins
    if not IsInGuild() then
        return;
    end

    for i = 1 , GRM.GetNumGuildies() do
        rosterName , rank , rankInd , level , _ , zone , note , oNote , _ , _ , classFile , pts , _ , _ , _ , rep , guid = GetGuildRosterInfo ( i );
        if name == rosterName then
            isFound = true;
            rosterIndex = i;
            break;
        end
    end
    if isFound then           -- This means it shows successfully 1 found player...
        if not GRM_G.liveAddedToons[rosterName] then

            GRM_G.liveAddedToons[rosterName] = {};

            local race , sex;
            if guid ~= "" then
                race , sex = select ( 4 , GetPlayerInfoByGUID ( guid ) );
            end
            if race == nil or sex == nil then
                race , sex = select ( 4 , GetPlayerInfoByGUID ( guid ) );   -- Call a second time... sometimes the server is weird and the first call produces nil, but the immediate 2nd does respond.
                if race == nil or sex == nil then
                    race = "";
                    sex = 1;
                end
            end

            local memberInfoToAdd = {};

            memberInfoToAdd.name = rosterName                                           -- 1
            memberInfoToAdd.rankName = rank;                                            -- 2
            memberInfoToAdd.rankIndex = rankInd;                                        -- 3 (It needs to be 1 less to match when compared to the guildRosterInfo call )
            memberInfoToAdd.level = level;                                              -- 4
            memberInfoToAdd.note = note;                                                -- 5
            if GRM.CanViewOfficerNote() then
                memberInfoToAdd.officerNote = oNote;                                    -- 6
            else
                memberInfoToAdd.officerNote = nil; 
            end
            memberInfoToAdd.class = classFile;                                          -- 7
            memberInfoToAdd.lastOnline = 0;                                             -- 8 Time since they last logged in in hours.
            memberInfoToAdd.zone = zone;                                                -- 9
            memberInfoToAdd.achievementPoints = pts;                                    -- 10    
            memberInfoToAdd.isMobile = false;                                           -- 11
            memberInfoToAdd.rep = rep;                                                  -- 12
            memberInfoToAdd.isOnline = true;                                            -- 13
            memberInfoToAdd.status = 0;                                                 -- 14
            memberInfoToAdd.GUID = guid;                                                -- 15
            memberInfoToAdd.race = "";                                                  -- 16
            memberInfoToAdd.sex = 1;                                                    -- 17
            memberInfoToAdd.rosterSelection = rosterIndex;                                        -- 18

            memberInfoToAdd.faction = GRM_G.faction;

            if GRM_G.BuildVersion >= 80000 then
                memberInfoToAdd.MythicScore = 0;
            end

            if GRM_G.BuildVersion >= 80000 then

                local clubID = C_Club.GetGuildClubId();
                if clubID and clubID ~= "" then
                    local members = C_Club.GetClubMembers ( clubID )
                    local playerName = "";
        
                    if members then
                        for i = 1 , #members do
                            player = C_Club.GetMemberInfo ( clubID , members[i] )
                            playerName = GRM.GetFullNameClubMember ( player.guid );
            
                            if player and playerName and playerName ~= "" and playerName == rosterName then
                                if player.overallDungeonScore then
                                    memberInfoToAdd.MythicScore = player.overallDungeonScore;
                                end
            
                                if GRM_G.BuildVersion >= 100000 then
                                    memberInfoToAdd.faction = player.faction;
                                end
                                break;
                            end
                        end
                    end
                end
            end

            GRM.RecordJoinChanges ( memberInfoToAdd , GRM.GetClassColorRGB ( classFile , true ) .. GRM.SlimName ( name ) .. "|r" , true , select ( 2 , GRM.GetTimestamp() ) , true );

            if GRM_UI.GRM_RosterFrame and GRM_UI.GRM_RosterFrame:IsVisible() then
                GRM_R.RefreshRosterName();
            end
    
            -- Check Main Auto tagging...
            if not GRM_G.OnFirstLoad then
                GRM.SetGuildInfoDetails();
            end

            -- -- Delay for time to check "Unique Accounts" change...
            C_Timer.After ( 10 , function()               
                if GRM_G.DesignateMain then
                    GRM.SetMain ( name , 1 );
                    GRM.Report ( GRM.L ( "GRM Auto-Detect! {name} has joined the guild and will be set as Main" , GRM.GetClassifiedName ( name , true ) ) );
                    if GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame:IsVisible() then
                        GRM.RefreshAuditFrames ( true , true );
                    end
                end
            end);
            -- Clear them - this prevents the spam join from server.
            C_Timer.After ( 2 , function()
                GRM_G.liveAddedToons[rosterName] = nil
            end)
        end

    elseif GRM_G.RejoinControlCheck <= 90 then
        GRM_G.RejoinControlCheck = GRM_G.RejoinControlCheck + 1;
        
        -- Try to refresh the roster
        if GRM_G.RejoinControlCheck % 10 == 0 then
            GRM.GuildRoster();
            if GRM_G.BuildVersion >= 30000 then
                QueryGuildEventLog();
            end            
        end

        C_Timer.After ( 0.1 , function()
            -- Re-Check 1 time.
            GRM.CheckForNewPlayer( name );
        end);
        return;
    end

    GRM_G.RejoinControlCheck = 0;
end

-- Method:          GRM.GetParsedNameFromInviteAnnouncmenet ( string )
-- What it Does:    Parses out the player name-server from the system message about a player joining the guild
-- Purpose:         Useful for players joining the guild.
GRM.GetParsedNameFromInviteAnnouncmenet = function( text )
    local ind = string.find ( text , "-" );
    if string.find ( string.sub ( text , ind ) , " " ) ~= nil then  -- We know that there is a space at the end of it... Let's parse that off.
        for i = ind , #text do
            if string.sub ( text , i , i ) == " " then
                text = string.sub ( text , 1 , i - 1 );
                break;
            end
        end
        -- text = string.sub ( text , 1 , ind + string.find ( string.sub ( text , ind ) , " " ) - 1 );
    end
    if string.find ( text , " " ) ~= nil then
        for i = ind , 1 , -1 do
            if string.sub ( text , i , i ) == " " then
                text = string.sub ( text , i + 1 );
                break;
            end
        end
    end
    return text;
end

-- Method:          GRM.LiveKickDetection( string , int )
-- What it Does:    Reports the a player was kicked from the guild and checks if ban was done as well
-- Purpose:         To update the database on-the-fly for changes.
--                  Limited in Classic to only detect your own changes, not others, due to some server limitations and lack of desire to parse text for 11 different languages.
GRM.LiveKickDetection = function( text , scanNumber )

    if GRM_G.ClassicKickErrorProtect ~= text then
        GRM_G.ClassicKickErrorProtect = text;

        -- In a function to be called immediately or upon a delay
        local playerThatWasKicked , playerThatKicked = GRM.GetParsedKickPlayerNames ( text );
        local result = false;

        if playerThatWasKicked ~= "" then
            result = true;
            if GRM_G.currentName == playerThatWasKicked and GRM_UI.GRM_MemberDetailMetaData:IsVisible() then
                GRM_G.pause = false;
                GRM_UI.GRM_MemberDetailMetaData:Hide();
            end

            if playerThatWasKicked then
                GRM_G.liveKickedToons[playerThatWasKicked] = {};
            end
            GRM_G.KickAction ( playerThatWasKicked , playerThatKicked );
        end

        GRM_G.LiveScanningBlock.kick[scanNumber] = false;
        return result;
    else
        return false;
    end
end

-- Method:          GRM.BanAndKickingAltsByPlayer ( string )
-- What it Does:    Removes the player, but all ques up alts for kicking, and bans all the alts as well if setting is so checked.
-- Purpose:         Allow player to also ban all connected alts
GRM.BanAndKickingAltsByPlayer = function ( playerThatWasKicked , scanNumber )
    local banReason = GRM_UI.GRM_MemberDetailPopupEditBox:GetText();
    local banGeneric = GRM.L ( "Reason Banned?" ) .. "\n" .. GRM.L ( "Click \"YES\" When Done" );
    local result = "";
    local recorded = false;

    if banReason ~= banGeneric and banReason ~= "" and banReason ~= nil then
        result = banReason;
    end

    if GRM_G.isChecked2 then
        GRM.KickAllAlts ( playerThatWasKicked , result );
    end
    
    if GRM_G.isChecked then          -- Box is checked, so YES player should be banned. -This boolean is useful because this is a reused Blizz default frame, since protected function.
        -- Popup edit box - BAN logic...
        local player = GRM.GetPlayer ( playerThatWasKicked );
        if player then
            player.bannedInfo[1] = true;      -- This officially tags the player as BANNED!
            player.bannedInfo[2] = time();
            player.bannedInfo[3] = false;
            player.bannedInfo[4] = GRM_G.addonUser;

            if result ~= "" then
                player.reasonBanned = result;
            else
                player.reasonBanned = "";
            end

            -- Add a log message too if it is a ban!
            local logEntryWithTime , logEntry = GRM.GetBanLogString ( GRM_G.isChecked2 , GRM.GetClassifiedName ( GRM_G.addonUser , true ) , GRM.GetClassifiedName ( player.name , true ) , player.reasonBanned , select ( 2 , GRM.GetTimestamp() ) );
            
            GRM.AddLog ( { 17 , logEntryWithTime , GRM_G.isChecked2 , GRM.GetClassifiedName ( GRM_G.addonUser , true ) , GRM.GetClassifiedName ( player.name , true ) , player.reasonBanned , select ( 2 , GRM.GetTimestamp() ) } );

            if GRM.S()["toChat"].banned then
                GRM.PrintLog ( { 17 , logEntry } );
            end

            -- Send the message out!
            if GRM.S().syncEnabled and GRM.S().syncBanList then
                if result == "" then
                    result = GRM.L ( "None Given" );
                end
                GRMsync.SendMessage ( "GRM_SYNC" , GRM_G.PatchDayString .. "?GRM_BAN?" .. GRM.S().syncRank .. "?" .. tostring ( GRM.S().syncRankBanList ) .. "?" .. playerThatWasKicked .. "?" .. tostring ( GRM_G.isChecked2 ) .. "?" .. result .. "?" .. player.class , "GUILD" );
            end
        end
    end
    GRM_G.KickAction ( playerThatWasKicked , GRM_G.addonUser , scanNumber , false );

    GRM_G.isChecked = false;
    GRM_G.isChecked2 = false;
end

-- Method:          GRM.GetPlayerKickedFromButton ( string , bool )
-- What it Does:    Used for the secure hook and runs when the guild uninvite action is implemented from removing the player and returns the player removed's name
-- Purpose:         Since the guild uninvite is a protected action now, it is still useful to know the name of the player being kicked, especially for perfect matching
--                  when trying to set a ban or kicking all of their alts as well.
GRM.GetPlayerKickedFromButton = function( nameOrGUID , isMacro )
    if IsInGuild() then
        local scanNumber = 0;

        if isMacro then
            GRM_G.LiveScanningBlock.kickM , scanNumber = GRM.SetNextTrue ( GRM_G.LiveScanningBlock.kickM );
        else
            GRM_G.LiveScanningBlock.kickS , scanNumber = GRM.SetNextTrue ( GRM_G.LiveScanningBlock.kickS );
        end
        GRM.GuildRoster();
        if GRM_G.BuildVersion >= 30000 then
            QueryGuildEventLog();
        end

        local playerThatWasKicked , realm = "" , "";

        if not GRM_G.CurrentlyScanning then
            GRM.KickButtonLogic ( nameOrGUID , scanNumber , isMacro );
        else
            if isMacro then
                GRM.AddToLiveScanQue ( 8 , nameOrGUID , scanNumber , isMacro );
            else
                GRM.AddToLiveScanQue ( 7 , nameOrGUID , scanNumber );
            end
        end
    end
        
end

-- Method:          GRM.KickButtonLogic ( string , int , bool )
-- What it Does:    Parses player name if they are going to be kicking for quick reporting
-- Purpose:         Control quick reporting to log and updating server.
GRM.KickButtonLogic = function ( nameOrGUID , scanNumber , isMacro )

    if string.match ( nameOrGUID , "Player-.+" ) then -- guid
        playerThatWasKicked, realm = select ( 6 , GetPlayerInfoByGUID ( nameOrGUID ) );
        -- run it twice...
        C_Timer.After ( 1 , function()
            playerThatWasKicked, realm = select ( 6 , GetPlayerInfoByGUID ( nameOrGUID ) );

            if realm == "" then
                playerThatWasKicked = GRM.AppendServerName ( playerThatWasKicked );
            else
                playerThatWasKicked = playerThatWasKicked .. "-" .. realm;
            end

            if playerThatWasKicked then
                GRM_G.liveKickedToons[playerThatWasKicked] = {};
            end
        
            if isMacro then
                GRM_G.KickAction ( playerThatWasKicked , GRM_G.addonUser , scanNumber , isMacro );
            else
                GRM.BanAndKickingAltsByPlayer ( playerThatWasKicked , scanNumber );
            end
            
        end);
        
    else -- name
        playerThatWasKicked = GRM.AppendServerName ( nameOrGUID );
        if playerThatWasKicked then
            GRM_G.liveKickedToons[playerThatWasKicked] = {};
        end
    
        if isMacro then
            GRM_G.KickAction ( playerThatWasKicked , GRM_G.addonUser , scanNumber , isMacro );
        else
            GRM.BanAndKickingAltsByPlayer ( playerThatWasKicked , scanNumber );
        end
        
    end

end

-- Method:          GRM_G.KickAction ( string , string )
-- What it Does:    Records the data of who was kicked, who did the kicking, and for their alts if necessary
-- Purpose:         Management of kicking logic.
GRM_G.KickAction = function( kickedToon , kickerOfficer , scanNumber , isMacro )
    if kickerOfficer ~= nil and #kickerOfficer > 0 then

        -- Calculate the changesGRM.RecordKickChanges
        local unitName , playerKicked , timePassed , logEntryMetaData , listOfAlts , mainName , publicNote , officerNote , date , isFoundInEventLog , _ , playerLevel , customNote = GRM.RecordKickChanges ( kickedToon , true , select ( 2 , GRM.GetTimestamp() ) , kickerOfficer );

        local logReportWithTime , logReport = GRM.GetLeftOrKickString ( unitName , playerKicked , timePassed , logEntryMetaData , listOfAlts , mainName , publicNote , officerNote , date , isFoundInEventLog , nil , nil , playerLevel , customNote );
        -- report the changes!
        if ( not GRM_UI.GRM_ToolCoreFrame:IsVisible() or ( GRM_UI.GRM_ToolCoreFrame:IsVisible() and not GRM.S().disableMacroToolLogSpam ) ) and GRM.S()["toChat"].left and not GRM_G.isChecked then
            GRM.PrintLog ( { 10 , logReport } );
        end
        GRM.AddLog ( { 10 , logReportWithTime , unitName , playerKicked , timePassed , logEntryMetaData , listOfAlts , mainName , publicNote , officerNote , date , playerLevel} );
    
        GRM_G.pause = false;

        -- Referesh frames if visible
        GRM_UI.GRM_MemberDetailMetaData:Hide();
        if kickerOfficer ~= GRM_G.addonUser or ( kickerOfficer == GRM_G.addonUser and GRM_UI.GRM_ToolCoreFrame ~= nil and not GRM_UI.GRM_ToolCoreFrame:IsVisible() and not GRM.isChecked2 ) then
            GRM.RefreshSelectHybridFrames ( true , true , true , true );
        end

        if GRM_UI.GRM_RosterFrame and GRM_UI.GRM_RosterFrame:IsVisible() then
            GRM_R.RefreshRosterName();
        end
        
    end

    if isMacro then
        GRM_G.LiveScanningBlock.kickM[scanNumber] = false;
    elseif scanNumber then
        GRM_G.LiveScanningBlock.kickS[scanNumber] = false;
    end
    
end

-- Method:          GRM.GetPromotionText ( string )
-- What it Does:    Returns the parsed names of the person who promotes a player, who was promoted, and the rank they were promoted to.
-- Purpose:         Live parsing of the system message so the player does not have to wait for the log to update in retail or the roster to refresh in Classic
--                  Also in Classic there is no log so this is the only way to actually log *who* did what.
GRM.GetPromotionText = function ( text )
    local officer , playerPromoted , newRank = "" , "" , "";
    local pattern = "";

    if GRM_G.Region == "deDE" then
        
        pattern = string.gsub ( ERR_GUILD_PROMOTE_SSS  , "%%1$s" , "(.+)" );
        for i = 2 , 3 do
            pattern = string.gsub ( pattern  , "%%" .. i .. "$s" , "(.+)" );
        end
        officer , playerPromoted , newRank = string.match ( text , pattern );

    elseif GRM_G.Region == "ruRU" then
        pattern = string.gsub ( "%s производит %s в звание \"%s\"."  , "%%s" , "(.+)" );
        officer , playerPromoted , newRank = string.match ( text , pattern );
        playerPromoted = string.sub ( playerPromoted , 6 , #playerPromoted - 1 );
        
    else
        pattern = string.gsub ( ERR_GUILD_PROMOTE_SSS  , "%%s" , "(.+)" );
        officer , playerPromoted , newRank = string.match ( text , pattern );

    end
        
    return GRM.AppendServerName ( officer ) , GRM.AppendServerName ( playerPromoted ) , newRank;
end

-- Method:          GRM.GetDeomotionText ( string )
-- What it Does:    Returns the parsed names of the person who promotes a player, who was demoted, and the rank they were demoted to.
-- Purpose:         Live parsing of the system message so the player does not have to wait for the log to update in retail or the roster to refresh in Classic
--                  Also in Classic there is no log so this is the only way to actually log *who* did what.
GRM.GetDeomotionText = function ( text )

    local officer , playerDemoted , newRank = "" , "" , "";
    local pattern = "";

    if GRM_G.Region == "deDE" then

        pattern = string.gsub ( ERR_GUILD_DEMOTE_SSS  , "%%1$s" , "(.+)" );
        for i = 2 , 3 do
            pattern = string.gsub ( pattern  , "%%" .. i .. "$s" , "(.+)" );
        end
        officer , playerDemoted , newRank = string.match ( text , pattern );

    elseif GRM_G.Region == "ruRU" then
        pattern = string.gsub ( "%s разжалует %s в звание \"%s\"."  , "%%s" , "(.+)" );
        officer , playerDemoted , newRank = string.match ( text , pattern );
        playerDemoted = string.sub ( playerDemoted , 6 , #playerDemoted - 1 );
        
    else
        pattern = string.gsub ( ERR_GUILD_DEMOTE_SSS  , "%%s" , "(.+)" );
        officer , playerDemoted , newRank = string.match ( text , pattern );

    end

    return GRM.AppendServerName ( officer ) , GRM.AppendServerName ( playerDemoted ) , newRank;
end

-------------------------------
--- LIVE EVENT TRACKING  ------
-------------------------------

GRM_G.LiveScanningBlock = {};
GRM_G.LiveScanningBlock.promoted = {};
GRM_G.LiveScanningBlock.demoted = {};
GRM_G.LiveScanningBlock.left = {};
GRM_G.LiveScanningBlock.kick = {};
GRM_G.LiveScanningBlock.kickS = {};
GRM_G.LiveScanningBlock.kickM = {};

GRM.LiveScanQue = {};
GRM_G.liveKickedToons = {};
GRM_G.liveAddedToons = {};
GRM_G.livePromotedToons = {};
GRM_G.liveDemotedToons = {};
GRM_G.processingLiveScanQue = false;

-- Method:          GRM.AddToLiveScanQue ( int , string , int )
-- What it Does:    Adds the entry to a table to be used for reporting if already involved in a log scan. No need to cause overlap.
-- Purpose:         Prevent double log entry overlap.
GRM.AddToLiveScanQue = function ( index , msg , scanNumber , misc )
    local toAdd = true;

    for i = 1, #GRM.LiveScanQue do
        if GRM.LiveScanQue[i][1] == index and GRM.LiveScanQue[i][2] == msg then
            toAdd = false;
            break;
        end
    end

    if toAdd then
        if misc then
            table.insert ( GRM.LiveScanQue , { index , msg , scanNumber , misc } );
        else
            table.insert ( GRM.LiveScanQue , { index , msg , scanNumber } );
        end;
    end

    return toAdd;
end

-- Method:          GRM.ProcessLiveScanQue()
-- What it Does:    Scans through and completes any of the live changes detected
-- Purpose:         Ensure accurate sync reporting to the logs.
GRM.ProcessLiveScanQue = function()
    if not GRM_G.processingLiveScanQue then
        GRM_G.processingLiveScanQue = true;

        while #GRM.LiveScanQue > 0 do

            if GRM.LiveScanQue[1][1] == 1 then
                GRM.LivePromoteOrDemoteDetection ( GRM.LiveScanQue[1][2] , true , GRM.LiveScanQue[1][3] );
            elseif GRM.LiveScanQue[1][1] == 2 then
                GRM.LivePromoteOrDemoteDetection ( GRM.LiveScanQue[1][2] , false , GRM.LiveScanQue[1][3] );
            elseif GRM.LiveScanQue[1][1] == 5 then
                GRM.LiveLeaveDetection( GRM.LiveScanQue[1][2] , GRM.LiveScanQue[1][3] );
            elseif GRM.LiveScanQue[1][1] == 6 then
                GRM.LiveKickDetection ( GRM.LiveScanQue[1][2] , GRM.LiveScanQue[1][3] );
            elseif GRM.LiveScanQue[1][1] == 7 then
                GRM.KickButtonLogic ( GRM.LiveScanQue[1][2] , GRM.LiveScanQue[1][3] );
            elseif GRM.LiveScanQue[1][1] == 8 then
                GRM.KickButtonLogic ( GRM.LiveScanQue[1][2] , GRM.LiveScanQue[1][3] , GRM.LiveScanQue[1][4] );
            end

            table.remove ( GRM.LiveScanQue , 1 ); -- Just keep removing the first.

        end

        GRM_G.processingLiveScanQue = false;
        GRM_G.CurrentlyScanning = false;

    end
end

-- Method:          GRM.SetNextTrue ( tabloe )
-- What it Does:    It sets the index of a live event check in case they needed to be considered
-- Purpose:         Ensure accurate reporting of live changes.
GRM.SetNextTrue = function ( scanningBlock )

    local isSet = false;
    local num = 0;

    for i = 1 , #scanningBlock do
        if not scanningBlock[i] then
            scanningBlock[i] = true;
            num = i;
            isSet = true;
            break;
        end
    end

    if not isSet then
        table.insert ( scanningBlock , true );
        num = #scanningBlock;
    end

    return scanningBlock , num
end

-- Method:          GRM.SystemMessageLiveDetectionControl ( string )
-- What it Does:    Organizes the promotions, demotions, kicks, joins, leaves for live detection
-- Purpose:         Sometimes the server call to the guild can take several seconds to pull data, even though the system message has already emoted. This will actually parse the system message so as not to need to wait for server callback.
GRM.SystemMessageLiveDetectionControl = function ( msg )
    local result = false;
    if GRM_G.guildName ~= "" then

        local scanNumber = 0;

        -- In case of failure, let's store the messaage
        if string.find ( msg , GRM.L ( "has promoted" ) ) then

            GRM_G.LiveScanningBlock.promoted , scanNumber = GRM.SetNextTrue ( GRM_G.LiveScanningBlock.promoted );
            if not GRM_G.CurrentlyScanning then
                GRM.GuildRoster();
                result = GRM.LivePromoteOrDemoteDetection ( msg , true , scanNumber );
            else
                
                local toAdd = GRM.AddToLiveScanQue ( 1 , msg , scanNumber );
                result = false;

                if not toAdd then
                    table.remove ( GRM_G.LiveScanningBlock.promoted , scanNumber );
                end

                C_Timer.After ( 3 , function()
                    GRM.GuildRoster();                                       -- Initial queries...
                    if GRM_G.BuildVersion >= 30000 then
                        QueryGuildEventLog();
                    end
                end);

            end 

            if result and not GRM.S()["toChat"].promotion then
                result = false;
            end

        elseif string.find ( msg , GRM.L ( "has demoted" ) ) then
            
            GRM_G.LiveScanningBlock.demoted , scanNumber = GRM.SetNextTrue ( GRM_G.LiveScanningBlock.demoted );
            if not GRM_G.CurrentlyScanning then
                GRM.GuildRoster();
                result = GRM.LivePromoteOrDemoteDetection ( msg , false , scanNumber );
            else
                local toAdd = GRM.AddToLiveScanQue ( 2 , msg , scanNumber );
                result = false;

                if not toAdd then
                    table.remove ( GRM_G.LiveScanningBlock.demoted , scanNumber );
                end
            
                C_Timer.After ( 3 , function()
                    GRM.GuildRoster();                                       -- Initial queries...
                    if GRM_G.BuildVersion >= 30000 then
                        QueryGuildEventLog();
                    end
                end);

            end 

            if result and not GRM.S()["toChat"].demotion then
                result = false;
            end

        elseif string.find ( msg , GRM.L ( "joined the guild." ) ) then

            if not GRM_G.OnFirstLoad then
                GRM_G.changeHappenedExitScan = true;
            end

            GRM.GuildRoster();
            if GRM_G.BuildVersion >= 30000 then
                QueryGuildEventLog();
            end
                GRM_G.TempBanSystemMessage = true;
                GRM_G.MainNameSystemMsgControl = true;

            C_Timer.After ( 1 , function()
                GRM_G.TempBanSystemMessage = false;
                GRM_G.MainNameSystemMsgControl = false;
                GRM_G.changeHappenedExitScan = true;
                GRM.LiveJoinDetection ( msg );

            end);
            
        elseif string.find ( msg , GRM.L ( "left the guild." ) ) then
            
            GRM_G.LiveScanningBlock.left , scanNumber = GRM.SetNextTrue ( GRM_G.LiveScanningBlock.left );
            GRM.GuildRoster();
            if not GRM_G.CurrentlyScanning then
                GRM.GuildRoster();
                result = GRM.LiveLeaveDetection( msg , scanNumber );
            else
                local toAdd = GRM.AddToLiveScanQue ( 5 , msg , scanNumber );
                result = false;

                if not toAdd then
                    table.remove ( GRM_G.LiveScanningBlock.left , scanNumber );
                end

                C_Timer.After ( 3 , function()
                    GRM.GuildRoster();                                       -- Initial queries...
                    if GRM_G.BuildVersion >= 30000 then
                        QueryGuildEventLog();
                    end
                end);

            end

            if result and not GRM.S()["toChat"].left then
                result = false;
            end

        elseif string.find ( msg , GRM.L ( "has been kicked" ) ) then
            -- Look at "GRM.GetPlayerKickedFromButton" function for kicks the player does themselves. This just absorbs the ones done by others.
            
            if not string.find ( msg , GRM.SlimName ( GRM_G.addonUser ) , 1 , true ) then
                GRM_G.LiveScanningBlock.kick , scanNumber = GRM.SetNextTrue ( GRM_G.LiveScanningBlock.kick );

                if not GRM_G.CurrentlyScanning then
                    GRM.GuildRoster();
                    result = GRM.LiveKickDetection ( msg , scanNumber );
                else
                    local toAdd = GRM.AddToLiveScanQue ( 6 , msg , scanNumber );
                    result = false;

                    if not toAdd then
                        table.remove ( GRM_G.LiveScanningBlock.kick , scanNumber );
                    end
                end
 
            end
        end

        if result and not GRM.S()["toChat"].left then
            result = false;
        end
    end

    return result;
end

-- Method:          GRM.LiveJoinDetection ( string )
-- What it Does:    Holds the repeatable code to run if a current scan is happening.
-- Purpose:         Cleanup the code so functions aren't too big.
GRM.LiveJoinDetection = function( msg )
        
    local name = GRM.GetParsedJoinPlayerName ( msg );
    if name then

        GRM.CheckForNewPlayer( name );

    end

end

-- Method:          GRM.LivePromoteOrDemoteDetection ( string , bool , int )
-- What it Does:    Checks live event on promotions and demotions and reports on them and updates the database
-- Purpose:         To instantly log these rank event changes to the database.
--                  Note, due to the lack of a server event log in Classic it will be more limited and only function to instant report if you do the action yourself.
GRM.LivePromoteOrDemoteDetection = function( msg , isPromotion , scanNumber )
    local changeRecorded = false;

    -- Controlling the flow of information to either be instant or on delay
    local rankChangeAction = function ( promotedToon , promotingOfficer , newRank )

        local recorded = false;

        if #newRank > 0 then
            local player = GRM.GetPlayer ( promotedToon );

            if player then

                if isPromotion then
                    GRM_G.livePromotedToons[player.name] = newRank;
                else
                    GRM_G.liveDemotedToons[player.name] = newRank;
                end

                recorded = GRM.OnRankChange ( player.rankName , newRank , promotedToon , promotingOfficer );

            end
        end

        return recorded;
    end

    local officer , playerWhoseRankChanged , newRank = "" , "" , "";
    
    if isPromotion then
        officer , playerWhoseRankChanged , newRank = GRM.GetPromotionText ( msg );
    else
        officer , playerWhoseRankChanged , newRank = GRM.GetDeomotionText ( msg );
    end

    if officer ~= nil and playerWhoseRankChanged ~= nil and newRank ~= nil then
        changeRecorded = rankChangeAction( playerWhoseRankChanged , officer , newRank );
    end

    if isPromotion then
        GRM_G.LiveScanningBlock.promoted[scanNumber] = false;
    else
        GRM_G.LiveScanningBlock.demoted[scanNumber] = false;
    end

    return changeRecorded;
end

-- Method:          GRM.LiveLeaveDetection( string , int )
-- What it Does:    Catches the system message that the player just left and then updates their details appropriately
-- purpose:         Instantly report when a player is no longer in the guild. Also to use for your own self-detection.
GRM.LiveLeaveDetection = function( text , scanNumber )

    if GRM_G.ClassicLeftErrorProtect ~= text then
        GRM_G.ClassicLeftErrorProtect = text;
        local unitName , playerKicked , timePassed , logEntryMetaData , listOfAlts , mainName , publicNote , officerNote , date , isFoundInEventLog , isNoLongerOnServer , isLiveDetection , playerLevel , customNote = GRM.RecordLeftGuildChanges ( GRM.GetParsedplayerName ( text ) , true );

        local logReportWithTime , logReport = GRM.GetLeftOrKickString ( unitName , playerKicked , timePassed , logEntryMetaData , listOfAlts , mainName , publicNote , officerNote , date , isFoundInEventLog , isNoLongerOnServer , isLiveDetection , playerLevel , customNote );
        
        if GRM.S()["toChat"].left then
            GRM.PrintLog ( { 10 , logReport } );
        end
        GRM.AddLog ( { 10 , logReportWithTime , unitName , playerKicked , timePassed , logEntryMetaData , listOfAlts , mainName , publicNote , officerNote , date } );

        GRM.RefreshSelectHybridFrames ( true , true , true , true );
        
        if GRM_UI.GRM_RosterFrame and GRM_UI.GRM_RosterFrame:IsVisible() then
            GRM_R.RefreshRosterName();
        end

        GRM_G.LiveScanningBlock.left[scanNumber] = false;

        return true;
    else
        return false;
    end
end

-- Method:          GRM.GetParsedplayerName ( string )
-- What it Does:    Parses out the Left Player message for all 11 clients
-- Purpose:         The Taiwan and Chinese Mandarin need to be parsed differently.
GRM.GetParsedplayerName = function ( text )
    local result = "";

    if GRM_G.Region == "zhCN" then
        result = string.sub ( text , 1 , string.find ( text , "离" ) - 1 );
    elseif GRM_G.Region == "zhTW" then
        result = string.sub ( text , 1 , string.find ( text , "離" ) - 1 );
    else
        result = string.sub ( text , 1 , string.find ( text , " " ) - 1 );
    end

    return GRM.AppendServerName ( result );
end

-- Method:          GRM.GetParsedJoinPlayerName ( string )
-- What it Does:    Parses out the joined Player message for all 11 clients
-- Purpose:         To live determine the name of the player that joined the guild
GRM.GetParsedJoinPlayerName = function ( text )
    local pattern = string.gsub ( ERR_GUILD_JOIN_S , "%%s" , "([%%S]+)" );
    local playerJoined = string.match ( text , pattern );

    return GRM.AppendServerName ( playerJoined );
end

-- Method:          GRM.GetParsedKickPlayerNames ( string )
-- What it Does:    Returns both the kicked and the kicker names from the parsed system message 
-- Purpose:         To cleanup and efficiently handle LIVE chat reporting when a player is kicked.
GRM.GetParsedKickPlayerNames = function ( text )
    local playerThatWasKicked = "";
    local playerThatKicked = "";

    if GRM_G.Region == "deDE" then
        playerThatWasKicked = string.sub ( text , 1 , string.find ( text , " " ) - 1 );
        local start = select ( 2 , string.find ( text , "wurde von " , 1 , true ) ) + 1;
        playerThatKicked = string.sub ( text , start , start + ( string.find ( string.sub ( text , start ) , " " ) - 1 ) );

    elseif GRM_G.Region == "ptBR" then

        local start = select ( 2 , string.find ( text , "personagem " , 1 , true ) ) + 1;
        playerThatWasKicked = string.sub ( text , start , string.find ( text , " foi" , 1 , true ) - 1 ); 
        start = 0;
        for i = #text , 1 , -1 do
            if string.sub ( text , i , i ) == " " then
                start = i + 1;      -- add 1 because we want the letter immediately after.
                break;
            end
        end
        playerThatKicked = string.sub ( text , start , #text - 1 );

    elseif GRM_G.Region == "koKR" then
        if GRM_G.BuildVersion < 80000 then
            playerThatKicked = string.sub ( text , 1 , string.find ( text , "|1이" , 1 , true ) - 1 );
            local start = string.find ( text , " " ) + 1;
            playerThatWasKicked = string.sub ( text , start , string.find ( text , "|1을" , 1 , true ) - 1 );

        else
            playerThatKicked = string.sub ( text , 1 , string.find ( text , " 님이" , 1 , true ) - 1 );
            local start = select ( 2 , string.find ( text , "님이 " ) ) + 1;
            playerThatWasKicked = string.sub ( text , start , string.find ( text , " 님을" , 1 , true ) - 1 );
        end
        
    elseif GRM_G.Region == "ruRU" then
        playerThatKicked = string.sub ( text , 1 , string.find ( text , " " ) - 1 );
        playerThatWasKicked = string.sub ( text , string.find ( text , "(" , 1 , true ) + 1 , string.find ( text , ")" , 1 ,  true ) - 1 );

    else
        
        local pattern = string.gsub ( ERR_GUILD_REMOVE_SS , "%%s" , "([%%S]+)" );
        playerThatWasKicked, playerThatKicked = string.match ( text , pattern );

    end

    return GRM.AppendServerName ( playerThatWasKicked ) , GRM.AppendServerName ( playerThatKicked );
end

----------------------
-- END LIVE DETECT ---
----------------------

-- Method:          GRM.RemoveBan( int , boolean , boolean , int )
-- What it Does:    Just what it says... it removes the ban from the player and wipes the data clean. No history of ban is stored
-- Purpose:         Necessary for forgiveness or accidental banning.
GRM.RemoveBan = function ( name , onPopulate , personWhoRemovedIt )
    local player = GRM.GetPlayer ( name );

    if player then
        player.bannedInfo = nil;
        player.bannedInfo = { false , time() , true , personWhoRemovedIt }
        player.reasonBanned = "";

        GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailBannedText1:Hide();
        GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailBannedIgnoreButton:Hide();

        -- On populate is referring to the check for when it is on mouseover... no need to check this if not.
        if onPopulate and GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame:IsVisible() then
            -- Refresh the frames:
            if GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_CoreBanListScrollChildFrame.allFrameButtons ~= nil then
                for i = 1 , #GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_CoreBanListScrollChildFrame.allFrameButtons do
                    GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_CoreBanListScrollChildFrame.allFrameButtons[i][1]:UnlockHighlight();
                end
            end
            GRM.RefreshBanListFrames();
        end
    end
end

-- Method:          GRM.UnBanplayer ( string , string )
-- What it Does:    Unbans a listed player in the ban list
-- Purpose:         To be able to control who is banned and not banned in the guild.
GRM.UnBanplayer = function ( name , personWhoRemovedIt )
    local isFound = false;
    local player = GRM.GetFormerPlayer ( name );

    if player then
        isFound = true;
        player.bannedInfo = nil;
        player.bannedInfo = { false , time() , true , personWhoRemovedIt }
        player.reasonBanned = "";
    end
    return isFound;
end

-- Method:          GRM.BanListUnban ( string , string )
-- What it Does:    Unbans the player selected on the core ban list frame upon button push
-- Purpose:         Good to control who is and isn't on the ban list...
GRM.BanListUnban = function ( name , personWhoRemovedIt )
    -- Check the players that left first!
    -- if the player was not found in the left player's list, then we know he is currently in the guild but on ban list!!!
    if not GRM.UnBanplayer ( name , personWhoRemovedIt ) then
        GRM.RemoveBan ( name , false , personWhoRemovedIt );
    end

    -- Refresh the frames:
    if GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_CoreBanListScrollChildFrame.allFrameButtons ~= nil then
        for i = 1 , #GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_CoreBanListScrollChildFrame.allFrameButtons do
            GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_CoreBanListScrollChildFrame.allFrameButtons[i][1]:UnlockHighlight();
        end
    end
    GRM.RefreshBanListFrames();
end

-------------------------------
----- UI SCRIPTING LOGIC ------
----- ALL THINGS UX ARE HERE --
-------------------------------

-- Method:          GRM.GRM.PopulateMemberDetails ( string )
-- What it Does:    Builds the details for the core MemberInfoFrame
-- Purpose:         Iterate on each mouseover... Furthermore, this is being kept in "Local" for even the most infinitesimal cost-saving on resources
--                  by not indexing it in a table. Buried in it will be mostly non-compartmentalized logic, few function calls.
GRM.PopulateMemberDetails = function( handle , memberInfo )
    if handle ~= "" and handle ~= nil and GRM_G.guildName ~= "" and IsInGuild() then              -- If the handle is failed to be returned, it is returned as an empty string. Just logic to not populate if on failure.
        GRM_G.rankDateSet = false;        -- resetting tracker

        local player = GRM.GetPlayer ( handle );
        if player then
            local fullName , zone , isOnline , _ ;

            if memberInfo then
                if memberInfo.guid ~= nil then
                    zone = memberInfo.zone;
                    if memberInfo.presence ~= 3 then
                        isOnline = true;
                    else
                        isOnline = false;
                    end
                else
                    local found = false;
                    for i = 1 , GRM.GetNumGuildies() do
                        fullName, _, _, _, _, zone, _, _, isOnline = GetGuildRosterInfo ( i );
                        if fullName == handle then
                            found = true;
                            break;
                        end
                    end
                    if not found then
                        zone = nil;
                    end

                end
            else
                local found = false;
                for i = 1 , GRM.GetNumGuildies() do
                    fullName, _, _, _, _, zone, _, _, isOnline = GetGuildRosterInfo ( i );
                    if fullName == handle then
                        found = true;
                        break;
                    end
                end
                if not found then
                    zone = nil;
                end
            end

            if zone ~= nil and zone ~= "" then
                player.isOnline = isOnline;
                if player.zone ~= zone then
                    player.timeEnteredZone = time();    -- Resets the time
                end
                player.zone = zone;
            end

            --- CLASS
            local classColors = GRM.GetClassColorRGB ( player.class );
            GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailNameText:SetTextColor ( classColors[1] , classColors[2] , classColors[3] , 1.0 );
            
            -- FACTION ICON
            GRM.FactionIcon ( player.faction );

            -- HARDCORE MODE
            GRM.DeathStatus ( player );

            -- PLAYER NAME
            -- Let's scale the name too!            
            GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailNameText:SetText ( GRM.SlimName ( handle ) );
            local nameHeight = 16;
            GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailNameText:SetFont ( GRM_G.FontChoice , GRM_G.FontModifier + nameHeight );        -- Reset size back to 16 just in case previous fontstring was altered 
            while ( GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailNameText:GetWidth() > 120 ) do
                nameHeight = nameHeight - 0.1;
                GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailNameText:SetFont ( GRM_G.FontChoice , GRM_G.FontModifier + nameHeight );
            end

            -- IS MAIN
            if player.isMain then
                GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailMainText:Show();
                GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailAltText:Hide();
            else
                GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailMainText:Hide();

                if GRM.PlayerIsAnAlt ( player ) then
                    GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailAltText:Show();
                else
                    GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailAltText:Hide();
                end
            end

            --- LEVEL
            local levelAndMythicText = "";

            if GRM.S().showLevel then

                if not GRM.S().showLevelMaxOnly or ( GRM.S().showLevelMaxOnly and player.level < GRM_G.LvlCap ) then
                    if GRML.Languages[GRM.S().selectedLang] == "Russian" or GRML.Languages[GRM.S().selectedLang] == "Korean" then
                        levelAndMythicText = tostring ( player.level ) .. GRM.L ( "Level: " );
                    else
                        levelAndMythicText = GRM.L ( "Level: " ) .. player.level;
                    end
                end
            end

            -- MYTHINC+ SCORE
            if GRM_G.BuildVersion >= 80000 and GRM.S().showMythicRating and player.level == GRM_G.LvlCap then

                if levelAndMythicText ~= "" then
                    levelAndMythicText = levelAndMythicText .. " | " .. GRM.L ( "M+ Rating:" ) .. "  " .. GRM.GetMythicRatingToMatchRaiderIO ( player.MythicScore ) .. player.MythicScore .. "|r" ;
                else
                    levelAndMythicText = GRM.L ( "M+ Rating:" ) .. "  " .. GRM.GetMythicRatingToMatchRaiderIO ( player.MythicScore ) .. player.MythicScore .. "|r";
                end
            end

            GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailLevel:SetText ( levelAndMythicText );

            -- Rank Text Info...
            GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailRankTxt:SetText ( "\"" .. player.rankName .. "\"");
            GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailRankTxt:Show();

            -- ZONE INFORMATION
            if not GRM_UI.GRM_MemberDetailMetaData.GRM_DateSubmitButton:IsVisible() then
                if player.isOnline then
                    if player.zone ~= nil then
                        GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailMetaZoneInfoZoneText:SetText ( player.zone );                                     -- Zone
                        GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailMetaZoneInfoTimeText2:SetText ( GRM.GetTimePassedInZone ( player.timeEnteredZone ) );              -- Time Passed
                    end
                    GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailMetaZoneInfoText:Show();
                    GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailMetaZoneInfoZoneText:Show();
                    GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailMetaZoneInfoTimeText1:Show();
                    GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailMetaZoneInfoTimeText2:Show();
                else
                    GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailMetaZoneInfoText:Hide();
                    GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailMetaZoneInfoZoneText:Hide();
                    GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailMetaZoneInfoTimeText1:Hide();
                    GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailMetaZoneInfoTimeText2:Hide();
                end


                --RANK PROMO DATE
                if player.promoteDateUnknown then
                    GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailRankDateTxt:SetText ( GRM.L ( "Promoted:" ) .. " " .. GRM.L ( "Unknown" ) );
                    GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailRankDateTxt:Show();
                    GRM_UI.GRM_MemberDetailMetaData.GRM_SetPromoDateButton:Hide();
                    GRM_G.rankDateSet = true;
                else
                    if #player.rankHist[1][5] == 1 then      --- Promotion has never been recorded!
                        GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailRankDateTxt:Hide();
                        GRM_UI.GRM_MemberDetailMetaData.GRM_SetPromoDateButton:Show();
                    else
                        GRM_UI.GRM_MemberDetailMetaData.GRM_SetPromoDateButton:Hide();
                        GRM_G.rankDateSet = true;
                        GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailRankDateTxt:SetText ( GRM.DateUntrustedTag ( player.rankHist[1][7] ) .. GRM.L ( "Promoted:" ) .. " " .. GRM.FormatTimeStamp ( { player.rankHist[1][2] , player.rankHist[1][3] , player.rankHist[1][4] } , false , false ) );
                        GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailRankDateTxt:Show();
                    end
                end

                -- JOIN DATE
                if player.joinDateUnknown then
                    GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailJoinDateButton:Hide();
                    GRM_UI.GRM_MemberDetailMetaData.GRM_JoinDateText:SetText ( GRM.L ( "Unknown" ) );
                    GRM_UI.GRM_MemberDetailMetaData.GRM_JoinDateText:Show();
                else
                    if player.joinDateHist[1][1] == 0 then
                        GRM_UI.GRM_MemberDetailMetaData.GRM_JoinDateText:Hide();
                        GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailJoinDateButton:Show();
                    else
                        GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailJoinDateButton:Hide();

                        GRM_UI.GRM_MemberDetailMetaData.GRM_JoinDateText:SetText ( GRM.DateUntrustedTag ( player.joinDateHist[1][6] ) .. GRM.FormatTimeStamp ( { player.joinDateHist[1][1] , player.joinDateHist[1][2] , player.joinDateHist[1][3] } , false ) );
                        GRM_UI.GRM_MemberDetailMetaData.GRM_JoinDateText:Show();
                    end
                end

                -- Birthday
                if GRM.S().showBDay then
                    -- Title should always be here
                    GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailBirthdayTitleText:Show();
                    if player.birthdayUnknown then
                        GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailBirthdayButton:Hide();
                        GRM_UI.GRM_MemberDetailMetaData.GRM_BirthdayText:SetText ( GRM.L ( "Unknown" ) );
                        GRM_UI.GRM_MemberDetailMetaData.GRM_BirthdayText:Show();
                    else
                        -- Checking button vs text
                        if player.events[2][1][1] ~= 0 then
                            GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailBirthdayButton:Hide();
                            GRM_UI.GRM_MemberDetailMetaData.GRM_BirthdayText:SetText ( GRM.FormatTimeStamp ( player.events[2][3] , false , true ) );
                            GRM_UI.GRM_MemberDetailMetaData.GRM_BirthdayText:Show();
                        else
                            GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailBirthdayButton:Show();
                            GRM_UI.GRM_MemberDetailMetaData.GRM_BirthdayText:Hide();
                        end
                    end
                else
                    GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailBirthdayButton:Hide();
                    GRM_UI.GRM_MemberDetailMetaData.GRM_BirthdayText:Hide();
                    GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailBirthdayTitleText:Hide();
                end
            end

            -- PLAYER NOTE AND OFFICER NOTE EDIT BOXES
            if not GRM_UI.GRM_MemberDetailMetaData.GRM_PlayerNoteEditBox:HasFocus() and not GRM_UI.GRM_MemberDetailMetaData.GRM_PlayerOfficerNoteEditBox:HasFocus() and not GRM_UI.GRM_MemberDetailMetaData.GRM_CustomNoteEditBoxFrame.GRM_CustomNoteEditBox:HasFocus() then
                local finalNote = GRM.L ( "Click here to set a Public Note" );
                local finalONote = GRM.L ( "Click here to set an Officer's Note" );
                GRM_UI.GRM_MemberDetailMetaData.GRM_PlayerNoteEditBox:Hide();
                GRM_UI.GRM_MemberDetailMetaData.GRM_PlayerOfficerNoteEditBox:Hide();

                -- Set Public Note if is One
                if player.note ~= nil and player.note ~= "" then
                    finalNote = player.note;
                end
                GRM_UI.GRM_MemberDetailMetaData.GRM_noteFontString1:SetText ( finalNote );
                if ( GRM.CanEditPublicNote() or ( GRM_G.BuildVersion >= 80000 and handle == GRM_G.addonUser ) ) then
                    if finalNote ~= GRM.L ( "Click here to set a Public Note" ) then
                        GRM_UI.GRM_MemberDetailMetaData.GRM_PlayerNoteEditBox:SetText( finalNote );
                    else
                        GRM_UI.GRM_MemberDetailMetaData.GRM_PlayerNoteEditBox:SetText( "" );
                    end
                elseif finalNote == GRM.L ( "Click here to set a Public Note" ) then
                    GRM_UI.GRM_MemberDetailMetaData.GRM_noteFontString1:SetText ( GRM.L ( "Unable to Edit Public Note at Rank" ) );
                end

                -- Set O Note
                if GRM.CanViewOfficerNote() == true then
                    if player.officerNote ~= nil and player.officerNote ~= "" then
                        finalONote = player.officerNote;
                    end
                    if finalONote == GRM.L ( "Click here to set an Officer's Note" ) and GRM.CanEditOfficerNote() ~= true then
                        finalONote = GRM.L ( "Unable to Edit Officer Note at Rank" );
                    end
                    GRM_UI.GRM_MemberDetailMetaData.GRM_noteFontString2:SetText ( finalONote );
                    if finalONote ~= GRM.L ( "Click here to set an Officer's Note" ) then
                        GRM_UI.GRM_MemberDetailMetaData.GRM_PlayerOfficerNoteEditBox:SetText( finalONote );
                    else
                        GRM_UI.GRM_MemberDetailMetaData.GRM_PlayerOfficerNoteEditBox:SetText( "" );
                    end
                else
                    GRM_UI.GRM_MemberDetailMetaData.GRM_noteFontString2:SetText ( GRM.L ( "Unable to View Officer Note at Rank" ) );
                end

                -- Custom Note CheckBox
                if player.customNote[1] then
                    GRM_UI.GRM_MemberDetailMetaData.GRM_CustomNoteEditBoxFrame.GRM_CustomNoteSyncMetaCheckBox:SetChecked( true );
                else
                    GRM_UI.GRM_MemberDetailMetaData.GRM_CustomNoteEditBoxFrame.GRM_CustomNoteSyncMetaCheckBox:SetChecked( false );
                end
                if GRM.S().syncEnabled and GRM.S().syncCustomNote then
                    GRM_UI.GRM_MemberDetailMetaData.GRM_CustomNoteEditBoxFrame.GRM_CustomNoteSyncMetaCheckBox:Enable();
                    GRM_UI.GRM_MemberDetailMetaData.GRM_CustomNoteEditBoxFrame.GRM_CustomNoteSyncMetaCheckBox.GRM_CustomNoteMetaCheckBoxText:SetTextColor ( 1.0 , 0.82 , 0.0 , 1.0 );
                else
                    -- sync is disabled, so disable the button...
                    GRM_UI.GRM_MemberDetailMetaData.GRM_CustomNoteEditBoxFrame.GRM_CustomNoteSyncMetaCheckBox.GRM_CustomNoteMetaCheckBoxText:SetTextColor ( 0.5 , 0.5 , 0.5 , 1 );
                    GRM_UI.GRM_MemberDetailMetaData.GRM_CustomNoteEditBoxFrame.GRM_CustomNoteSyncMetaCheckBox:Disable();
                end
                -- Set Custom Note details
                GRM.BuildCustomNoteScrollFrame ( player.customNote[6] );
                
                GRM_UI.GRM_MemberDetailMetaData.GRM_noteFontString2:Show();
                GRM_UI.GRM_MemberDetailMetaData.GRM_noteFontString1:Show();

            end

            -- Last Online
            if player.isOnline then
                GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailLastOnlineTxt:SetText ( GRM.L ( "Online" ) );
            else
                GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailLastOnlineTxt:SetText ( GRM.HoursReport ( player.lastOnline ) );
            end

            -- Reputation
            if GRM.S().viewGuildRep and GRM_G.BuildVersion >= 40000 then  -- Cataclysm feature added
                GRM_UI.GRM_MemberDetailMetaData.GRM_ReputationLevelText:SetText ( GRM.GetReputationTextLevel ( player.guildRep , true ) );
                GRM_UI.GRM_MemberDetailMetaData.GRM_ReputationLevelText:Show();
            else
                GRM_UI.GRM_MemberDetailMetaData.GRM_ReputationLevelText:Hide();
            end

            -- Group Invite Button -- Setting script here
            if player.isOnline and handle ~= GRM_G.addonUser and not GRM_UI.GRM_MemberDetailMetaData.GRM_CustomNoteEditBoxFrame.GRM_CustomNoteEditBox:HasFocus() then
                GRM.SetGroupInviteButton ( handle );
                GRM_UI.GRM_MemberDetailMetaData.GRM_GroupInviteButton:Show();
                GRM_UI.GRM_MemberDetailMetaData.GRM_SafeFromRulesButton:ClearAllPoints();
                GRM_UI.GRM_MemberDetailMetaData.GRM_SafeFromRulesButton:SetPoint ( "LEFT" , GRM_UI.GRM_MemberDetailMetaData.GRM_GroupInviteButton , "RIGHT" , 5 , 0 );
                GRM_UI.GRM_MemberDetailMetaData.GRM_SafeFromRulesButton:Show();
            elseif not player.isOnline or handle == GRM_G.addonUser then
                GRM_UI.GRM_MemberDetailMetaData.GRM_GroupInviteButton:Hide();

                if handle ~= GRM_G.addonUser and not GRM_UI.GRM_MemberDetailMetaData.GRM_CustomNoteEditBoxFrame.GRM_CustomNoteEditBox:HasFocus() then
                    GRM_UI.GRM_MemberDetailMetaData.GRM_SafeFromRulesButton:ClearAllPoints();
                    GRM_UI.GRM_MemberDetailMetaData.GRM_SafeFromRulesButton:SetPoint ( "BOTTOMLEFT" , GRM_UI.GRM_MemberDetailMetaData , "BOTTOMLEFT" , 15 , 13 );
                    GRM_UI.GRM_MemberDetailMetaData.GRM_SafeFromRulesButton:Show();
                else
                    GRM_UI.GRM_MemberDetailMetaData.GRM_SafeFromRulesButton:Hide();
                end
            end

            -- IF PLAYER WAS PREVIOUSLY BANNED AND REJOINED
            -- Player was previous banned and rejoined logic! This will unban the player.
            local isGuildieBanned = player.bannedInfo[1];
            if isGuildieBanned and handle ~= GRM_G.addonUser then
                GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailBannedIgnoreButton:SetScript ( "OnClick" , function ( _ , button ) 
                    if button == "LeftButton" then
                        GRM.RemoveBan ( handle , true , GRM_G.addonUser );

                        -- Send the unban out for sync'd players
                        if GRM.S().syncEnabled and GRM.S().syncBanList then
                            GRMsync.SendMessage ( "GRM_SYNC" , GRM_G.PatchDayString .. "?GRM_UNBAN?" .. GRM.S().syncRank .. "?" .. tostring ( GRM.S().syncRankBanList ) .. "?" .. player.name .. "?" , "GUILD");
                        end
                        -- Message
                        local classColorHex = GRM.GetClassColorRGB ( player.class , true )
                        GRM.Report ( GRM.L ( "{name} has been Removed from the Ban List." ,  classColorHex .. player.name .. "|r" ) );
                    end
                end);
                
                GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailBannedText1:Show();
                GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailBannedIgnoreButton:Show();
            else
                GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailBannedText1:Hide();
                GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailBannedIgnoreButton:Hide();
            end

            -- ALTS 
            GRM.PopulateAltFrames ( handle );

            -- Font note handling
            GRM_UI.ReconfigureNoteFonts();

        end
    end
end

-- Method:          GRM.FactionIcon ( ind );
-- What it Does:    Returns the Horde and Alliance faction colors
-- Purpose:         In 10.1 cross faction guilds became a thing, so this allows players to tag with a faction symbol.
GRM.FactionIcon = function ( index )
    if GRM.S().showFaction and not ( index == -1 ) then
        if index == 0 then
            GRM_UI.GRM_MemberDetailMetaData.GRM_HordeIconTexture:Show();
            GRM_UI.GRM_MemberDetailMetaData.GRM_AllianceIconTexture:Hide();
        else
            GRM_UI.GRM_MemberDetailMetaData.GRM_AllianceIconTexture:Show();
            GRM_UI.GRM_MemberDetailMetaData.GRM_HordeIconTexture:Hide();
        end
    else
        GRM_UI.GRM_MemberDetailMetaData.GRM_HordeIconTexture:Hide();
        GRM_UI.GRM_MemberDetailMetaData.GRM_AllianceIconTexture:Hide();
    end
end

-- Method:          GRM.DeathStatus ( playerObject )
-- What it Does:    Controls the texture visibility in the mouseover window
-- Purpose:         Hardcore mode support indicates player is DEAD.
GRM.DeathStatus = function ( player )
    if GRM_G.HardcoreActive and player.HC.isDead then
        GRM_UI.GRM_MemberDetailMetaData.GRM_DeathTexture:Show();
        GRM_UI.GRM_MemberDetailMetaData.GRM_ClearDeathButton:Show();

        GRM_UI.GRM_MemberDetailMetaData.GRM_RIPtext:SetText ( GRM.L ( "R.I.P. - {custom1}" , nil , nil , nil , GRM.FormatTimeStamp ( { player.HC.timeOfDeath[1] , player.HC.timeOfDeath[2] , player.HC.timeOfDeath[3] } ) ) );
        GRM_UI.GRM_MemberDetailMetaData.GRM_RIPtext:SetTextColor ( GRM.S().logColor[15][1] , GRM.S().logColor[15][2] , GRM.S().logColor[15][3] );
        GRM_UI.GRM_MemberDetailMetaData.GRM_RIPtext:Show();
    else
        GRM_UI.GRM_MemberDetailMetaData.GRM_DeathTexture:Hide();
        GRM_UI.GRM_MemberDetailMetaData.GRM_ClearDeathButton:Hide();
        GRM_UI.GRM_MemberDetailMetaData.GRM_RIPtext:Hide();
    end
end

-- Method:          GRM.ClearAllFrames( boolean )
-- What it Does:    Ensures frames are properly reset upon frame reload...
-- Purpose:         Logic time-saver for minimal costs... why check status of them all when you can just disable and build anew on each reload?
GRM.ClearAllFrames = function( includingMeta )
    if includingMeta then
        if GRM_UI.GRM_MemberDetailMetaData:IsVisible() then
            GRM_UI.GRM_MemberDetailMetaData:Hide();
            GRM_G.currentName = "";
        end
    end
    GRM_UI.GRM_MemberDetailMetaData.GRM_MonthDropDownMenuSelected:Hide();
    GRM_UI.GRM_MemberDetailMetaData.GRM_YearDropDownMenuSelected:Hide();
    GRM_UI.GRM_MemberDetailMetaData.GRM_DayDropDownMenuSelected:Hide();
    GRM_UI.GRM_MemberDetailMetaData.GRM_DateSubmitButton:Hide();
    GRM_UI.GRM_MemberDetailMetaData.GRM_DateSubmitCancelButton:Hide();
    GRM_UI.GRM_MemberDetailMetaData.GRM_NoteCount:Hide();
    GRM_UI.GRM_MemberDetailMetaData.GRM_CoreAltFrame:Hide();
    GRM_UI.GRM_MemberDetailMetaData.GRM_altDropDownOptions:Hide();
    GRM_UI.GRM_MemberDetailMetaData.GRM_MouseOverStatusFrame:Hide();
    GRM_UI.GRM_MemberDetailMetaData.GRM_MouseOverDateStatusFrame:Hide();
    GRM_UI.GRM_MemberDetailMetaData.GRM_CoreAltFrame.GRM_AddAltEditFrame:Hide();
    GRM_UI.GRM_MemberDetailMetaData.GRM_SyncJoinDateSideFrame:Hide();
    GRM_UI.GRM_MemberDetailMetaData.GRM_ConfirmCustomNoteButton:Hide();
    GRM_UI.GRM_MemberDetailMetaData.GRM_CancelCustomNoteButton:Hide();
    GRM_UI.GRM_MemberDetailMetaData.GRM_AltGroupingScrollBorderFrame:Hide();
    GRM_UI.GRM_MemberDetailMetaData.GRM_CustomNoteEditBoxFrame.GRM_CustomNoteEditBox:ClearFocus();
    GRM_UI.GRM_MemberDetailMetaData.GRM_PlayerNoteEditBox:ClearFocus();
    GRM_UI.GRM_MemberDetailMetaData.GRM_PlayerOfficerNoteEditBox:ClearFocus();
    GRM_UI.GRM_OfficerNoteTooltip:Hide();
    GRM_UI.GRM_MemberDetailMetaData.GRM_CoreAltFrame.GRM_CoreAltScrollFrameSlider:Hide();
    GRM_UI.GRM_MemberDetailMetaData.GRM_CustomNoteEditBoxFrame.GRM_CustomNoteScrollFrameSlider:Hide();
    GRM_UI.GRM_MemberDetailMetaData.GRM_MacroToolIgnoreListSettingsFrame:Hide();
end

-- Method:          GRM.ClearResetFramesOnTabChange()
-- What it Does:    Resets the frames when you are tabbing back and forth
-- Purpose:         Cleaner UI transition experience. Also, no need to keep player name up when the roster screen is gone.
GRM.ClearResetFramesOnTabChange = function()
    if GRM_UI.GRM_MemberDetailMetaData:IsVisible() then
        GRM_UI.GRM_MemberDetailMetaData:Hide() -- this will also trigger to clear all frames GRM.ClearAllFrames()
    end

    if GRM_UI.MemberDetailFrame and GRM_UI.MemberDetailFrame:IsVisible() then
        GRM_UI.MemberDetailFrame:Hide();
    end
end

-- Method:          GRM.SubFrameCheck()
-- What it Does:    Checks the core main frames, if they are open... and hides them
-- Purpose:         Questionable at this time... I might rewrite it with just 4 lines... It serves its purpose now
GRM.SubFrameCheck = function()
    -- wipe the frames...
    if GRM_UI.GRM_MemberDetailMetaData.GRM_DateSubmitCancelButton:IsVisible() then
        GRM_UI.GRM_MemberDetailMetaData.GRM_DateSubmitCancelButton:Click();
    end
    if GRM_UI.GRM_MemberDetailMetaData.GRM_CoreAltFrame.GRM_AddAltEditFrame:IsVisible() then
        GRM_UI.GRM_MemberDetailMetaData.GRM_CoreAltFrame.GRM_AddAltEditFrame:Hide();
    end
    if GRM_UI.GRM_MemberDetailMetaData.GRM_NoteCount:IsVisible() then
        GRM_UI.GRM_MemberDetailMetaData.GRM_NoteCount:Hide();
    end
    if GRM_UI.GRM_MemberDetailMetaData.GRM_MacroToolIgnoreListSettingsFrame:IsVisible() then
        GRM_UI.GRM_MemberDetailMetaData.GRM_MacroToolIgnoreListSettingsFrame:Hide();
    end
    GRM_UI.GRM_MemberDetailMetaData.GRM_PlayerNoteEditBox:ClearFocus();
    GRM_UI.GRM_MemberDetailMetaData.GRM_PlayerOfficerNoteEditBox:ClearFocus();
    GRM_UI.GRM_MemberDetailMetaData.GRM_AltGroupingScrollBorderFrame:Hide();
    GRM_UI.GRM_MemberDetailMetaData.GRM_CustomNoteEditBoxFrame.GRM_CustomNoteEditBox:ClearFocus();
    GRM_UI.GRM_MemberDetailMetaData.GRM_altDropDownOptions:Hide();
    GRM_UI.GRM_MemberDetailMetaData.GRM_MouseOverStatusFrame:Hide();
    GRM_UI.GRM_MemberDetailMetaData.GRM_MouseOverDateStatusFrame:Hide();
    GRM_UI.GRM_MemberDetailMetaData.GRM_SyncJoinDateSideFrame:Hide();
end

-- Method:          GRM.SelectPlayerOnRoster ( string )
-- What it Does:    If the guild roster window is open, this will jump to the player anywhere in the roster, online or offline, and bring up their metadata window
-- Purpose:         Useful for when a player wants to click and alt rather than have to scan through the roster for them.
GRM.SelectPlayerOnRoster = function ( playerName )
    if GRM_UI.MemberDetailFrame:IsVisible() then
        GRM_UI.MemberDetailFrame:Hide();
    end

    if GuildFrame and GRM_UI.MemberDetailFrameClassic:IsVisible() then
        GRM_UI.MemberDetailFrameClassic:Hide();
    end
    GRM_UI.GRM_MemberDetailMetaData.GRM_PlayerNoteEditBox:ClearFocus();
    GRM_UI.GRM_MemberDetailMetaData.GRM_PlayerOfficerNoteEditBox:ClearFocus();
    GRM_UI.GRM_MemberDetailMetaData.GRM_CustomNoteEditBoxFrame.GRM_CustomNoteEditBox:ClearFocus();
    GRM_G.currentName = playerName;
    GRM_G.RosterSelection = GRM.GetRosterSelectionID ( playerName );
    GRM_G.pause = false;
    GRM.ClearAllFrames( false );
    GRM.PopulateMemberDetails ( playerName );
    GRM_G.pause = true;
end

-- Method:          GRM.DateUntrustedTag ( bool )
-- What it Does:    Adds a tag in front of a date indicating it is not valid. Returns also the boolean of if it is trusted or not.
-- Purpose:         Notify you that you may need to manually update the date.
GRM.DateUntrustedTag = function( isVerified )
    local result = "";
    
    if not isVerified then
        result = "|cffff0000!!|r";
    end

    return result;
end

-------------------------------
-- BANNING LOGIC AND METHODS --
-------------------------------

-- Method:          GRM.GetPlayerWhoBanned ( string , boolean )
-- What it Does:    Returns the name of the player who banned the given toon, if they are banned at least.
-- Purpose:         Mostly for use in the tooltip on the mouseover of the ban buttons to say who banned the player.
GRM.GetPlayerWhoBanned = function ( name , isInGuild )
    local result = "";
    local player;

    if isInGuild then
        player = GRM.GetPlayer ( name );
    else
        player = GRM.GetFormerPlayer (name );
    end

    if player then
        if player.bannedInfo[1] and player.bannedInfo[4] ~= "" then  -- No point in stating who banned them if they don't currently have a ban
            result = player.bannedInfo[4];
        end
    end

    return result;
end

-- Method:          GRM.GetBannedPlayersWithGUIDs()
-- What it Does:    Compiles a list of all players that are banned with GUIDs into a 2d array
-- Purpose:         For use on easy re-checking of players' GUID to see if the banned player is no longer on the server
GRM.GetBannedPlayersWithGUIDs = function()
    local result = {};

    for _ , player in pairs ( GRM.GetGuild() ) do
        if type ( player ) == "table" then

            if player.bannedInfo[1] and player.GUID ~= nil and player.GUID ~= "" then
                table.insert ( result , { player.name , player.GUID } );
            end
        end
    end

    for _ , player in pairs ( GRM.GetFormerMembers() ) do
        if type ( player ) == "table" then

            if player.bannedInfo[1] and player.GUID ~= nil and player.GUID ~= "" then
                table.insert ( result , { player.name , player.GUID } );
            end
        end
    end

    return result;
end

-- Method:          GRM.GetBannedPlayersStillInGuild()
-- What it Does:    Returns a list of players currently in the guild that are banned, with their accompanying metadata.
-- Purpose:         Collect more than just the count, but get the player metadata too
GRM.GetBannedPlayersStillInGuild = function()
    local playerDetails = {};
    local guildData = GRM.GetGuild();

    for _ , player in pairs ( guildData ) do
        if type ( player ) == "table" then
            if player.bannedInfo[1] then
                table.insert ( playerDetails  , { player.name , player.class , player.bannedInfo[2] , player.rankName , player.rankIndex , player.reasonBanned , true , player.isUnknown , player.GUID } );
            end
        end
    end
    return playerDetails;
end

-- Method:          GRM.GetListBannedAndUnbannedPlayers ( guildData )
-- What it Does:    Pulls the list of all players banned and unbanned.
-- Purpose:         For sync use - only need to compare timestamp. If not the same, then will tag it as needed to be shown. 
GRM.GetListBannedAndUnbannedPlayers = function( guildAndFormer )
    -- data = { guildData , leftGuildData } -- temp files to scan through.
    local result = {};
    local data = guildAndFormer or { GRM.GetGuild() , GRM.GetFormerMembers() };

    if guildAndFormer then

        -- In a linear array, not in linked table
        for i = 1 , #data do
            for j = 1 , #data[i] do
                if data[i][j].bannedInfo[1] or data[i][j].bannedInfo[3] then
                    -- Banned or Unbanned

                    table.insert ( result , { data[i][j].name , data[i][j].bannedInfo[2] } );   -- name and timestamp is all that is needed

                end
            end
        end

    else

        for i = 1 , #data do
            for _ , player in pairs ( data[i] ) do
                if type ( player ) == "table" then

                    if player.bannedInfo[1] or player.bannedInfo[3] then
                        -- Banned or Unbanned

                        table.insert ( result , { player.name , player.bannedInfo[2] } );   -- name and timestamp is all that is needed

                    end
                end
            end
        end

    end

    return result;
end

-- Method:          GRM.SyncRemoveCurrentPlayerBan ( string , int )
-- What it Does:    Removes a current ban during sync, thus avoids the chat spam.
-- Purpose:         Ban mechanism for during retroactive sync.
GRM.SyncRemoveCurrentPlayerBan = function ( name , timestamp , unbanner )
    local player = GRM.GetPlayer ( name );

    if player then
        if timestamp > player.bannedInfo[2] then
            player.bannedInfo = nil;
            player.bannedInfo = { false , timestamp , true , unbanner }
            player.reasonBanned = "";
            
            GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailBannedText1:Hide();
            GRM_UI.GRM_MemberDetailMetaData.GRM_MemberDetailBannedIgnoreButton:Hide();
        end
    end
end

-- Method:          GRM.SyncAddCurrentPlayerBan ( string , int , string , string )
-- What it Does:    Adds a ban during sync with the reason
-- Purpose:         Ban mechanism for during retroactive sync.
GRM.SyncAddCurrentPlayerBan = function ( name , timestamp , reason , banner )
    local player = GRM.GetPlayer ( name );

    if player then
        if timestamp > player.bannedInfo[2] then
            player.bannedInfo = nil;
            player.bannedInfo = { true , timestamp , false , banner }
            player.reasonBanned = reason;
        end
    end
end

-- Method:          GRM.ChangeCurrentPlayerBanReason ( string , string , string )
-- What it Does:    Edits the current ban reason with a new one
-- Purpose:         Mechanism for editing the reason of a ban
GRM.ChangeCurrentPlayerBanReason = function ( name , reason , banner )
    local player = GRM.GetPlayer ( name );

    if player then
        if not banner then
            banner = "";
        end
        player.bannedInfo[4] = banner;
        player.reasonBanned = reason;
    end
end

-- Method:          GRM.GetNumberOfPlayerSBannedCurrentlyInGuild ( int )
-- What it Does:    Returns the number of players that are currently banned but are still in the guild
-- Purpose:         Useful on the OnUpdate Ban List tab to inform the player better if there are currently players in the guild that need to be banned.
GRM.GetNumberOfPlayerSBannedCurrentlyInGuild = function()
    local result = 0;
    local names = {};
    local guildData = GRM.GetGuild();

    for _ , player in pairs ( guildData ) do
        if type ( player ) == "table" then
            if player.bannedInfo[1] then
                result = result + 1;
                table.insert ( names , { player.name , GRM.GetClassColorRGB ( player.class ) , player.lastOnline } );
            end
        end
    end

    if result == 0 then
        GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_BanListRemoveAllCurrentButton:Hide();
    elseif GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame:IsVisible() and not GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_BanListRemoveAllCurrentButton:IsVisible() then
        GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_BanListRemoveAllCurrentButton:Show();
    end
        
    return result , names;
end
-- Method:          GRM.GetSortedBanListNamesWithDetails ( string )
-- What it Does:    Returns the list of all banned players based on the given sorting settings
-- Purpose:         Give the player to sort the ban list by the headers.
GRM.GetSortedBanListNamesWithDetails = function ( textSearch )
    local guildData = GRM.GetGuild();
    local finalList = {};
    local format = GRM_G.banDetailsControl[1];
    local descending = GRM_G.banDetailsControl[2];
    local playerDetails = {};
    local isAdded = false
    local count = 0;
    local rankName = "";

-- Add bans of people still in the guild
    for _ , player in pairs ( guildData ) do
        if type ( player ) == "table" then
            if player.bannedInfo[1] then
                if not textSearch or string.find ( string.lower ( GRM.RemoveSpecialCharacters ( player.name ) ) , textSearch , 1 , true ) or string.find ( string.lower ( player.name ) , textSearch , 1 , true ) then
                    rankName = player.rankName;
                    if rankName == "" or player.rankIndex == 99 then
                        rankName = GRM.L ( "Not Determined" );
                    end
                    table.insert ( playerDetails  , { player.name , player.class , player.bannedInfo[2] , rankName , player.rankIndex , player.reasonBanned , true , player.isUnknown , player.GUID , player.isTransfer } );
                    count = count + 1;
                end
            end
        end
    end

    guildData = GRM.GetFormerMembers();
    
    local start = #playerDetails + 1;
    local insertIndex = 1;

    -- Add bans of people not in the guild - adds them in order of when the most recent ban was.
    for _ , player in pairs ( guildData ) do
        if type ( player ) == "table" then

            if player.bannedInfo[1] then
                if not textSearch or string.find ( string.lower ( GRM.RemoveSpecialCharacters ( player.name ) ) , textSearch , 1 , true ) then
                    insertIndex = 1;

                    local isUnknown = false;
                    if player.GUID == "" then
                        isUnknown = true;
                    end

                    if #playerDetails == 0 then
                        insertIndex = 1;
                    else
                        for i = start , #playerDetails do
                            if player.bannedInfo[2] >= playerDetails[i][3] then
                                insertIndex = i;
                                break;
                            end

                            if i == #playerDetails and insertIndex == 1 then
                                insertIndex = i + 1;
                            end
                        end
                    end

                    if ( not player.class or player.class == "" ) and player.GUID ~= "" then
                        player.class = GRM.GetPlayerClassByGUID ( player.GUID );
    
                        if player.class == "" then
                            player.class = "HUNTER";        -- This shouldn't ever happen, but this is edge case if server fails to respond. Placholder class is set.
                        end
                    end

                    rankName = player.rankName;
                    if rankName == "" or player.rankIndex == 99 then
                        rankName = GRM.L ( "Not Determined" );
                    end

                    table.insert ( playerDetails  , insertIndex , { player.name , player.class , player.bannedInfo[2] , rankName , player.rankIndex , player.reasonBanned , false , isUnknown , player.GUID , player.isTransfer } );
                    count = count + 1;
                end
            end
        end
    end
        
    -- By Name
    if format == 2 then

        if descending then
            sort ( playerDetails , function ( a , b ) return a[1] < b[1] end );     -- Sorts complex table with first index alphabetically with score ranking
        else
            sort ( playerDetails , function ( a , b ) return b[1] < a[1] end );     -- Sorts complex table with first index alphabetically with score ranking
        end
        finalList = playerDetails;
    
    -- By Rank
    elseif format == 3 then

        for i = 1 , #playerDetails do
            if #finalList == 0 then
                table.insert ( finalList , playerDetails[i] );
            else
                -- Now, need to scan through the list to see what we have
                isAdded = false;
                for j = 1 , #finalList do
                    if descending then
                        if playerDetails[i][5] < finalList[j][5] then                  -- if rank index is lower, it is higher in the guild as index 0 = Guild Leader
                            table.insert ( finalList , j , playerDetails[i] );
                            isAdded = true;
                            break;
                        end
                    else
                        if playerDetails[i][5] > finalList[j][5] then
                            table.insert ( finalList , j , playerDetails[i] );
                            isAdded = true;
                            break;
                        end
                    end
                end
                if not isAdded then
                    table.insert ( finalList , playerDetails[i] ); -- Just add it to the end
                end
            end
        end

    -- By Date
    elseif format == 4 then

        for i = 1 , #playerDetails do

            if #finalList == 0 then
                table.insert ( finalList , playerDetails[i] );
            else
                -- Now, need to scan through the list to see what we have
                
                isAdded = false;
                for j = 1 , #finalList do
                    if descending then
                        if playerDetails[i][3] >= finalList[j][3] then                   -- Larger epoch stamps means more recent...
                            table.insert ( finalList , j , playerDetails[i] );
                            isAdded = true;
                            break;
                        end
                    else
                        if playerDetails[i][3] < finalList[j][3] then
                            table.insert ( finalList , j , playerDetails[i] );
                            isAdded = true;
                            break;
                        end
                    end
                end
                if not isAdded then
                    table.insert ( finalList , playerDetails[i] ); -- Just add it to the end
                end
            end
        end
    end
    
    return finalList , count;
end

-- Method:          GRM.IsAnyBanHighlighted()
-- What it Does:    Checks if any of the buttons in the ban list are highlighted
-- Purpose:         UX
GRM.IsAnyBanHighlighted = function()
    local result = false;

    for i = 1 , #GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_CoreBanListScrollChildFrame.allFrameButtons do
        if GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_CoreBanListScrollChildFrame.allFrameButtons[i][6] then
            result = true;
            break;
        end

    end

    return result;
end

-- Method:          GRM.ClearAllBanHighlights()
-- What it Does:    Clears all the highlights of any selected name in the ban window
-- Purpose:         UX
GRM.ClearAllBanHighlights = function()
    for i = 1 , #GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_CoreBanListScrollChildFrame.allFrameButtons do
        GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_CoreBanListScrollChildFrame.allFrameButtons[i][1]:UnlockHighlight();
        GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_CoreBanListScrollChildFrame.allFrameButtons[i][6] = false
    end
end

-- Method:          GRM.IsBanNameOnList ( name , array )
-- What it Does:    Returns true if the given name is on the list
-- Purpose:         To identify a quick lookup if the name is on the list for purposes of updating the ban list to show player has left the server
GRM.IsBanNameOnList = function ( name , list )
    local result = false;

    for i = 1 , #list do
        if name == list[i] then
            result = true;
            break;
        end
    end

    return result;
end

-- Method:          GRM.RefreshBanListFrames( bool , string )
-- What it Does:    On loading the Ban List frames, it populates and prepares them for a scrollable window if necessary
-- purpose:         Quality of Life. Whilst the ban list is managed automatically behind the scenes, it is useful to have common information that syncs between users
--                  with the guild.
GRM.RefreshBanListFrames = function( listNeedingUpdate , textSearch , banList , count )
    -- SCRIPT LOGIC ON ADD EVENT SCROLLING FRAME
    local scrollHeight = 0;
    local scrollWidth = 561;
    local buffer = 20;
    textSearch = textSearch or "";

    GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_CoreBanListScrollChildFrame.allFrameButtons = GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_CoreBanListScrollChildFrame.allFrameButtons or {};  -- Create a table for the Buttons.

    -- populating the window correctly.
    local tempHeight = 0;

    if not banList then
    
        if textSearch == "" and GRM.Trim( GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_PlayerSearchBanEditBox:GetText() ) ~= "" then
            textSearch = GRM.Trim( GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_PlayerSearchBanEditBox:GetText() );
        end

        banList , count = GRM.GetSortedBanListNamesWithDetails ( textSearch );
    end

    -- Populating the window based on the Current Players PLayers
    for i = 1 , #banList do
        -- if font string is not created, do so.
        if not GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_CoreBanListScrollChildFrame.allFrameButtons[i] then
            local tempButton = CreateFrame ( "Button" , "BannedPlayer" .. i , GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_CoreBanListScrollChildFrame ); -- Names each Button 1 increment up
            table.insert ( GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_CoreBanListScrollChildFrame.allFrameButtons , { tempButton , tempButton:CreateFontString ( nil , "OVERLAY" , "GameFontWhiteTiny" ) , tempButton:CreateFontString ( nil , "OVERLAY" , "GameFontWhiteTiny" ) , tempButton:CreateFontString ( nil , "OVERLAY" , "GameFontWhiteTiny" ) , tempButton:CreateFontString ( nil , "OVERLAY" , "GameFontWhiteTiny" ) , false } );
        end

        local BanButtons = GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_CoreBanListScrollChildFrame.allFrameButtons[i][1];
        local BanNameText = GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_CoreBanListScrollChildFrame.allFrameButtons[i][2];
        local BanRankText = GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_CoreBanListScrollChildFrame.allFrameButtons[i][3];
        local BanDateText = GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_CoreBanListScrollChildFrame.allFrameButtons[i][4];
        local BanReasonText = GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_CoreBanListScrollChildFrame.allFrameButtons[i][5];
        GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_CoreBanListScrollChildFrame.allFrameButtons[i][6] = false;  -- Reset the highlights.

        local classColor = GRM.GetClassColorRGB ( banList[i][2] );
        local nameDetails = banList[i][1];

        -- Is Transfer
        if banList[i][10] then
            nameDetails = nameDetails .. " |CFFFF0000(" .. GRM.L ( "Not on Server" ) .. ")";
            BanButtons.noIdentity = false;
            BanButtons.notOnServer = true;

        -- No GUID found
        elseif banList[i][8] then
            -- Player was unable to be identified on the server
            nameDetails = nameDetails .. " |CFFFF0000" .. GRM.L ( "(Unable to Identify)" );
            BanButtons.noIdentity = true
            BanButtons.notOnServer = false;

        -- GUID, but no longer valid
        elseif listNeedingUpdate and GRM.IsBanNameOnList ( nameDetails , listNeedingUpdate ) then
            nameDetails = nameDetails .. " |CFFFF0000(" .. GRM.L ( "Not on Server" ) .. ")";
            BanButtons.noIdentity = false;
            BanButtons.notOnServer = true;

        else
            BanButtons.noIdentity = false;
            BanButtons.notOnServer = false;
        end

        BanButtons:SetWidth ( 555 );
        BanButtons:SetHeight ( 19 );
        BanButtons:SetHighlightTexture ( "Interface\\Buttons\\UI-Panel-Button-Highlight" );
        if banList[i][7] then
            BanNameText:SetText ( GRM.L ( "{name}(Still in Guild)" , banList[i][1] .. "  |cff7fff00" ) );
            BanButtons.stillInGuild = true;
        else
            BanNameText:SetText ( nameDetails );
            BanButtons.stillInGuild = false;
        end
        BanButtons:RegisterForDrag ( "LeftButton" );
        BanButtons:SetScript ( "OnDragStart" , function()
            GRM_UI.GRM_RosterChangeLogFrame:StartMoving();
        end);
        BanButtons:SetScript ( "OnDragStop" , function()
            GRM_UI.GRM_RosterChangeLogFrame:StopMovingOrSizing();
            GRM_UI.SaveCorePosition();
        end);

        BanNameText:SetTextColor ( classColor[1] , classColor[2] , classColor[3] , 1 );
        BanNameText:SetFont ( GRM_G.FontChoice , GRM_G.FontModifier + 12 );
        BanNameText:SetJustifyH ( "LEFT" );
        BanNameText:SetWidth ( 295 );
        BanNameText:SetWordWrap ( false );
        BanRankText:SetText ( banList[i][4] );
        BanRankText:SetFont ( GRM_G.FontChoice , GRM_G.FontModifier + 12 );
        BanRankText:SetJustifyH ( "CENTER" );
        BanRankText:SetWidth ( 100 );
        BanRankText:SetTextColor ( 0.90 , 0.80 , 0.50 , 1.0 );
        BanDateText:SetText ( GRM.EpochToDateFormat ( banList[i][3] ) );
        BanDateText:SetFont ( GRM_G.FontChoice , GRM_G.FontModifier + 12 );
        BanDateText:SetJustifyH ( "CENTER" );
        BanDateText:SetWidth ( 100 );
        -- Determine it's not an empty ban reason!
        local reason = "";
        if banList[i][6] == "" or banList[i][6] == nil then
            reason = GRM.L ( "No Ban Reason Given" );
        else
            reason = banList[i][6];
        end
        BanReasonText:SetText ( "|CFFFF0000" .. GRM.L ( "Reason:" ) .. " |CFFFFFFFF" .. reason );
        BanReasonText:SetWidth ( 245 );
        BanReasonText:SetWordWrap ( true );
        BanReasonText:SetSpacing ( 1 );
        BanReasonText:SetFont ( GRM_G.FontChoice , GRM_G.FontModifier + 12 );
        BanReasonText:SetPoint ( "TOPLEFT" , BanButtons , "BOTTOMLEFT" , 0 , -1);
        BanReasonText:SetJustifyH ( "LEFT" );

        -- Logic
        BanButtons:SetScript ( "OnClick" , function ( self , button )
            if button == "LeftButton" then

                local fullName = BanNameText:GetText();
                local R,G,B = BanNameText:GetTextColor();
                
                if self.noIdentity or self.stillInGuild or self.notOnServer then
                    fullName = string.sub ( fullName , 1 , string.find ( fullName , " " ) - 1 );
                end
                
                if IsShiftKeyDown() and IsControlKeyDown() then
                    GRM.RestoreTooltip();
                    GRM_UI.GRM_RosterChangeLogFrame.GRM_LogTab:Click();
                    GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_LogEditBox:SetText( GRM.SlimName ( fullName ) );
                elseif IsControlKeyDown() then
                    if self.stillInGuild then
                        GRM.OpenPlayerWindow( fullName );
                    end
                else

                    -- For highlighting purposes
                    for j = 1 , #GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_CoreBanListScrollChildFrame.allFrameButtons do
                        if self ~= GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_CoreBanListScrollChildFrame.allFrameButtons[j][1] then

                            -- Selected button differs from this, so we can 
                            GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_CoreBanListScrollChildFrame.allFrameButtons[j][1]:UnlockHighlight();
                            GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_CoreBanListScrollChildFrame.allFrameButtons[j][6] = false;
                        else
                            GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_CoreBanListScrollChildFrame.allFrameButtons[j][1]:LockHighlight();
                            GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_CoreBanListScrollChildFrame.allFrameButtons[j][6] = true;
                        end

                    end
                    
                    GRM_G.TempBanTarget = { fullName , { GRM.ConvertRGBScale ( R , true ) , GRM.ConvertRGBScale ( G , true ) , GRM.ConvertRGBScale ( B , true ) } }; -- Need to parse out the "(Still in Guild)"
                end
            end
        end);
        
        -- Now let's pin it!
        
        if i == 1 then
            BanButtons:SetPoint( "TOPLEFT" , GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_CoreBanListScrollChildFrame , "TOPLEFT" , 5 , -12 );
            BanNameText:SetPoint ( "TOPLEFT" , GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_CoreBanListScrollChildFrame , "TOPLEFT" , 5 , -12 );
            BanRankText:SetPoint ( "TOP" , GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_CoreBanListScrollChildFrame , "TOP" , 64 , -12 );
            BanDateText:SetPoint ( "TOP" , GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_CoreBanListScrollChildFrame , "TOP" , 211 , -12 );
            scrollHeight = scrollHeight + BanButtons:GetHeight() + BanReasonText:GetHeight();
        else
            BanButtons:SetPoint( "TOPLEFT" , GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_CoreBanListScrollChildFrame.allFrameButtons[i - 1][5] , "BOTTOMLEFT" , 0 , - buffer );
            BanNameText:SetPoint ( "TOPLEFT" , GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_CoreBanListScrollChildFrame.allFrameButtons[i - 1][5] , "BOTTOMLEFT" , 0 , - buffer );
            BanRankText:SetPoint ( "TOP" , GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_CoreBanListScrollChildFrame.allFrameButtons[i - 1][3] , "BOTTOM" , 0 , - ( tempHeight + buffer ) );
            BanDateText:SetPoint ( "TOP" , GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_CoreBanListScrollChildFrame.allFrameButtons[i - 1][4] , "BOTTOM" , 0 , - ( tempHeight + buffer ) );
            scrollHeight = scrollHeight + BanButtons:GetHeight() + BanReasonText:GetHeight() + buffer;
        end
        BanButtons:Show();
        tempHeight = BanReasonText:GetHeight() + ( BanButtons:GetHeight() - BanNameText:GetHeight() ) + 1;
    end

    -- Ok, let's add a count to how many banned
    if count > 0 then
        GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_CoreBanListFrameNumBannedText:SetText( "(" .. GRM.L ( "Total Banned:" ) .. " " .. count .. ")" );
        GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_CoreBanListFrameNumBannedText:Show();
        GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_CoreBanListFrameAllOfflineText:Hide();
    else
        GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_CoreBanListFrameNumBannedText:Hide();
        GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_CoreBanListFrameAllOfflineText:Show();
    end

    -- Hides all the additional buttons... if necessary ( necessary because once initialized, the buttons are there. This avoids bloated code and too much purging and rebuilding and purging. Just hide for future use.
    for i = count + 1 , #GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_CoreBanListScrollChildFrame.allFrameButtons do
        GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_CoreBanListScrollChildFrame.allFrameButtons[i][1]:Hide();
    end

    --Set Button Logic
    for i = 1 , #GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_CoreBanListScrollChildFrame.allFrameButtons do
        GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_CoreBanListScrollChildFrame.allFrameButtons[i][1]:SetScript ( "OnEnter" , function ( self )          
            local playerName = GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_CoreBanListScrollChildFrame.allFrameButtons[i][2]:GetText();
            local playerWhoBanned = "";
            local stillInGuild = false;

            if string.find ( playerName , " " ) ~= nil then

                local inGuild = true;
                if string.find ( playerName , GRM.L ( "(Unable to Identify)" ) , 1 , true ) ~= nil then
                    inGuild = false; 
                end

                playerName = GRM.Trim ( string.sub ( playerName , 1 , string.find ( playerName , " " ) - 1 ) );
                playerWhoBanned = GRM.GetPlayerWhoBanned ( playerName , inGuild );

                if inGuild then
                    stillInGuild = true;
                end
            else
                playerWhoBanned = GRM.GetPlayerWhoBanned ( playerName , false );
            end

            if playerWhoBanned == "" then
                playerWhoBanned = GRM.L ( "Unknown" );
            else
                playerWhoBanned = GRM.GetClassifiedName ( playerWhoBanned , true );
            end
            
            GRM_UI.SetTooltipScale();
            GameTooltip:SetOwner ( self , "ANCHOR_CURSOR" );
            GameTooltip:AddLine ( GRM.L ( "Player Was Banned By: {name}" , playerWhoBanned ) );
            GameTooltip:AddLine ( " " );
            if stillInGuild then
                GameTooltip:AddLine ( GRM.L ( "{custom1} to open Player Window" , nil , nil , nil , "|CFFE6CC7F" .. GRM.L ( "Ctrl-Click" ) .. "|r" ) );
            end
            GameTooltip:AddLine ( GRM.L ( "{custom1} to Search the Log for Player" , nil , nil , nil , "|CFFE6CC7F" .. GRM.L ( "Ctrl-Shift-Click" ) .. "|r" ) );
            GameTooltip:Show();
        end);

        GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_CoreBanListScrollChildFrame.allFrameButtons[i][1]:SetScript ( "OnLeave" , function ()
            GRM.RestoreTooltip();
        end);

    end

    GRM_UI.UpdateBanTabCurrentlyInGuild();
    
    -- Update the size -- it either grows or it shrinks!
    GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_CoreBanListScrollChildFrame:SetSize ( scrollWidth , scrollHeight );

    --Set Slider Parameters ( has to be done after the above details are placed )
    local scrollMax = ( scrollHeight - GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_CoreBanListScrollFrame:GetHeight() ) + ( buffer * .5 ) + tempHeight;
    if scrollMax < 0 then
        scrollMax = 0;
    end
    GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_CoreBanListScrollFrameSlider:SetMinMaxValues ( 0 , scrollMax );
    -- Mousewheel Scrolling Logic
    GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_CoreBanListScrollFrame:EnableMouseWheel( true );
    GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_CoreBanListScrollFrame:SetScript( "OnMouseWheel" , function( _ , delta )
        local current = GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_CoreBanListScrollFrameSlider:GetValue();
        
        if IsShiftKeyDown() and delta > 0 then
            GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_CoreBanListScrollFrameSlider:SetValue ( 0 );
        elseif IsShiftKeyDown() and delta < 0 then
            GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_CoreBanListScrollFrameSlider:SetValue ( scrollMax );
        elseif delta < 0 and current < scrollMax then
            if IsControlKeyDown() then
                GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_CoreBanListScrollFrameSlider:SetValue ( current + 60 );
            else
                GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_CoreBanListScrollFrameSlider:SetValue ( current + 20 );
            end
        elseif delta > 0 and current > 1 then
            if IsControlKeyDown() then
                GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_CoreBanListScrollFrameSlider:SetValue ( current - 60 );
            else
                GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_CoreBanListScrollFrameSlider:SetValue ( current - 20 );
            end
        end
    end);

    -- GUID check to see if any of them are no longer on the server...
    if not listNeedingUpdate then
        local names = GRM.GetBannedPlayersWithGUIDs();
        GRM.SetplayersStillOnServer ( names , true );

        C_Timer.After ( 3 , function()
            local list = GRM.ValidateBanGUIDs ( textSearch );

            if #list > 0 then
                GRM.RefreshBanListFrames( list , textSearch , banList , count );
            end
        end);
    end
end

-- Method:          GRM.RefreshSelectHybridFrames ( bool , bool , bool , bool )
-- What it Does:    Checks if these frames are visible and if so, refreshes their details
-- Purpose:         If a value changes in the roster, like a player leaves or joins the guild, or even is promoted, demoted, you want these values to be instantly visible and reset
--                  Be warned, calling this can be extremely computationally expensive. Never place it in a loop to update on each value changed. Only place it at the end of the 
--                  sequence of actions to update everything all at once.
GRM.RefreshSelectHybridFrames = function ( log , audit , ban , macroTool )
    if log and GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame:IsVisible() then
        GRM.BuildLogComplete( true , true );
    end

    --Refresh Audit Frames
    if audit and GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame:IsVisible() then
        GRM.RefreshAuditFrames ( true , true );
    end

    -- Refresh Ban List Frames
    if ban and GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame:IsVisible() then
        GRM.RefreshBanListFrames();
    end

    --Refresh Macro Tool Frames
    if macroTool and GRM_UI.GRM_ToolCoreFrame ~= nil and GRM_UI.GRM_ToolCoreFrame:IsVisible() then
        GRM_UI.RefreshManagementTool();
    end
end


--- FINALLY!!!!!
--- TOOLTIPS ---
----------------

-- Method:          GRM.RestoreTooltip()
-- What it Does:    Restores the previous settings of the tooltip so GRM's own settings do not overwrite elsewhere
-- Purpose:         Maintain compatibility, and also add this all into a single function call.
GRM.RestoreTooltip = function()
    GRM_UI.RestoreTooltipScale();
    GameTooltip:Hide();
end

-- Method:          GRM.GetRankHistory ( string , string )
-- What it Does:    Returns the give players promotion date history
-- Purpose:         So export can include a promotion date history
GRM.GetRankHistory = function ( player , delimiter )
    local history = "";
    local separator = ",";
    local timeStamp = "";
    local header = "";

    if delimiter == "," then
        separator = ";";
    end

    local count = 0;

    if player.rankHist[1][2] > 0 then  -- If it is zero then it has never been set
        for i = 1 , #player.rankHist do

            if history ~= "" then
                history = history .. separator;
            end

            if player.rankHist[i][8] == 3 then  --  "Left Guild"
                header = GRM.L ( "Left Guild" );
            else
                header = player.rankHist[i][1];
            end

            timeStamp = header .. ": " .. GRM.FormatTimeStamp ( { player.rankHist[i][2] , player.rankHist[i][3] , player.rankHist[i][4] } , false , false );

            history = history .. timeStamp;

            count = count + 1;
            if count > 10 then
                break;
            end
        end
    end

    return history;
end

-- Method:          GRM.PromoRankTooltip ( frame )
-- What it Does:    Processes the logic for this specific tooltip in the player rank window and populates player rank promotion history
-- Purpose:         Keep code clean and management and compartmentalized on the mouseover tooltip window.
GRM.PromoRankTooltip = function( self )
    if GetMouseFocus() == self and self.GRM_MemberDetailRankToolTip:IsVisible() ~= true and not StaticPopup1:IsVisible() and not DropDownList1:IsVisible() and self.GRM_MemberDetailRankDateTxt:IsVisible() == true and not GRM_UI.GRM_MemberDetailMetaData.GRM_MouseOverDateStatusFrame:IsVisible() and self.GRM_MemberDetailRankDateTxt:IsMouseOver(1,-1,-1,1) == true then
            
        self.GRM_MemberDetailRankToolTip:SetOwner( self.GRM_MemberDetailRankDateTxt , "ANCHOR_BOTTOMRIGHT" );
        self.GRM_MemberDetailRankToolTip:AddLine( "|cFFFFFFFF" .. GRM.L ( "Rank History" ) );
        
        local player = GRM.GetPlayer ( GRM_G.currentName );
        if player then
            -- Now, let's build the tooltip
            if self.GRM_MemberDetailRankDateTxt:GetText() == GRM.L ( "Promoted:" ) .. " " .. GRM.L ( "Unknown" ) then
                self.GRM_MemberDetailRankToolTip:AddDoubleLine ( "|cFFFF0000" .. GRM.L ( "Time at Rank:" ) , GRM.L ( "Unknown" ) );
                self.GRM_MemberDetailRankToolTip:AddDoubleLine ( " " , " " );
            else

                local header = "";
                for i = 1 , #player.rankHist do

                    -- If on the last set...
                    if i == 1 then

                        local timeAtRank = GRM.L ( "Unknown" );
                        if #player.rankHist[1][5] > 1 then
                            timeAtRank = GRM.GetTimePassedUsingTableOrString ( { player.rankHist[1][2] , player.rankHist[1][3] , player.rankHist[1][4] } )[4];
                        elseif not player.promoteDateUnknown then
                            timeAtRank = GRM.L ( "Not Set" );
                        end

                        self.GRM_MemberDetailRankToolTip:AddDoubleLine ( "|cFFFF0000" .. GRM.L ( "Time at Rank:" ) , timeAtRank );
                        self.GRM_MemberDetailRankToolTip:AddDoubleLine ( " " , " " );

                        if #player.rankHist[1][5] > 1 and not player.rankHist[1][7] then
                            self.GRM_MemberDetailRankToolTip:AddLine ( GRM.L ( "The {name} tag indicates a date must be verified to sync" , "|CFFFF0000!!|r" ) );
                            self.GRM_MemberDetailRankToolTip:AddLine ( GRM.L ( "To confirm or edit the date, right click the date, edit, and submit" ) , 1 , 0.84 , 0 , true );
                            self.GRM_MemberDetailRankToolTip:AddLine ( " " );
                            self.GRM_MemberDetailRankToolTip:AddLine ( GRM.L ( "If the date is accurate, right click and select 'Confirm Date'" ) , 1 , 0.84 , 0 , true );
                            self.GRM_MemberDetailRankToolTip:AddDoubleLine ( " " , " " );
                        end

                    end

                    if player.rankHist[i][8] == 3 then  --  "Left Guild"
                        header = GRM.L ( "Left Guild" );
                    else
                        header = player.rankHist[i][1];
                    end

                    self.GRM_MemberDetailRankToolTip:AddDoubleLine(  header .. ":" , GRM.DateUntrustedTag ( player.rankHist[i][7] ) .. GRM.FormatTimeStamp ( { player.rankHist[i][2] , player.rankHist[i][3] , player.rankHist[i][4] } , false , false ) , 0.38 , 0.67 , 1.0 );
                end
            end
            self.GRM_MemberDetailRankToolTip:AddLine ( " " );
            self.GRM_MemberDetailRankToolTip:AddLine ( GRM.L ( "Right-Click to Edit" ) );
        end

        self.GRM_MemberDetailRankToolTip:Show();
    elseif GetMouseFocus() ~= self or ( self.GRM_MemberDetailRankToolTip:IsVisible() == true and self.GRM_MemberDetailRankDateTxt:IsMouseOver(1,-1,-1,1) ~= true ) then
        self.GRM_MemberDetailRankToolTip:Hide();
        self.GRM_MemberDetailServerNameToolTip:Hide();
    end
end

-- Method:          GRM.JoinDateTooltip ( frame )
-- What it Does:    Builds the tooltip for when mousing over the guild join date history
-- Purpose:         Keep code clean and compartmentalized
GRM.JoinDateTooltip = function ( self )
    if GetMouseFocus() == self and self.GRM_MemberDetailJoinDateToolTip:IsVisible() ~= true and not StaticPopup1:IsVisible() and self.GRM_JoinDateText:IsVisible() == true and not GRM_UI.GRM_MemberDetailMetaData.GRM_MouseOverDateStatusFrame:IsVisible() and self.GRM_JoinDateText:IsMouseOver(1,-1,-1,1) == true then
           
        self.GRM_MemberDetailJoinDateToolTip:SetOwner( self.GRM_JoinDateText , "ANCHOR_BOTTOMRIGHT" );
        self.GRM_MemberDetailJoinDateToolTip:AddLine( "|cFFFFFFFF" .. GRM.L ( "Membership History" ) );
        local joinedHeader;
        local msg = "";

        local player = GRM.GetPlayer ( GRM_G.currentName );
        if player then
            -- Ok, let's build the tooltip now.
            if self.GRM_JoinDateText:GetText() == GRM.L ( "Unknown" ) then
                self.GRM_MemberDetailJoinDateToolTip:AddDoubleLine ( GRM.L ( "Joined:" ) , GRM.L ( "Unknown" ) );
                self.GRM_MemberDetailJoinDateToolTip:AddDoubleLine ( " " , " " );
            else
                for i = 1 , #player.joinDateHist do                                       -- Starting with most recent join which will be at end of array.
                    if i == 1 then
                        self.GRM_MemberDetailJoinDateToolTip:AddDoubleLine ( "|cFFFF0000" .. GRM.L ( "Time as Member:" ) , GRM.GetTimePlayerHasBeenMember ( player.name ) );

                        if #player.joinDateHist > 0 then
                            local totalJoins = math.floor ( #player.joinDateHist / 2 ) + ( #player.joinDateHist % 2 );
                            local total = GRM.L ( "Times in Guild: {num}" , nil , nil , totalJoins );
            
                            if GRM.IsGuildEE ( GRM_G.guildName ) then
                                if GRM.IsPlayerEE ( GRM_G.currentName ) then
                                    total = GRM_G.listOfPlayers[GRM_G.currentName] .. ": " .. totalJoins;
                                else
                                    total = GRM_G.listOfGuilds[GRM_G.guildName] .. ": " .. totalJoins;
                                end
                            end
            
                            self.GRM_MemberDetailJoinDateToolTip:AddLine( total , 1 , 0 , 0 );
                        end

                        self.GRM_MemberDetailJoinDateToolTip:AddDoubleLine ( " " , " " );

                        if string.find ( self.GRM_JoinDateText:GetText() , "!!" , 1 , true ) ~= nil then
                            self.GRM_MemberDetailJoinDateToolTip:AddLine ( GRM.L ( "The {name} tag indicates a date must be verified to sync" , "|CFFFF0000!!|r" ) );
                            self.GRM_MemberDetailJoinDateToolTip:AddLine ( GRM.L ( "To confirm or edit the date, right click the date, edit, and submit" ) , 1 , 0.84 , 0 , true );
                            self.GRM_MemberDetailJoinDateToolTip:AddLine ( " " );
                            self.GRM_MemberDetailJoinDateToolTip:AddLine ( GRM.L ( "If the date is accurate, right click and select 'Confirm Date'" ) , 1 , 0.84 , 0 , true );
                            self.GRM_MemberDetailJoinDateToolTip:AddDoubleLine ( " " , " " );
                        end
                    end

                    if player.joinDateHist[i][7] == 2 then
                        joinedHeader = GRM.L ( "Left:" );
                    elseif i == #player.joinDateHist then
                        joinedHeader = GRM.L ( "Joined:" );
                    else
                        joinedHeader = GRM.L ( "Rejoined:" );
                    end
                    if player.joinDateHist[i][1] == 0 then
                        msg = GRM.L ( "Unknown" );
                    else
                        msg = GRM.DateUntrustedTag ( player.joinDateHist[i][6] ) .. GRM.FormatTimeStamp ( { player.joinDateHist[i][1] , player.joinDateHist[i][2] , player.joinDateHist[i][3] } , false );
                    end
                    self.GRM_MemberDetailJoinDateToolTip:AddDoubleLine( joinedHeader , msg , 0.38 , 0.67 , 1.0 );
                    -- If player once left, then this will add the line for it.
                end
            end
            self.GRM_MemberDetailJoinDateToolTip:AddLine ( " " );
            self.GRM_MemberDetailJoinDateToolTip:AddLine ( GRM.L ( "Right-Click to Edit" ) );
        end
        self.GRM_MemberDetailJoinDateToolTip:Show();
    elseif GetMouseFocus() ~= self or ( self.GRM_JoinDateText:IsMouseOver(1,-1,-1,1) ~= true and ( self.GRM_MemberDetailJoinDateToolTip:IsVisible() or self.GRM_MemberDetailServerNameToolTip:IsVisible() ) ) then
        self.GRM_MemberDetailJoinDateToolTip:Hide();
        self.GRM_MemberDetailServerNameToolTip:Hide();
    end
end

-- Method:          GRM.PlayerNameTooltip( frame )
-- What it Does:    Builds tooltip when mousing over the player name
-- Purpose:         Compartmentalizing the code for cleanliness, like previous tooltip logic
GRM.PlayerNameTooltip = function( self )
    if not GRM_UI.GRM_MemberDetailMetaData.GRM_altDropDownOptions:IsVisible() and not StaticPopup1:IsVisible() and self.GRM_MemberDetailNameText:IsMouseOver ( 1 , -1 , -1 , 1 ) and GetMouseFocus() == self then
        -- Get Class Color
        local textR, textG, textB = self.GRM_MemberDetailNameText:GetTextColor();

        -- Build the tooltip
        self.GRM_MemberDetailServerNameToolTip:SetOwner ( self.GRM_JoinDateText , "ANCHOR_CURSOR" );
        self.GRM_MemberDetailServerNameToolTip:AddLine ( GRM_G.currentName , textR , textG , textB );

        local player = GRM.GetPlayer ( GRM_G.currentName );
        
        if player and player.race ~= "" and player.sex ~= 0 then
            self.GRM_MemberDetailServerNameToolTip:AddLine ( GRM.L ( "{name} {name2}" , C_CreatureInfo.GetRaceInfo ( raceIDEnum[player.race] ).raceName , GRM.GetSex ( player.sex ) ) , 1 , 1 , 1 );
        end

        self.GRM_MemberDetailServerNameToolTip:AddLine ( " " );
        self.GRM_MemberDetailServerNameToolTip:AddLine ( GRM.L ( "{custom1} to Copy Name to Chat" , nil , nil , nil , "|CFFE6CC7F" .. GRM.L ( "Shift-Click" ) .. "|r" ) );
        self.GRM_MemberDetailServerNameToolTip:AddLine ( GRM.L ( "{custom1} for Additional Options" , nil , nil , nil , "|CFFE6CC7F" .. GRM.L ( "Right-Click" ) .. "|r" ) );
        self.GRM_MemberDetailServerNameToolTip:Show();
    else
        self.GRM_MemberDetailServerNameToolTip:Hide();
    end
end

-- Method:          GRM.GetSex ( int )
-- What it Does:    Returns the localized text string of the given gender
-- Purpose:         Useful to report the player's sex.
GRM.GetSex = function ( index )
    local result = "";
    if index > 1 then
        if index == 2 then
            result = GRM.L ( "Male" );
        elseif index == 3 then
            result = GRM.L ( "Female" );
        end
    end
    return result;
end

-- Method:          GRM.AltNameTooltip ( frame )
-- What it Does:    Populates the alt info tooltip
-- Purpose:         Useful info for player, keeps code clean.
GRM.AltNameTooltip = function ( self )

    local player = GRM.GetPlayer ( GRM_G.currentName );

    if ( GRM_UI.GRM_MemberDetailMetaData.GRM_CoreAltFrame.GRM_CoreAltScrollFrame.GRM_CoreAltScrollChildFrame.allFrameButtons ~= nil and #GRM_UI.GRM_MemberDetailMetaData.GRM_CoreAltFrame.GRM_CoreAltScrollFrame.GRM_CoreAltScrollChildFrame.allFrameButtons > 0 and GRM_UI.GRM_MemberDetailMetaData.GRM_CoreAltFrame.GRM_CoreAltScrollFrame.GRM_CoreAltScrollChildFrame.allFrameButtons[1][1]:IsVisible() ) and not StaticPopup1:IsVisible() and not self.GRM_altDropDownOptions:IsVisible() and not ( self.GRM_YearDropDownMenu:IsVisible() and self.GRM_YearDropDownMenu:IsMouseOver() ) and not ( self.GRM_DayDropDownMenu:IsVisible() and self.GRM_DayDropDownMenu:IsMouseOver() ) then

        if not self.GRM_ExtraAltDetailsArrowButton:IsMouseOver( 1 , -1 , -1 , 1 ) then

            GRM_G.tempAltName = "";
            
            if player then

                local listOfAlts = GRM.GetListOfAlts ( player );
                local color = {};
                local AltTT = self.GRM_MemberDetailServerNameToolTip;
                local isOver = false;

                if GRM_UI.GRM_MemberDetailMetaData.GRM_CoreAltFrame.GRM_CoreAltScrollFrame.GRM_CoreAltScrollChildFrame.allFrameButtons ~= nil then
                    for i = 1 , #GRM_UI.GRM_MemberDetailMetaData.GRM_CoreAltFrame.GRM_CoreAltScrollFrame.GRM_CoreAltScrollChildFrame.allFrameButtons do
                        if GRM_UI.GRM_MemberDetailMetaData.GRM_CoreAltFrame.GRM_CoreAltScrollFrame.GRM_CoreAltScrollChildFrame.allFrameButtons[i][1]:IsVisible() and GRM_UI.GRM_MemberDetailMetaData.GRM_CoreAltFrame.GRM_CoreAltScrollFrame.GRM_CoreAltScrollChildFrame.allFrameButtons[i][1]:IsMouseOver ( 1 , -1 , -1 , 1 ) and GetMouseFocus() == GRM_UI.GRM_MemberDetailMetaData.GRM_CoreAltFrame.GRM_CoreAltScrollFrame.GRM_CoreAltScrollChildFrame.allFrameButtons[i][1] and listOfAlts[i] and listOfAlts[i][1] then
                            GRM_G.tempAltName = listOfAlts[i][1];
                            color = GRM.GetClassColorRGB ( listOfAlts[i][2] , false )
                            AltTT:SetOwner ( GRM_UI.GRM_MemberDetailMetaData.GRM_CoreAltFrame.GRM_CoreAltScrollFrame.GRM_CoreAltScrollChildFrame.allFrameButtons[i][1] , "ANCHOR_CURSOR" );
                            AltTT:AddLine ( listOfAlts[i][1] , color[1] , color[2] , color[3] );
                            AltTT:AddLine ( " " );
                            AltTT:AddLine ( GRM.L ( "{custom1} to Copy Name to Chat" , nil , nil , nil , "|CFFE6CC7F" .. GRM.L ( "Shift-Click" ) .. "|r" ) );
                            AltTT:AddLine ( GRM.L ( "{custom1} for Additional Options" , nil , nil , nil , "|CFFE6CC7F" .. GRM.L ( "Right-Click" ) .. "|r" ) );
                            AltTT:AddLine ( GRM.L ( "{custom1} to open Player Window" , nil , nil , nil , "|CFFE6CC7F" .. GRM.L ( "Ctrl-Click" ) .. "|r" ) )
                            isOver = true;
                            break;
                        end
                    end
                end

                if isOver and not self.GRM_altDropDownOptions:IsVisible() then
                    AltTT:Show();
                elseif self.GRM_altDropDownOptions:IsVisible() and not self.GRM_MemberDetailNameText:IsMouseOver ( 1 , -1 , -1 , 1 ) then
                    AltTT:Hide();
                end
            end
        end

        local player = GRM.GetPlayer ( GRM_G.currentName );
        if GRM_UI.GRM_MemberDetailMetaData.GRM_CoreAltFrame:IsMouseOver( 5 , 5 , 5 , 35 ) and player and GRM.GetNumAlts ( player.altGroup ) >= 12 then
            GRM_UI.GRM_MemberDetailMetaData.GRM_CoreAltFrame.GRM_CoreAltScrollFrameSlider:Show();
            GRM_CoreAltScrollFrameSliderThumbTexture:Show();
        else
            GRM_UI.GRM_MemberDetailMetaData.GRM_CoreAltFrame.GRM_CoreAltScrollFrameSlider:Hide();
        end

        if self.GRM_CustomNoteEditBoxFrame.GRM_CustomNoteScrollFrame:IsMouseOver( 1 , 1 , 1 , 13 ) and select ( 2 , self.GRM_CustomNoteEditBoxFrame.GRM_CustomNoteScrollFrameSlider:GetMinMaxValues() ) > 0 then
            self.GRM_CustomNoteEditBoxFrame.GRM_CustomNoteScrollFrameSlider:Show();
            GRM_CustomNoteScrollFrameSliderThumbTexture:Show()
        else
            self.GRM_CustomNoteEditBoxFrame.GRM_CustomNoteScrollFrameSlider:Hide();
        end

    else        
        if not self.GRM_MemberDetailNameText:IsMouseOver ( 1 , -1 , -1 , 1 ) then
            self.GRM_MemberDetailServerNameToolTip:Hide();
        end
    end

    if GRM.PlayerHasAlts ( player ) then

        if not self.GRM_ExtraAltDetailsArrowButton:IsVisible() then
            self.GRM_ExtraAltDetailsArrowButton:Show();
        end
         
    else
        if self.GRM_ExtraAltDetailsArrowButton:IsVisible() then
            self.GRM_ExtraAltDetailsArrowButton:Hide();
        end
    end
end

-- Method:          GRM.PlayerStatusNotificationTooltip ( Frame )
-- What it Does:    Builds notification tooltip to let player know they can view player status updates
-- Purpose:         Useful info for the player
GRM.PlayerStatusNotificationTooltip = function ( self )
    if GetMouseFocus() == self and self.GRM_MemberDetailPlayerStatus:IsMouseOver ( 1 , -1 , -1 , 1 ) and not GRM_UI.GRM_MemberDetailMetaData.GRM_MouseOverStatusFrame:IsVisible() then
        self.GRM_MemberDetailNotifyStatusChangeTooltip:SetOwner ( self.GRM_MemberDetailPlayerStatus , "ANCHOR_CURSOR" );
        self.GRM_MemberDetailNotifyStatusChangeTooltip:AddLine ( "|cFFFFFFFF" .. GRM.L ( "|CFFE6CC7FRight-Click|r to Set Notification of Status Change" ) );

        self.GRM_MemberDetailNotifyStatusChangeTooltip:Show();
    else
        self.GRM_MemberDetailNotifyStatusChangeTooltip:Hide();
    end
end

-- Method:          GRM.EditBdayTooltip ( self )
-- What it Does:    Provides a tooltip on the text so player knows they can edit it.
-- Purpose:         Clean code!
GRM.EditBdayTooltip = function ( self )
    if not self.GRM_BirthdayTooltip:IsVisible() and GetMouseFocus() == self and self.GRM_BirthdayText:IsVisible() and self.GRM_BirthdayText:IsMouseOver ( 1 , -1 , -1 , 1 ) and not GRM_UI.GRM_MemberDetailMetaData.GRM_MouseOverDateStatusFrame:IsVisible() then
        self.GRM_BirthdayTooltip:SetOwner ( self.GRM_BirthdayText , "ANCHOR_CURSOR" );
        self.GRM_BirthdayTooltip:AddLine (  GRM.L ( "Right-Click to Edit" ) );

        self.GRM_BirthdayTooltip:Show();
    elseif GetMouseFocus() ~= self or ( self.GRM_BirthdayTooltip:IsVisible() and not self.GRM_BirthdayText:IsMouseOver ( 1 , -1 , -1 , 1 ) ) then
        self.GRM_BirthdayTooltip:Hide();
    end
end

----------------------
-- CONFIG CHECK ------
----------------------

-- Method:          GRM.SystemMessageEnabledCheck()
-- What it does:    Does a check if system messages are still enabled.
-- Purpose:         To let the player know if they disable system messages the addon will not work.
GRM.SystemMessageEnabledCheck = function()
    GRM_G.SystemMessageTest = false;
    if not GRM_G.SystemMessageTestAnnounced then

        C_Timer.After ( 3 , function()
            if not GRM_G.SystemMessageTest then
                GRM_G.SystemMessageTestAnnounced = true;

                local realmName = GetRealmName();
                if IsAddOnLoaded ( "FastGuildInvite" ) and FGI_DB.realm and FGI_DB.realm[realmName] then

                    local enabledSystemMessages = function()
                        FGI_DB.realm[realmName].systemMSG = false;        -- Save file index - will be nil when it saves if set to false...
                        FGI.DB.realm.systemMSG = false;
                        ChatFrame_RemoveMessageEventFilter ( "CHAT_MSG_SYSTEM" , FGI.functions.hideSysMsg );
                        GRM.Report ( GRM.L ( "System Messages have been enabled and GRM should now function properly." ) );
                        GRM.Report ( GRM.L ( "Please Note: To permanently enable system messages, you must manually re-enable them in your chat window general settings" ) );
                    end

                    GRM.SetConfirmationWindow ( enabledSystemMessages , GRM.L ( "GRM has detected that FGI is blocking system messages and cannot function properly without them. Do you want to enable them?" ) );
                
                elseif not IsListeningForMessageType ( "SYSTEM" ) then
                    local enabledSystemMessages = function()
                        ToggleChatMessageGroup( true , "SYSTEM" );
                        GRM.Report ( GRM.L ( "System Messages have been enabled and GRM should now function properly." ) );
                    end

                    GRM.SetConfirmationWindow ( enabledSystemMessages , GRM.L ( "GRM has detected that System Messages are disabled and cannot function properly without them. Do you want to enable them?" ) );
                end
            end
        end);
    end
end

----------------------
-- GLOBAL CONTROLS ---
----------------------

-- Method:          GRM.MemberDetailToolTips ( self , float )
-- What it Does:    Populates the tooltips on the "OnUpdate" check for the core Member Detail frame
-- Purpose:         UI Feature  
-- Note:            self = GRM_UI.GRM_MemberDetailMetaData
GRM.MemberDetailToolTips = function ( self , elapsed )
    GRM_UI.GRM_MemberDetailMetaData.timer = GRM_UI.GRM_MemberDetailMetaData.timer + elapsed;
    if GRM_UI.GRM_MemberDetailMetaData.timer >= 0.075 then
        if IsInGuild() then

            -- PROMO DATE TEXT
            -- Only populate and show tooltip if mouse is over text frame and it is not already visible.
            GRM.PromoRankTooltip ( self );

            -- JOIN DATE TEXT
            GRM.JoinDateTooltip ( self );

            -- PLAYER NAME TEXT
            GRM.PlayerNameTooltip( self );

            -- ALT NAMES
            GRM.AltNameTooltip ( self );

            -- PLAYER STATUS
            GRM.PlayerStatusNotificationTooltip ( self );

            -- EDIT TOOLTIPS
            GRM.EditBdayTooltip ( self );
            
            if GRM_G.pause then
                GRM_UI.GRM_MemberDetailMetaData.GRM_WindowIsLockedText:Show();
            else
                GRM_UI.GRM_MemberDetailMetaData.GRM_WindowIsLockedText:Hide();
            end
        end
        GRM_UI.GRM_MemberDetailMetaData.timer = 0;
    end
end

-- Method:          GRM.ModifySpecificGuildControlValue ( int , string )
-- What it Does:    Modifies the position of the guild Control and returns the string
-- Purpose:         Easy modification of the string.
GRM.ModifySpecificGuildControlValue = function ( position , newValue )
    local rules = GRM.GetRulesString();
    local result = "";
    local pos1;

    if position == 1 then
        local pos = string.find ( rules , ";" , 1 , true );
        result = newValue .. string.sub ( rules , pos );
    elseif position == 10 then
        result = string.sub ( rules , 1 , #rules - 1 ) .. newValue;
    else
        local c = 1;    -- start it at 1 so it is always incremented up by 1 ahead. 

        for i = 1 , #rules do
            if string.sub ( rules , i , i ) == ";" then
                c = c + 1;

                -- Joined and rejoined dates.
                if pos1 ~= nil then
                    result = string.sub ( rules , 1 , pos1 ) .. newValue .. string.sub ( rules , i );
                    break;
                end

                if c == position then
                    if c ~= 7 and c ~= 8 then
                        result = string.sub ( rules , 1 , i ) .. newValue .. string.sub ( rules , i + 2 );
                        break;
                    else
                        pos1 = i;
                    end
                end
            end
        end
    end

    return result;                                              
end

-- Method:          GRM.UpdateGuildInfoWithNewValue ( int , string )
-- What it Does:    Modifies the control values then inserts them into the guildInfo over the original GRM controls, effectively replacing them
-- Purpose:         Ease of controls of global GRM controls for the addon user.
GRM.UpdateGuildInfoWithNewValue = function ( controlIndex , newValue )
    if CanEditGuildInfo() then
        local guildInfoText = GetGuildInfoText();
        local rulesString = GRM.GetRulesString();

        if rulesString ~= nil then
            local first , last = string.find ( guildInfoText , GRM.GetRulesString() , 1 , true );

            if first ~= nil and last ~= nil and CanEditGuildInfo() then
                SetGuildInfoText ( string.sub ( guildInfoText , 1 , first - 1 ) .. GRM.ModifySpecificGuildControlValue ( controlIndex , tostring ( newValue ) ) .. string.sub ( guildInfoText , last + 1 ) );
            end
        end
    end
end

-- Method:          GRM.GetRulesString()
-- What it Does:    Pulls the rules from the guild Info note
-- Purpose:         To clear the guildInfo and clean it up for expanded  global controls.
GRM.GetRulesString = function()
    return string.match ( GetGuildInfoText() , "grm^(.+)^g" );
end

-- Method:          GRM.GetEachGlobalControl()
-- What it Does:    Returns the parsed string based on the pattern match
-- Purpose:         Faster and cleaer code for parsing the global controls
GRM.GetEachGlobalControl = function( rulesString )
    if rulesString then
        GRM_G.MatchPattern10 = GRM_G.MatchPattern10 or GRM.BuildComPattern ( 10 , ";" , false );

        return string.match ( rulesString , GRM_G.MatchPattern10 );
    else
        return nil;
         
    end
end

-- Method:          GRM.GetGlobalControlValue ( int )
-- What it Does:    Returns the Global control value from the guildInfo global string
-- Purpose:         Easily pull values from the parsed note.
GRM.GetGlobalControlValue = function ( index )
    local rulesString = GRM.GetRulesString();
    local result;

    if rulesString ~= nil and rulesString ~= "" then
        result = select ( index , GRM.GetEachGlobalControl( rulesString ) );
    end

    -- Error protection
    if rulesString == "" then
        result = true;
    end

    return result;
end


-- Method:          GRM.UpdateGuildLeaderPermissions( bool , bool )
-- What it Does:    Scans the guild leader note for special tags and controls, pushes them to addon player setting - Rechecks every 60 seconds...
-- Purpose:         So the guild leader can mass enable/disable certain features in the addon.
GRM.UpdateGuildLeaderPermissions = function( isMyEdit , forced )
    local notes = GetGuildInfoText();

    if IsInGuild() and GRM_G.GuildInfo ~= notes and GRM.S() then
        if notes ~= nil and #notes > 0 then

            if not GRM_G.tagFormatChangeNotice then
                GRM_G.tagFormatChangeNotice = true;

                if CanEditGuildInfo() and string.find ( notes , "grm^" , 1 , true ) == nil and ( string.find ( notes , "g1^" , 1 , true ) ~= nil or string.find ( notes , "g2^" , 1 , true ) ~= nil ) then
                    GRM.Report ( GRM.L ( "GRM:" ) .. " " .. GRM.L ( "A new format exists for global settings controls." ) .. "\n" .. GRM.L ( "Go to GRM window > Options > Officer Tab > \"Set Global Controls\"" ) .. "\n" .. GRM.L ( "Remove the old format when all guildies have updated properly. You may wish to leave it in Guild Info until then." ) );
                end

            end

            local rulesString = GRM.GetRulesString();

            if rulesString ~= nil then
                local timeFormat , generalSync , banSync , customSync , joinDateLocation , enableUsingTags , joinTag , rejoinTag , noteTrigger = GRM.GetEachGlobalControl( rulesString );
                
                -- Timestamp format
                GRM.SetTimestampRestriction ( timeFormat , isMyEdit );

                -- Rank restriction control!
                GRM.SetLeaderRankRestrictionSetting ( generalSync , isMyEdit );

                -- Ban Restriction control
                GRM.SetLeaderBanRestrictionSetting ( banSync , isMyEdit );

                -- Custom Note Restriction Control
                GRM.SetLeaderCustomNoteRestrictionSetting ( customSync , isMyEdit );

                -- -- Join Date destiation Control
                GRM.SetLeaderJoinDateRestrictionSetting ( joinDateLocation , isMyEdit );

                -- -- Use join/Rejoin headers
                GRM.SetLeaderUsingJoinTagHeaders ( enableUsingTags );

                -- Tag Formatting
                GRM.SetJoinTagCustomFormat ( joinTag , rejoinTag , isMyEdit );

                -- -- !Note enabled controls
                GRM.SetNoteTriggerRestrictions ( noteTrigger );

            end
        end
        GRM_G.GuildInfo = GetGuildInfoText();

        if GRM_UI.GRM_RosterChangeLogFrame:IsVisible() then
            GRM_UI.BuildLogFrames()
        end
    end
    if not forced then
        C_Timer.After ( 60 , function()
            if IsInGuild() and GRM.S() then
                GRM.UpdateGuildLeaderPermissions ( false , false );
            end
        end);    -- Recheck once per minute indefinitely...
    end
end

-- Method:          GRM.SetJoinTagCustomFormat ( string , string , bool )
-- What it Does:    Checks for the number after the given match, and forces the player to adhere to those setting...
-- Purpose:         Conformity within the guild in the settings.
GRM.SetJoinTagCustomFormat = function ( customJoin , customRejoin , isMyEdit )
    -- first, very it is not nil
    local needsRefresh = false;

    -- DEFAULTS
    if customJoin == "XX" then
        customJoin = GRM.L ( "Joined:" );
    end
    if customRejoin == "XX" then
        customRejoin = GRM.L ( "Rejoined:" );
    end

    -- Custom JOIN
    if customJoin ~= "X" and customJoin ~= GRM.S().customTags[1] and GRM.S().includeTag then

        -- Cannot be greater than Max Characters (16) characters
        if #customJoin > GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_OfficerOptionsFrame.GRM_CustomTagJoinEditBox:GetMaxLetters() then
            if isMyEdit then
                GRM.Report ( GRM.L ( "Custom Join Date Tag \"{name}\" cannot be set as it is {num} characters. The max is {custom1}." , customJoin , nil , #customJoin , GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_OfficerOptionsFrame.GRM_CustomTagJoinEditBox:GetMaxLetters() ) );
            end
        else
            local finalReport = "";
            if isMyEdit or CanEditGuildInfo() then
                if #GRM.S().customTags[1] > 0 then
                    finalReport = GRM.L ( "Custom Join Tag has been changed from \"{name}\" to \"{name2}\"" , GRM.S().customTags[1] , customJoin );
                else
                    finalReport = GRM.L ( "Custom Join Tag has been set to \"{name}\"" , customJoin );
                end
            else
                if #GRM.S().customTags[1] > 0 then
                    finalReport = GRM.L ( "Your Guild Leader has changed the Custom Join Tag from \"{name}\" to \"{name2}\"" , GRM.S().customTags[1] , customJoin );
                else
                    finalReport = GRM.L ( "Your Guild Leader has set the Custom Join Tag to \"{name}\"" , customJoin );
                end
            end
            GRM.Report ( GRM.L ( "GRM:" ) .. " " .. finalReport );
            GRM.S().customTags[1] = customJoin;

            if GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_OfficerOptionsFrame.GRM_CustomTagJoinEditBox:IsVisible() then
                GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_OfficerOptionsFrame.GRM_CustomTagJoinEditBox:SetText ( GRM.S().customTags[1] );
            end
            needsRefresh = true;
        end
    end

    -- Custom REJOIN
    if customRejoin ~= "X" and customRejoin ~= GRM.S().customTags[2] then

        -- Cannot be greater than Max Characters (16) characters
        if #customRejoin > GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_OfficerOptionsFrame.GRM_CustomTagREJoinEditBox:GetMaxLetters() then
            if isMyEdit then
                GRM.Report ( GRM.L ( "Custom Rejoin Date Tag \"{name}\" cannot be set as it is {num} characters. The max is {custom1}." , customRejoin , nil , #customRejoin , GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_OfficerOptionsFrame.GRM_CustomTagREJoinEditBox:GetMaxLetters() ) );
            end
        else
            local finalReport = "";
            if isMyEdit or CanEditGuildInfo() then
                if #GRM.S().customTags[2] > 0 then
                    finalReport = GRM.L ( "Custom Rejoin Tag has been changed from \"{name}\" to \"{name2}\"" , GRM.S().customTags[2] , customRejoin );
                else
                    finalReport = GRM.L ( "Custom Rejoin Tag has been set to \"{name}\"" , customRejoin );
                end
            else
                if #GRM.S().customTags[2] > 0 then
                    finalReport = GRM.L ( "Your Guild Leader has changed the Custom Rejoin Tag from \"{name}\" to \"{name2}\"" , GRM.S().customTags[2] , customRejoin );
                else
                    finalReport = GRM.L ( "Your Guild Leader has set the Custom Rejoin Tag to \"{name}\"" , customRejoin );
                end
            end
            GRM.Report ( GRM.L ( "GRM:" ) .. " " .. finalReport );

            GRM.S().customTags[2] = customRejoin;
            if GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_OfficerOptionsFrame.GRM_CustomTagREJoinEditBox:IsVisible() then
                GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_OfficerOptionsFrame.GRM_CustomTagREJoinEditBox:SetText ( customRejoin );
            end
            needsRefresh = true;
        end
    end

    if needsRefresh then
        GRM.SetJoinAndRejoinTags();
    end
end

-- Method:          GRM.SetNoteTriggerRestrictions ( string )
-- What it Does:    Checks the Guildinfo tag if settings need to be adjusted and modify the settings if they do.
-- Purpose:         Allow global control in enforcing all officers use this function.
GRM.SetNoteTriggerRestrictions = function ( noteTrigger )
    noteTrigger = tonumber ( noteTrigger );
    -- first, very it is not nil
    if noteTrigger ~= nil and noteTrigger < 3 then
        
        if not CanEditGuildInfo() then
            GRM_G.GlobalControl7 = true;
        end

        local needsRefresh = false;

        if noteTrigger == 1 and not GRM.S().noteSetEnabled then
            GRM.S().noteSetEnabled = true;
            GRM.Report ( GRM.L ( "GRM:" ) .. " " .. GRM.L ( "'!note' trigger has been globally ENABLED" ) );
            needsRefresh = true;

        elseif noteTrigger == 2 and GRM.S().noteSetEnabled then
            GRM.S().noteSetEnabled = false;
            GRM.Report ( GRM.L ( "GRM:" ) .. " " .. GRM.L ( "'!note' trigger has been globally DISABLED" ) );
            needsRefresh = true
        end

        if needsRefresh then
            -- Update the frames if necessary
            if GRM_UI.GRM_RosterChangeLogFrame:IsVisible() then
                if GRM.S().noteSetEnabled then
                    GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_OfficerOptionsFrame.GRM_NoteTagFeatureCheckButton:SetChecked ( true );
                else
                    GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_OfficerOptionsFrame.GRM_NoteTagFeatureCheckButton:SetChecked ( false );
                end
            end
        end

    else
        -- Not valid, disable it.
        GRM_G.GlobalControl7 = false;
    end
end

-- Method:          GRM.IsCustomJoinRestricted()
-- What it Does:    Returns true if the guild Info has the custom join tag note set properly to a custom
-- Purpose:         Prevent players from making editing changes
GRM.IsCustomJoinRestricted = function()
    local result = false;
    local customJoin = GRM.GetGlobalControlValue ( 7 );

    if customJoin ~= nil then        
        if customJoin == "XX" or #customJoin <= GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_OfficerOptionsFrame.GRM_CustomTagJoinEditBox:GetMaxLetters() then
            result = true;
        end
    end

    return result , customJoin;
end

-- Method:          GRM.IsCustomReJoinRestricted()
-- What it Does:    Returns true if the custom Rejoin is restricted globally using the guild info note
-- Purpose:         Prevent players from changing their settings if it is already restricted in the guild info note
GRM.IsCustomReJoinRestricted = function()
    local result = false;
    local customReJoin = GRM.GetGlobalControlValue ( 8 );

    if customReJoin ~= nil then     
        
        if customReJoin == "XX" or #customReJoin <= GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_OfficerOptionsFrame.GRM_CustomTagREJoinEditBox:GetMaxLetters() then
            result = true;
        end
    end

    return result , customReJoin;
end

-- Method:          GRM.SetTimestampRestriction ( string , bool )
-- What it Does:    Checks for the number after the given match, and forces the player to adhere to those setting...
-- Purpose:         Conformity within the guild in the settings.
GRM.SetTimestampRestriction = function ( timeFormatIndex , isMyEdit )
    
    -- Let's first verify it is not nil as any player could put anything there, no need to throw errors out there constantly due to bad formatting.
    if tonumber ( timeFormatIndex ) ~= nil then
        timeFormatIndex = tonumber ( timeFormatIndex );
    else
        GRM_G.GlobalControl5 = false;
        return;
    end

    if not CanEditGuildInfo() then
        GRM_G.GlobalControl5 = true;
    end

    if timeFormatIndex > 17 then
        timeFormatIndex = 17
    end

    -- Now, we check to see if yours matches it or not. If it doesn't, you need to change it.
    if timeFormatIndex ~= GRM.S().globalDateFormat then

        GRM.S().globalDateFormat = timeFormatIndex;
        GRM.UpdateGuildInfoWithNewValue ( 1 , timeFormatIndex );

        local finalReport = "";
        local month , day , year = select ( 2 , GRM.GetTodaysDate() );
        local timestamp = GRM.FormatTimeStamp ( { day , month , year } , false , false , GRM.S().globalDateFormat );

        if isMyEdit or CanEditGuildInfo() then
            finalReport = GRM.L ( "Timestamp Formatting has been Globally Set to: < {name} >" , timestamp );
        else
            finalReport = GRM.L ( "Your Guild Leader Has Globally Set the Timestamp Formatting to: < {name} >" , timestamp );
        end
        GRM.Report ( GRM.L ( "GRM:" ) .. " " .. finalReport );

        if GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame:IsVisible() then
            GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_OfficerOptionsFrame.GRM_TimestampSelected.GRM_TimestampSelectedText:SetText ( timestamp );
        end
    end
end

-- Method:          GRM.SetLeaderRankRestrictionSetting ( string , bool )
-- What it Does:    Checks for the number after the given match, and forces the player to adhere to those setting...
-- Purpose:         Conformity within the guild in the settings.
GRM.SetLeaderRankRestrictionSetting = function ( generalSyncIndex , isMyEdit )

    generalSyncIndex = tonumber ( generalSyncIndex );
    if generalSyncIndex ~= nil then

        if not CanEditGuildInfo() then
            GRM_G.GlobalControl1 = true;
        end

        -- Now, we need to verify it is a valid rank number. Note, indexes start at zero, but a general count starts at 1. So number of ranks is 10, while their index is 0-9.
        if generalSyncIndex > GuildControlGetNumRanks() - 1 then
            generalSyncIndex = GuildControlGetNumRanks() - 1;
        end
        -- Now, we check to see if yours matches it or not. If it doesn't, you need to change it.
        if generalSyncIndex ~= GRM.S().syncRank then

            local finalReport = "";
            if isMyEdit or CanEditGuildInfo() then
                finalReport = GRM.L ( "Sync Restrictions Globally Changed to {name} or Higher" , GuildControlGetRankName( generalSyncIndex + 1 ) );
            else
                finalReport = GRM.L ( "Your Guild Leader Has Set Sync Restrictions to {name} or Higher" , GuildControlGetRankName( generalSyncIndex + 1 ) );
            end
            GRM.Report ( GRM.L ( "GRM:" ) .. " " .. finalReport );

            GRM.S().syncRank = generalSyncIndex;
            if GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_SyncOptionsFrame:IsVisible() then
                GRM.CreateOptionsRankDropDown();
            end

        end
    else
        GRM_G.GlobalControl1 = false;
    end
end

-- Method:          GRM.SetLeaderBanRestrictionSetting ( string , bool )
-- What it Does:    Checks for the number after the given match, and forces the player to adhere to those Ban setting...
-- Purpose:         Conformity within the guild in the settings.
GRM.SetLeaderBanRestrictionSetting = function ( banSync , isMyEdit )
    banSync = tonumber ( banSync );

    -- first, very it is not nil
    if banSync ~= nil then

        if not CanEditGuildInfo() then
            GRM_G.GlobalControl2 = true;
        end
        
        -- Now, we need to verify it is a valid rank number. Note, indexes start at zero, but a general count starts at 1. So number of ranks is 10, while their index is 0-9.
        if banSync > GuildControlGetNumRanks() - 1 then
            banSync = GuildControlGetNumRanks() - 1;
        end
        -- Now, we check to see if yours matches it or not. If it doesn't, you need to change it.
        if banSync ~= GRM.S().syncRankBanList then

            if GRM.S().syncRank < banSync then
                GRM.S().syncRankBanList = GRM.S().syncRank;
                GRM.UpdateGuildInfoWithNewValue ( 3 , GRM.S().syncRank )

                GRM.Report ( GRM.L ( "Warning! Unable to select a Ban List rank below \"{name}\"" , GuildControlGetRankName( GRM.S().syncRankBanList + 1 ) )  .. "\n" .. GRM.L ( "Setting to match core filter rank" ) );

            else
                GRM.S().syncRankBanList = banSync;
                
                GRM.UpdateGuildInfoWithNewValue ( 3 , banSync )

                local finalReport = "";
                if isMyEdit or CanEditGuildInfo() then
                    finalReport = GRM.L ( "BAN Sync Restrictions Globally Changed to {name} or Higher" , GuildControlGetRankName( banSync + 1 ) );
                else
                    finalReport = GRM.L ( "Your Guild Leader Has Set BAN Sync Restrictions to {name} or Higher" , GuildControlGetRankName( banSync + 1 ) );
                end
                GRM.Report ( GRM.L ( "GRM:" ) .. " " .. finalReport );

                
                if GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_SyncOptionsFrame:IsVisible() then
                    GRM.CreateOptionsRankDropDown();
                end
            end
        end
    else
        GRM_G.GlobalControl2 = false;
    end
end

-- Method:          GRM.SetLeaderCustomNoteRestrictionSetting ( string , bool )
-- What it Does:    Checks for the number after the given match, and forces the player to adhere to those Ban setting...
-- Purpose:         Conformity within the guild in the settings.
GRM.SetLeaderCustomNoteRestrictionSetting = function ( customSyncIndex , isMyEdit )
    customSyncIndex = tonumber ( customSyncIndex );

    -- first, very it is not nil
    if customSyncIndex ~= nil then

        if not CanEditGuildInfo() then
            GRM_G.GlobalControl3 = true;
        end

        -- Now, we need to verify it is a valid rank number. Note, indexes start at zero, but a general count starts at 1. So number of ranks is 10, while their index is 0-9.
        if customSyncIndex > GuildControlGetNumRanks() - 1 then
            customSyncIndex = GuildControlGetNumRanks() - 1;
        end

        -- Now, we check to see if yours matches it or not. If it doesn't, you need to change it.
        if customSyncIndex ~= GRM.S().syncRankCustom then
            GRM.S().syncRankCustom = customSyncIndex;

            local finalReport = "";
            if isMyEdit or CanEditGuildInfo() then
                finalReport = GRM.L ( "CUSTOM NOTE Sync Restrictions Globally Changed to {name} or Higher" , GuildControlGetRankName( customSyncIndex + 1 ) );
            else
                finalReport = GRM.L ( "Your Guild Leader Has Set CUSTOM NOTE Sync Restrictions to {name} or Higher" , GuildControlGetRankName( customSyncIndex + 1 ) );
            end
            GRM.Report ( GRM.L ( "GRM:" ) .. " " .. finalReport );

                        for _ , player in pairs ( GRM.GetGuild() ) do
                if type ( player ) == "table" then
                    player.customNote[4] = customSyncIndex;
                    player.customNote[5] = false;
                end
            end

            if GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_SyncOptionsFrame:IsVisible() then
                GRM.CreateOptionsRankDropDown();
            end
        end
    else
        GRM_G.GlobalControl3 = false;
    end
end

-- Method:          GRM.SetLeaderJoinDateRestrictionSetting ( int , bool )
-- What it Does:    Checks for the number after the given match and forces all players to adhere to that setting.
-- Purpose:         Conformity and unification of addon settings and to prevent multiple people from adding join date to multiple locations.
GRM.SetLeaderJoinDateRestrictionSetting = function ( joinDateLocationIndex , isMyEdit )
    joinDateLocationIndex = tonumber ( joinDateLocationIndex );

    -- first, very it is not nil
    if joinDateLocationIndex ~= nil then

        if not CanEditGuildInfo() then
            GRM_G.GlobalControl4 = true;
        end

        -- Confirming it is GL controlled
        local location = { "Officer Note" , "Public Note" , "Custom Note" };
        local needsRefresh = false;

        if joinDateLocationIndex > 3 or joinDateLocationIndex < 0 then

            GRM.S().joinDateDestination = 1;
            GRM.S().addTimestampToNote = true;
            joinDateLocationIndex = 1;
            GRM.UpdateGuildInfoWithNewValue ( 5 , joinDateLocationIndex );

        -- Update guildinfo...
            GRM.Report ( GRM.L ( "Setting join date to destination index {num} is not valid. Value must be between 0 and 3. Setting to default of Officer Note." , nil , nil , joinDateLocationIndex ) );

            needsRefresh = true;

        end      
        
        -- Disabled = 0, Officer Note = 1, Public Note = 2 , custom = 3
        if joinDateLocationIndex ~= GRM.S().joinDateDestination then
            GRM.S().joinDateDestination = joinDateLocationIndex;
            GRM.UpdateGuildInfoWithNewValue ( 5 , joinDateLocationIndex );

            if joinDateLocationIndex == 0 then
                if GRM.S().addTimestampToNote then
                    GRM.S().addTimestampToNote = false
                end
            else
                GRM.S().addTimestampToNote = true;
            end
            needsRefresh = true;
        end

        if needsRefresh then
            local finalReport = "";
            if isMyEdit or CanEditGuildInfo() then
                if joinDateLocationIndex == 0 then
                    finalReport = GRM.L ( "Join Dates Globally Changed to no longer be added to the note when a player joins the guild" );
                else
                    finalReport = GRM.L ( "Join Dates Globally Changed to only be added to the {name}" , location[joinDateLocationIndex] );
                end
            else
                if joinDateLocationIndex == 0 then
                    finalReport = GRM.L ( "Your Guild Leader has disabled adding join dates to player notes" );
                else
                    finalReport = GRM.L ( "Your Guild Leader Has Set Join Dates to only be added to the {name}" , location[joinDateLocationIndex] );
                end
            end
            GRM.Report ( GRM.L ( "GRM:" ) .. " " .. finalReport );
        end

        if needsRefresh then
            if GRM_UI.GRM_RosterChangeLogFrame:IsVisible() then
                GRM_UI.ConfigureJoinDateLocation();
            end
        end

    else
        GRM_G.GlobalControl4 = false;
    end
end

-- Method:          GRM.SetLeaderUsingJoinTagHeaders ( string )
-- What it Does:    Checks if including the tag headers should be enabled or disabled
-- Purpose:         To help conformity in the guild on the destination of the notes.
GRM.SetLeaderUsingJoinTagHeaders = function( headerControl )
    if headerControl == "+" or headerControl == "-" then
        local needsRefresh = false;

        if not CanEditGuildInfo() then
            GRM_G.GlobalControl4_5 = true;
        end

        -- + = on, - = off
        if headerControl == "+" and not GRM.S().includeTag then
            GRM.S().includeTag = true;
            GRM.Report ( GRM.L ( "The \"{name}\" and \"{name2}\" tags have globally been set to be added to join date note entries." , GRM_G.customHeaderJoin , GRM_G.customHeaderRejoin ) );
            needsRefresh = true;
        elseif headerControl == "-" and GRM.S().includeTag then
            GRM.S().includeTag = false;
            GRM.Report ( GRM.L ( "The \"{name}\" and \"{name2}\" tags have globally been disabled from adding to join date note entries." , GRM_G.customHeaderJoin , GRM_G.customHeaderRejoin ) );
            needsRefresh = true;
        end

        if needsRefresh then
            if GRM_UI.GRM_RosterChangeLogFrame:IsVisible() then
                GRM_UI.ConfigureJoinDateLocation();
            end
            GRM.UpdateGuildInfoWithNewValue ( 6 , headerControl );
        end

    else
        GRM_G.GlobalControl4_5 = false;
    end
end



-- Method:          GRM.IsSyncRankGuildLeaderRestricted ( int )
-- What it Does:    Returns a boolean if the player's guild leader does have restriction standardization
--                  and returns the rank of that restriction by index.
-- Purpose:         Necessary for UX quality control on various methods to change and manipulate the settings.
GRM.IsSyncRankGuildLeaderRestricted = function ( selectedIndex )

    local result = false;
    local controlValue = GRM.GetGlobalControlValue ( selectedIndex );

    if controlValue ~= nil and controlValue ~= "X" then
        result = true;
        if tonumber ( controlValue ) ~= nil then
            controlValue = tonumber ( controlValue );
        end
    
        if selectedIndex == 1 then
            if controlValue > 17 or controlValue < 1 then
                controlValue = 1;
            end
    
        elseif selectedIndex > 1 and selectedIndex < 5 then -- 2 , 3 , 4
            if controlValue > GuildControlGetNumRanks() - 1 then   -- Set to lowest if necessary.
                controlValue = GuildControlGetNumRanks() - 1;
            end
    
        elseif selectedIndex == 5 then
            if controlValue > 3 or controlValue < 0 then
                -- default
                controlValue = 1;
            end
    
        elseif selectedIndex == 6 then
            if controlValue ~= "+" and controlValue ~= "-" then
                result = false;
            end
    
        elseif selectedIndex == 9 then
            if controlValue < 1 or controlValue > 2 then
                result = false;
            end
        end
    end    

    return result , controlValue;
end

-- Method:          GRM.ReportRankRestriction ( int )
-- What it Does:    Reports restriction rank if you try make a change to sync rank restrictions, yet in the guild info there are values set to control it.
-- Purpose:         Use for reporting any of the sync rank restrictions...
GRM.ReportRankRestriction = function ( rankIndex )
    if rankIndex ~= nil then
        GRM.Report ( GRM.L ( "GRM:" ) .. " " .. GRM.L ( "Unable to Change Rank. Guild Leader has set restriction to {name} or higher" , GuildControlGetRankName ( rankIndex + 1 ) ) );
    else
        GRM.Report ( GRM.L ( "GRM:" ) .. " " .. GRM.L ( "Unable to Change Rank. Guild Leader has set restriction level." ) );
    end
end

-- Method:          GRM.GetRankRestrictionText ( int )
-- What it Does:    Returns the text of the restriction rank guild leader has set it to for the controlled values in the guild info window
-- Purpose:         To make it obvious for player why they do not have access to sync rank controls.
GRM.GetRankRestrictionText = function ( rankIndex )
    local result = "";
    if rankIndex ~= nil then
        result = GRM.L ( "Unable to Change Rank. Guild Leader has set restriction to {name} or higher" , GuildControlGetRankName ( rankIndex + 1 ) );
    else
        result = GRM.L ( "Unable to Change Rank. Guild Leader has set restriction level." );
    end
    return result;
end

-- Method:          GRM.GetGlobalSettingsProgress()
-- What it Does:    Compiles the progress with the global functions
-- Purpose:         For use with creating an export of them.
GRM.GetGlobalSettingsProgress = function()
    local rulesString = GRM.GetRulesString();
    local result = {};

    if rulesString ~= nil then
        local guildControl = { GRM.GetEachGlobalControl( rulesString ) };
            
        for i = 1 , #guildControl do
            if guildControl[i] ~= "X" then
                table.insert ( result , { true , guildControl[i] } );
            else
                table.insert ( result , { false } );
            end
        end
        
    end
    return result;
end

-- Method:          GRM.AllGlobalsAreSet()
-- What it Does:    Returns true if all globals are set in the guildInfo properly
-- Purpose:         To help with guild Info global settings and tooltip info for UX
GRM.AllGlobalsAreSet = function()
    local result = true;
    local globals = GRM.GetGlobalSettingsProgress();

    if #globals > 0 then
        for i = 1 , #globals do
            if i < 10 and not globals[i][1] then
                result = false;
                break;
            end
        end
    else
        result = false;
    end

    return result;
end

-- Method:          GRM.SetGlobalControlsToGuildInfo()
-- What it Does:    Rebuilds the guild control tags and inserts them back into the guildInfo
-- Purpose:         Give the user the ability to control some specific functions globally.
GRM.SetGlobalControlsToGuildInfo = function()
    local controlString = GRM.GetAllGlobalRulesAsString();
    local existingRules = GRM.GetRulesString();
    local notes = GetGuildInfoText();
    local result = "";

    if existingRules ~= nil then
        -- ok rules already there, so we will need to save over them.
        local startIndex , endIndex = string.find ( notes , existingRules , 1 , true );
        if startIndex ~= nil and endIndex ~= nil then
            result = ( string.sub ( notes , 1 , startIndex - 5 ) .. controlString .. string.sub ( notes , endIndex + 3 ) );
        end
    else
        -- Just append to the end
        result = GRM.Trim ( notes ) .. "\n" .. controlString;
    end
    
    -- Ok, let's set the values
    if #result > 0 and GRM_UI.GuildInfoEditBox then
        if #result <= GRM_UI.GuildInfoEditBox:GetMaxLetters() then

            SetGuildInfoText ( result );
            GRM.Report ( GRM.L ( "Global controls exported to the guild info note. Updating..." ) );
            
            -- No delay is really needed but this is a fun progression feeling
            C_Timer.After ( 1.5 , function()
                GRM.Report ( GRM.L ( "Complete" ) .. " - " .. GRM.L ( "It may take up to 60 seconds for other guild members to detect the changes and update." ) );
            end);
            
            -- The delay needs to be here as sometimes the note, while update on your end, takes about 10 seconds or less to get a callback that the server properly updated it.
            C_Timer.After ( 10 , function()
                GRMsync.SendMessage ( "GRM_GCHAT" , "GINFOUPDATE?" , "GUILD" );     -- Send out to force others to update their permissions
                GRM.UpdateGuildLeaderPermissions ( true , true );
            end);

        else
            GRM.Report ( GRM.L ( "Unable to add globals controls to GuildInfo. There is not enough room." ) );
            GRM.Report ( GRM.L ( "You need to clear {num} characters to fit the control tags" , nil , nil , ( #result - GRM_UI.GuildInfoEditBox:GetMaxLetters() ) ) );
        end
    end

end

-- Method:          GRM.GetAllGlobalRulesAsString()
-- What it Does:    Builds the Globals string for the GuildInfo window
-- Purpose:         Quality of Life to help ease new players into the addon.
GRM.GetAllGlobalRulesAsString = function()

    local modifier = "+";
    if not GRM.S().includeTag then
        modifier = "-";
    end

    local customHeader = "^^";
    if GRM.S().customTags[1] == "" or GRM.S().customTags[1] == GRM.L ( "Joined:" ) then
        customHeader = "XX";
    else
        customHeader = GRM.S().customTags[1];
    end

    local customRejoinHeader = "";
    if GRM.S().customTags[2] == "" or GRM.S().customTags[2] == GRM.L ( "Rejoined:" ) then
        customRejoinHeader = "XX";
    else
        customRejoinHeader = GRM.S().customTags[2];
    end

    local noteEnabled = 1;
    if not GRM.S().noteSetEnabled then
        noteEnabled = 2;
    end
 
    local globalRules = ( "grm^" .. 
    GRM.S().globalDateFormat .. ";" ..
    GRM.S().syncRank .. ";" ..
    GRM.S().syncRankBanList .. ";" ..
    GRM.S().syncRankCustom .. ";" ..
    GRM.S().joinDateDestination .. ";" ..
    modifier .. ";" ..
    customHeader .. ";" ..
    customRejoinHeader .. ";" ..
    noteEnabled .. ";" .. 
    "X" .. "^g" );

    return globalRules;
end

------------------------------
------ NOTE SCANNING ---------
---- SEARCH AND PARSING ------
------------------------------

-- Method:          GRM.CheckAllDates( boolean )
-- What it Does:    Returns all of the date info of players who have notes, but no GRM data, ot the other way around, which note it is in, and the status of the note in terms of consistency with addon/note data
-- Purpose:         To manage the extremely complicated parsing of the notes to properly display note data...
GRM.CheckAllDates = function( showAll )
    local result;
    local canReadOfficer = GRM.CanEditOfficerNote();    -- No need to call for it over and over
    local collectNamesThatMisMatched = {};
    local noteLocation = 0;     -- 1 = officer, 2 = public, 3 = custom, 4 = multipleLocations
    local noteStatus = 0; -- 1 = doNotMatch , 2 = noteInWrongNote , 3 = NoNoteExists , 4 = doNotMatch && noteInWrongNote , 5 = doNotMatch && correctLocation && dateInMultipleNotes , 6 = doNotMatch && noteInWrongNote && dateInMultipleNotes
                          -- 7 = noteInWrongNote && dateInMultipleNotes , 8 == doMatch && CorrectLocation && multipleNotes , 9-12 - no GRM date imported yet

    for _ , player in pairs ( GRM.GetGuild() ) do
        if type ( player ) == "table" then
            noteStatus = 0;
            noteLocation = 0;
            result = nil;

            -- Check Officer
            if canReadOfficer and player.officerNote~= "" then
                result = GRM.GetParsedDate ( player.officerNote);
                -- If the note is found here, but not found in the proper place...
                if result ~= nil then
                    noteLocation = 1;
                    if GRM.S().joinDateDestination ~= 1 then
                        noteStatus = 2
                    end
                end
            end
            
            -- Custom Notes
            if result == nil and player.customNote[6] ~= "" then
                result = GRM.GetParsedDate ( player.customNote[6] );
                if result ~= nil then
                    noteLocation = 3;
                    if GRM.S().joinDateDestination ~= 3 then
                        noteStatus = 2
                    end
                end
            end

            -- Check Public
            if result == nil and player.note ~= "" then
                result = GRM.GetParsedDate ( player.note );
                if result ~= nil then
                    noteLocation = 2;
                    if GRM.S().joinDateDestination ~= 2 then
                        noteStatus = 2
                    end
                end
            end

            if result ~= nil then
                -- If GRM addon date does not match parsed note date.
                if not GRM.DatesDoMatch ( result , player.name ) then

                    -- If note is not in the right location AND it doesn't match
                    if noteStatus == 2 then
                        noteStatus = 4; -- 4 = doNotMatch && noteInWrongNote
                        if GRM.IsDateInOtherNotes ( player.name , noteLocation ) then
                            noteStatus = 6; -- 6 = doNotMatch && noteInWrongNote && dateInMultipleNotes
                            noteLocation = 4; -- Multiple Locations
                        end
                        if player.joinDateHist[1][1] == 0 then
                            if noteStatus == 4 then
                                noteStatus = 9;     -- noteInWrongNote && no GRM date saved
                            elseif noteStatus == 6 then
                                noteStatus = 10;    -- noteInWrongNote && dateInMultipleNotes && no GRM date saved
                            end
                        end
                    else
                        -- Note is IN the right location, but they do not match... Let's see if they don't match, IS in the right location, but is also in multiple notes.
                        noteStatus = 1;
                        if GRM.IsDateInOtherNotes ( player.name , noteLocation ) then
                            noteStatus = 5; -- 5 = doNotMatch && correctLocation && dateInMultipleNotes
                            noteLocation = 4; -- Multiple Locations
                            if player.joinDateHist[1][1] == 0 then
                                noteStatus = 11; -- correctLocation && dateInMultipleNotes && No GRM date saved
                            end
                        else
                            if player.joinDateHist[1][1] == 0 then
                                noteStatus = 12; -- correctLocation && No GRM date saved
                            end
                        end
                    end
                    table.insert ( collectNamesThatMisMatched , { player.name , result , noteLocation , noteStatus , player.name , false } );
                else
                    -- Else, they DO match!!!
                    -- If note matches, but is in the wrong location
                    if noteStatus == 2 then
                        if GRM.IsDateInOtherNotes ( player.name , noteLocation ) then
                            noteStatus = 7; -- 7 = noteInWrongNote && dateInMultipleNotes
                            noteLocation = 4; -- Multiple Locations
                        end
                    else
                        -- doMatch && InRightNote && MultipleNotes
                        if GRM.IsDateInOtherNotes ( player.name , noteLocation ) then
                            noteStatus = 8; -- 8 == doMatch && CorrectLocation && multipleNotes
                            noteLocation = 4; -- Multiple Locations
                        end
                    end
                    if showAll or ( not showAll and noteStatus ~= 0 ) then
                        table.insert ( collectNamesThatMisMatched , { player.name , result , noteLocation , noteStatus , player.name , false } );
                    end
                end
            elseif player.joinDateHist[1][1] ~= 0 then
                -- Date is in GRM, but there is no note.
                noteStatus = 3 -- Doesn't exist, or at least was not identified in the parsing...
                table.insert ( collectNamesThatMisMatched , { player.name , result , noteLocation , noteStatus , player.name , false } );
            end
        end
    end
    sort ( collectNamesThatMisMatched , function ( a , b ) return a[1] < b[1] end );
    return collectNamesThatMisMatched;
end

-- Method:          GRM.GetParsedDate ( string )
-- What it Does:    Algorithm for combining all pieces of the puzzle into attempting to parse out the date properly, and returns the { day, month , year } if valid
--                  Otherwise it returns nil;
-- Purpose:         Assist in controlling the overall logic of parsing the date into a workable format to reverse engineer the date stored in the notes.
GRM.GetParsedDate = function( note )
    local result;

    -- Remove some common formatting anomalies before we parse.
    note = GRM.CleanupNoteDate ( note );

    -- Now, let's parse the note (monthName include so no need to reparse for localization leanness)
    local date , firstPartOfNote , lastPartOfNote , index , monthName = GRM.GetNoteDateDetails ( note );

    -- now, we identify the day, month, year of note;
    if date then
        result = GRM.ParseDateFormat ( date , index , monthName );
    end

    return result;
end

-- Method:          GRM.RemoveDateFromNote ( string )
-- What it Does:    Removes the date from the note
-- Purpose:         To reverse engineer the notes and replace them with different dates.
GRM.RemoveDateFromNote = function ( note )
    local date , firstPartOfNote , lastPartOfNote , index , monthName = GRM.GetNoteDateDetails ( note );
    local success = false;
    local result = "";

    if date then
        firstPartOfNote = GRM.ClearJoinTag ( firstPartOfNote );
        success = true;

        if #firstPartOfNote > 0 then
            firstPartOfNote = firstPartOfNote .. " ";
        end

        result = GRM.Trim ( firstPartOfNote .. lastPartOfNote );
    end

    return result , success;     -- Cleanup the result;
end

-- Method:          GRM.ClearJoinTag ( string )
-- What it Does:    Checks a given string from a note and searches for the "Joined:" text and returns true, as well as the string at the next appropriate start position
-- Purpose:         Make parsing notes extremely simple.
GRM.ClearJoinTag = function ( note )
    local headers = { GRM.L ( "Joined" ) , "joined" , "Joined" , GRM.L ( "Rejoined" ) , "rejoined" , "Rejoined" , "Rejoin" , "rejoin" , "Returned" , "returned" , GRM_G.customHeaderRejoin , GRM_G.customHeaderJoin };

    if note and note ~= "" then
        for i = 1 , #headers do
            if note:find ( headers[i] ) then
                note = string.gsub ( note , headers[i] .. ":" , "" );
                note = string.gsub ( note , headers[i] , "" );
                break;
            end
        end
    end

    return GRM.Trim ( note );
end

-- Method:          GRM.ParseDateFormat ( string , int , string )
-- What it Does:    Returns the day, month, year of the parsed timestamo from note
-- Purpose:         To more easily parse the player notes
GRM.ParseDateFormat = function ( date , index , monthName )
    local result = {};
    local day , month , year;

    if monthName then
        month = monthEnum [GRM.OrigL ( monthName )];
    end
    
    if index == 1 then
        day = tonumber ( string.match ( date , "(%d+)%s+") );
        year = tonumber ( string.match ( date , "'(%d+)") );
    
    elseif index == 2 then
        day = tonumber ( string.match ( date , "(%d+)%s+") );
        year = tonumber ( string.match ( date , "%s+(%d+)") );
    
    elseif index == 3 then
        year = tonumber ( string.match ( date , "(%d%d%d%d)%-") );
        month = tonumber ( string.match ( date , "%-(%d+)%-" ) );
        day = tonumber ( string.match ( date , "%d%d%d%d%-%d+%-(%d%d?)" ) );

        if month > 12 then
            day = month;
            month = tonumber ( string.match ( date , "%d%d%d%d%-%d+%-(%d%d?)" ) );
        end

    elseif index == 4 then
        year = tonumber ( string.match ( date , "%-(%d%d%d%d)" ) );
        month = tonumber ( string.match ( date , "%-(%d+)%-") );
        day = tonumber ( string.match ( date , "(%d+)%-%d+%-%d%d%d%d" ) );
        
        if month > 12 then
            day = month;
            month = tonumber ( string.match ( date , "(%d+)%-%d+%-%d%d%d%d" ) );
        end

    elseif index == 5 then
        day = tonumber ( string.match ( date , "(%d+)%-") );
        year = tonumber ( string.match ( date , "%-(%d%d%d%d)") );
    
    elseif index == 6 then
        day = tonumber ( string.match ( date , "(%d+)%-") );
        month = tonumber ( string.match ( date , "%-(%d+)%-") );
        year = tonumber ( string.match ( date , "%d+%-%d+%-(%d%d)") );
    
        -- Now, we don't know yet which format this date is in, is it MM-DD-YY or DD-MM-YY
        -- Let's see if month > 12 then we know they need to be flipped
        if month > 12 or ( GRM.S().globalDateFormat == 11 and day < 13 ) then
            day = month;
            month = tonumber ( string.match ( date , "(%d+)%-") );
        end
    
    elseif index == 7 then
        day = tonumber ( string.match ( date , "(%d+)/") );
        month = tonumber ( string.match ( date , "/(%d+)/") );
        year = tonumber ( string.match ( date , "%d+/%d+/(%d%d)") );
    
        -- Now, we don't know yet which format this date is in, is it MM/DD/YY or DD/MM/YY
        -- Let's see if month > 12 then we know they need to be flipped
        if month > 12 or ( GRM.S().globalDateFormat == 12 and day < 13 ) then
            day = month;
            month = tonumber ( string.match ( date , "(%d+)/") );
        end

    elseif index == 8 then
        day = tonumber ( string.match ( date , "%d%d%d%d%.%d%d%.(%d%d)" ) );
        month = tonumber ( string.match ( date , "%.(%d%d)%." ) );
        year = tonumber ( string.match ( date , "(%d%d%d%d)%.%d%d%.%d%d" ) );
    
    elseif index == 9 then
        day = tonumber ( string.match ( date , "(%d+)%.") );
        month = tonumber ( string.match ( date , "%.(%d+)%.") );
        year = tonumber ( string.match ( date , "%d+%.%d+%.(%d%d)") );
    
        -- Now, we don't know yet which format this date is in, is it MM.DD.YY or DD.MM.YY
        -- Let's see if month > 12 then we know they need to be flipped
        if month > 12 or ( GRM.S().globalDateFormat == 13 and day < 13 ) then
            day = month;
            month = tonumber ( string.match ( date , "(%d+)%.") );
        end
    
    elseif index == 10 then
        day = tonumber ( string.match ( date , "(%d+)%.") );
        month = tonumber ( string.match ( date , "%.(%d+)%.") );
        year = tonumber ( string.match ( date , "%d+%.%d+%.(%d%d%d%d)") );
    
        -- Now, we don't know yet which format this date is in, is it MM.DD.YYYY or DD.MM.YYYY
        -- Let's see if month > 12 then we know they need to be flipped
        if month > 12 or ( GRM.S().globalDateFormat == 14 and day < 13 ) then
            day = month;
            month = tonumber ( string.match ( date , "(%d+)%.") );
        end
    
    elseif index == 11 then
        day = tonumber ( string.match ( date , "%s+(%d+)%s+'" ) );
        year = tonumber ( string.match ( date , "'(%d%d)") );
    
    elseif index == 12 then
        day = tonumber ( string.match ( date , "%s+(%d+)%s+" ) );
        year = tonumber ( string.match ( date , "%s+%d+%s+(%d%d)" ) );
    
    elseif index == 13 then
        day = tonumber ( string.match ( date , "-(%d+)-" ) );
        year = tonumber ( string.match ( date , "-(%d%d%d%d)" ) );

    end

    if year < 1000 then
        year = year + 2000;
    end

    if GRM.IsValidYear ( year ) and GRM.IsValidMonth ( month ) and GRM.IsValidDay ( day , month , year ) then
        result = { day , month , year };
    else
        result = nil;
    end

    return result;
end

-- Method:          GRM.CleanupNoteDate ( string )
-- What it Does:    Removes any "st" or "th" abbrev. in English - Compatible as no other selected languages have dates that this would mess with.
-- Purpose:         Increases compatibility to some custom formats for parsing.
GRM.CleanupNoteDate = function ( note )
    local first , last;
    note = string.gsub ( string.gsub ( string.gsub ( note , ", " , " " ) , "%. " , " " ) , "," , " " ); -- cleans up the commans and possibly period typos.

    -- Remove the "th" if it is preceeded by a number -- %d represents a digit
    while string.find ( note , "%d+th" ) ~= nil do
        first , last = string.find ( note , "%d+th" );
        note = string.sub ( note , 1 , first ) .. string.sub ( note , last + 1 );
    end

    -- same as above.
    while string.find ( note , "%d+st" ) ~= nil do
        first , last = string.find ( note , "%d+st" );
        note = string.sub ( note , 1 , first ) .. string.sub ( note , last + 1 );
    end

    return note;
end

-- Method:          GRM.FindStartOfDate ( note )
-- What it Does:    Parses the given note for a GRM styled note format and returns it, as well as the text before the note and the text after.
-- Purpose:         Finding the date in the note can be challenging with so many different formats. This does that as long as it is in a GRM supported format.
GRM.GetNoteDateDetails = function ( note )
    local firstPartOfNote , lastPartOfNote = "" , "";
    local date;
    local monthName;
    local startIndex , lastIndex = 0 , 0;
    local datePatterns = {          -- Example for May 30th, 2021
        "%d+%s+~#~%s+'%d+",         -- 30 May '21                   1
        "%d+%s+~#~%s+%d+",          -- 30 May 21                    2
        "%d%d%d%d%-%d+%-%d%d?",     -- 2021-05-30                   3
        "%d+%-%d+%-%d%d%d%d",       -- 30-05-2021                   4
        "%d+%-~#~%-%d%d%d%d",       -- 30-May-2021                  5
        "%d+%-%d+%-%d%d",           -- 30-05-21     or 05-30-21     6
        "%d+/%d+/%d%d",             -- 30/05/21     or 05/30/21     7
        "%d%d%d%d%.%d%d%.%d%d",     -- 2021.05.30                   8
        "%d+%.%d+%.%d%d",           -- 30.05.21     or 05.30.21     9
        "%d+%.%d+%.%d%d%d%d",       -- 30.05.2021   or 05.30.2021   10
        "~#~%s+%d+%s+'%d%d",        -- May 30 '21                   11
        "~#~%s+%d+%s+%d%d",         -- May 30 21                    12
        "~#~%s+%d+%s+%d%d%d%d"      -- May 30 2021                  13
        
    }

    local index = 0;
    for i = 1 , #datePatterns do

        if ( i > 2 and i < 11 and i ~= 5 ) then -- Dates with string names will be excluded from the logic.

            date = string.match ( note , datePatterns[i] );
            if date then
                startIndex , lastIndex = string.find ( note , datePatterns[i] );
                index = i;
                if i == 9 then
                    if string.match ( note , datePatterns[i + 1] ) ~= nil then
                        date = string.match ( note , datePatterns[i + 1] );
                        startIndex , lastIndex = string.find ( note , datePatterns[i + 1] );
                        index = 10;
                    end
                end
                
                break;
            end
        else
            -- swap in the date
            for j = 1 , #monthAbbrev do
                date = string.match ( note , string.gsub ( datePatterns[i] , "~#~" , GRM.L ( monthAbbrev[j] ) ) );
                if date then
                    startIndex , lastIndex = string.find ( note , string.gsub ( datePatterns[i] , "~#~" , GRM.L ( monthAbbrev[j] ) ) ) ;
                    monthName = GRM.L ( monthAbbrev[j] );
                    break;
                end
            end

            if date then
                index = i;
                break;
            end
        end
    end

    if date then
        if startIndex > 0 then
            firstPartOfNote = string.sub ( note , 1 , startIndex - 1 );
        end
        if not firstPartOfNote then
            firstPartOfNote = "";
        end
        if lastIndex > 0 then
            lastPartOfNote = string.sub ( note , lastIndex + 1 );
        end
        if not lastPartOfNote then
            lastPartOfNote = "";
        end
    end

    return date , firstPartOfNote , lastPartOfNote , index , monthName;
end

-- Method:          GRM.IsDateInOtherNotes ( int , int )
-- What it Does:    Returns true if the date is found in multiple locations...
-- Purpose:         So the addon can know if it is necessary to cleanup notes.
GRM.IsDateInOtherNotes = function ( name , noteLocation )
    local result = false;
    local player = GRM.GetPlayer ( name );

    if player then
        -- Check officer first
        if noteLocation ~= 1 and GRM.CanEditOfficerNote() then
            if GRM.GetParsedDate ( player.officerNote ) ~= nil then
                result = true;
            end
        end

        -- Check Custom Note next
        if not result and noteLocation ~= 3 then
            if GRM.GetParsedDate ( player.customNote[6] ) ~= nil then
                result = true;
            end
        end

        -- Check Public Note next
        if not result and noteLocation ~= 2 then
            if GRM.GetParsedDate ( player.note ) ~= nil then
                result = true;
            end
        end
    end

    return result;
end

-- Method:          GRM.IsValidYear ( int )
-- What it Does:    Returns true if the year is greater than 3 (2004 is when game launched), and less than or equal to current year
-- Purpose:         Easy reusable check when parsing dates in the notes.
GRM.IsValidYear = function ( year )
    local result = false;
    
    if year ~= nil and type ( year ) == "number" then
        if year > 2000 then
            year = year - 2000;
        end
        if year > 3 and year <= ( GRM.GetCurrentCalendarTime().year - 2000 ) then
            result = true;
        end
    end
    return result;
end

-- Method:          GRM.IsValidMonth ( int )
-- What it Does:    Returns true if the index is valid between 1 and 12
-- Purpose:         Verification of accurate data.
GRM.IsValidMonth = function ( month )
    local result = false;
    if month ~= nil and type ( month ) == "number" and month > 0 and month < 13 then
        result = true;
    end
    return result;
end 

-- Method:          GRM.IsValidDay ( int , int , int )
-- What it Does:    Returns true if the day is within the correct limits of that month, leap year accounted for.
-- Purpose:         Easy reusable check when parsing dates in the notes.
GRM.IsValidDay = function ( day , month , year )
    local result = false;
    if day ~= nil and type ( day ) == "number" and type ( month ) == "number" and type ( year ) == "number" and day < 32 and day > 0 and month < 13 and month > 0 then
        if ( month == 2 and day == 29 and GRM.IsLeapYear ( year ) ) or ( day <= daysInMonth[ tostring(month) ] ) then
            result = true;
        end
    end
    return result;
end

-- Method:          GRM.GetParsedNoteDateNumbers ( string )
-- What it Does:    Returns which separtor being use, the parsed values of the date, and the note with the date parsed out
-- Purpose:         Easier editing of the player notes on the fly, particularly for the advanced join date tool
GRM.GetParsedNoteDateNumbers = function ( note )
    note = GRM.Trim ( note );
    local separators = { " " , "-" , "/" , "." };
    local first, middle, last;
    local result;
    local pattern = "";
    
    for i = 1 , #separators do
        if string.find ( note , separators[i] , 1 , true ) ~= nil then

            first = string.match ( note , "(.+)" .. separators[i] );
            if first then
                note = string.match ( note , separators[i] .. "(.+)" );

                middle = string.match ( note , "(.+)" .. separators[i] );
                if middle then
                    pattern = "%d+";
                    note = string.match ( note , separators[i] .. "(.+)" );
                    last = string.match ( note , pattern ); -- Under the assumption that the final numbers are always numbers.
                    if last then
                        if not tonumber ( last ) then   
                            pattern = "%d%d%d%d";
                            last = string.match ( note , pattern );  -- first we check if there are 4.
                            if not last then
                                pattern = "%d%d";
                                last = string.match ( note , pattern );  -- Now we check for 2
                                if not last then
                                    pattern = "%d";
                                    last = string.match ( note , pattern );  -- Now we check for 1 (Format #15)
                                end
                            end
                        end
                        if last then
                            result = { separators[i] , first , middle , last , string.match ( note , pattern .. "(.+)" ) };
                        end
                    end
                end

            end

            break;
        end
    end
    return result;
end

-- Method:          GRM.DatesDoMatch ( array , string )
-- What it Does:    Returns true of the parsed date and the set date are the same, otherwise returns false
-- Purpose:         So player cna easily flag inconsistencies in the notes and correct them.
GRM.DatesDoMatch = function ( dates , name )
    local result = false;
    local player = GRM.GetPlayer ( name );

    if player.joinDateHist[1][1] > 0 then
        if dates[1] == player.joinDateHist[1][1] and dates[2] == player.joinDateHist[1][2] and dates[3] == player.joinDateHist[1][3] then
            result = true;
        end
    end

    return result
end


-----------------------
-- AUDIT TOOL FRAMES --
-----------------------

-- Method:          GRM.AuditRefresh()
-- What it Does:    Refreshes and updates all the frames in the audit JD tool
-- Purpose:         Easy refresh management for UX
GRM.AuditRefresh = function( fullRefresh )   
    if GRM.S().JDAuditToolFilter then
        GRM_UI.GRM_AuditJDTool.GRM_AuditJDToolCheckBox:SetChecked( true );
    end
    
    GRM.RefreshJDAuditToolFrames ( not GRM.S().JDAuditToolFilter , fullRefresh );
end

-- Method:          GRM.IsAnyHighlighted()
-- What it Does:    Returns true if at least one button is highlighted
-- Purpose:         Use as boolean gate
GRM.IsAnyHighlighted = function()
    local result = false;

    for i = 1 , #GRM_G.AuditToolGuildies do
        if GRM_G.AuditToolGuildies[i][6] then
            result = true;
            break;
        end
    end

    return result;
end

-- Method:          GRM.GetNoteName()
-- What it Does:    Returns the string note name of the configured default destination for the join date
-- Purpose:         Cleaner code is all
GRM.GetNoteName = function ()
    local result = "";
    if GRM.S().joinDateDestination == 1 then
       result = GRM.L ( "Officer Note" );
    elseif GRM.S().joinDateDestination == 2 then
        result = GRM.L ( "Public Note" );
    else
        result = GRM.L ( "Custom Note" );
    end
    return result;
end

-- Method:          GRM.GetCountNeedingAttention ( bool )
-- What it Does:    Gets the number of players in the audit that still need to be dealt with
-- Purpose:         For UI info reporting to the player.
GRM.GetCountNeedingAttention = function ( showAll )
    local count = #GRM_G.AuditToolGuildies;
    if showAll then
        count = 0;
        for i = 1 , #GRM_G.AuditToolGuildies do
            if GRM_G.AuditToolGuildies[i][4] > 0 then
                count = count + 1;
            end
        end
    end

    return count;
end

-- Method:          GRM.GetCountThatAreInMultipleLocations()
-- What it Does:    Gets the number of players in the audit that have dates in multiple locations
-- Purpose:         For UI info reporting to the player.
GRM.GetCountThatAreInMultipleLocations = function ()
    local count = 0;

    for i = 1 , #GRM_G.AuditToolGuildies do
        if GRM_G.AuditToolGuildies[i][4] == 2 or ( GRM_G.AuditToolGuildies[i][4] > 4 and GRM_G.AuditToolGuildies[i][4] < 12 ) then
            count = count + 1;
        end
    end

    return count;
end

-- Method:          GRM.GetCountIncorrectLocationNotCorrectNotImported()
-- What it Does:    Gets the number of players in the audit that have dates in multiple locations, not correct location, and not yet imported.
-- Purpose:         For UI info reporting to the player.
GRM.GetCountIncorrectLocationNotCorrectNotImported = function ()
    local count = 0;

    for i = 1 , #GRM_G.AuditToolGuildies do
        if GRM_G.AuditToolGuildies[i][4] == 9 or GRM_G.AuditToolGuildies[i][4] == 10 then
            count = count + 1;
        end
    end

    return count;
end

-- Method:          GRM.RefreshJDAuditToolsTextFrames ( bool )
-- What it Does:    Rechecks that the button text matches the logic
-- Purpose:         Quality controls on UX
GRM.RefreshJDAuditToolsTextFrames = function( showAll )
    local count = GRM.GetCountNeedingAttention ( showAll );

    if count > 0 then
        GRM_UI.GRM_AuditJDTool.GRM_JDToolScrollBorderFrame.GRM_AuditToolText6:SetText ( GRM.L ( "{num} Join Dates Need Attention" , nil , nil , count ) );
        GRM_UI.GRM_AuditJDTool.GRM_JDToolScrollBorderFrame.GRM_AuditToolText6:SetTextColor ( 0.64 , 0.102 , 0.102 );
    else
        GRM_UI.GRM_AuditJDTool.GRM_JDToolScrollBorderFrame.GRM_AuditToolText6:SetText ( GRM.L ( "All Complete" , nil , nil , count ) );
        GRM_UI.GRM_AuditJDTool.GRM_JDToolScrollBorderFrame.GRM_AuditToolText6:SetTextColor ( 0 , 0.8 , 1.0 );
    end

    if GRM.CanEditOfficerNote() then
        GRM_UI.GRM_AuditJDTool.GRM_JDToolScrollBorderFrame.GRM_AuditToolText7:Hide();
    else
        GRM_UI.GRM_AuditJDTool.GRM_JDToolScrollBorderFrame.GRM_AuditToolText7:Show();
    end

    local isHighlighted = GRM.IsAnyHighlighted();

    if not isHighlighted then
        GRM_UI.GRM_AuditJDTool.GRM_AuditJDToolButton4Text:SetText ( GRM.L ( "Fix all mismatched GRM dates with the note date" ) );
        GRM_UI.GRM_AuditJDTool.GRM_AuditJDToolButton3Text:SetText ( GRM.L ( "Fix all mismatched note dates with GRM saved date" ) );
        GRM_UI.GRM_AuditJDTool.GRM_AuditJDToolButton2Text:SetText ( GRM.L ( "Import all missing join dates from the note date" ) );
        GRM_UI.GRM_AuditJDTool.GRM_AuditJDToolButton1Text:SetText ( GRM.L ( "Add all missing saved dates to the {name}" , GRM.GetNoteName() ) );
        GRM_UI.GRM_AuditJDTool.GRM_AuditJDToolButton7Text:SetText ( GRM.L ( "Clear all join dates from incorrect note locations" ) );
    else
        GRM_UI.GRM_AuditJDTool.GRM_AuditJDToolButton4Text:SetText ( GRM.L ( "Fix selected mismatched GRM dates with the note date" ) );
        GRM_UI.GRM_AuditJDTool.GRM_AuditJDToolButton3Text:SetText ( GRM.L ( "Fix selected mismatched note dates with GRM saved date" ) );
        GRM_UI.GRM_AuditJDTool.GRM_AuditJDToolButton2Text:SetText ( GRM.L ( "Import selected missing join dates from the note date" ) );
        GRM_UI.GRM_AuditJDTool.GRM_AuditJDToolButton1Text:SetText ( GRM.L ( "Add selected missing saved dates to {name}" , GRM.GetNoteName() ) );
        GRM_UI.GRM_AuditJDTool.GRM_AuditJDToolButton7Text:SetText ( GRM.L ( "Clear selected join dates from incorrect note locations" ) );
    end
end

-- Method:          GRM.RefreshJDAuditToolFrames ()
-- What it Does:    Builds the scroll frame for the audit tools
-- Purpose:         Quality of Life management feature
GRM.RefreshJDAuditToolFrames = function ( showAll , fullRefresh )
    local hybridScrollFrameButtonCount = 13;
    local buttonHeight = 25;
    local scrollHeight = 0;
    local buttonWidth = GRM_UI.GRM_AuditJDTool.GRM_JDToolScrollFrame:GetWidth() - 5;
    if fullRefresh then
        GRM_G.AuditToolGuildies = GRM.CheckAllDates ( showAll );
        GRM_G.JDAuditToolLastSelection = "";
        GRM_UI.GRM_AuditJDTool.GRM_JDToolScrollChildFrame.Offset = hybridScrollFrameButtonCount;
        GRM_UI.GRM_AuditJDTool.GRM_JDToolScrollFrameSlider:SetValue ( 0 );  
    end

    -- Just refreshes the frames
    GRM.RefreshJDAuditToolsTextFrames ( showAll );

    GRM_UI.GRM_AuditJDTool.GRM_JDToolScrollChildFrame.AllButtons = GRM_UI.GRM_AuditJDTool.GRM_JDToolScrollChildFrame.AllButtons or {};  -- Create a table for the Buttons.
    GRM_UI.GRM_AuditJDTool.GRM_JDToolScrollChildFrame.Offset = GRM_UI.GRM_AuditJDTool.GRM_JDToolScrollChildFrame.Offset or ( hybridScrollFrameButtonCount );

    if GRM_UI.GRM_AuditJDTool.GRM_JDToolScrollChildFrame.Offset < hybridScrollFrameButtonCount then
        GRM_UI.GRM_AuditJDTool.GRM_JDToolScrollChildFrame.Offset = hybridScrollFrameButtonCount;
    elseif GRM_UI.GRM_AuditJDTool.GRM_JDToolScrollChildFrame.Offset > hybridScrollFrameButtonCount and GRM_UI.GRM_AuditJDTool.GRM_JDToolScrollChildFrame.Offset > #GRM_G.AuditToolGuildies then
        GRM_UI.GRM_AuditJDTool.GRM_JDToolScrollChildFrame.Offset = #GRM_G.AuditToolGuildies;
    end

    for i = 1 , #GRM_G.AuditToolGuildies do
        -- Build HybridScrollFrame Buttons
        if i <= hybridScrollFrameButtonCount then
            if not GRM_UI.GRM_AuditJDTool.GRM_JDToolScrollChildFrame.AllButtons[i] then
                local button = CreateFrame ( "Button" , "JDAuditButton" .. i .. "_" .. 1 , GRM_UI.GRM_AuditJDTool.GRM_JDToolScrollChildFrame );
                GRM_UI.GRM_AuditJDTool.GRM_JDToolScrollChildFrame.AllButtons[i] = { button , button:CreateFontString ( nil , "OVERLAY" , "GameFontWhiteTiny" ), button:CreateFontString ( nil , "OVERLAY" , "GameFontWhiteTiny" ), button:CreateFontString ( nil , "OVERLAY" , "GameFontWhiteTiny" ), button:CreateFontString ( nil , "OVERLAY" , "GameFontWhiteTiny" ), button:CreateFontString ( nil , "OVERLAY" , "GameFontWhiteTiny" )
                };

                button = GRM_UI.GRM_AuditJDTool.GRM_JDToolScrollChildFrame.AllButtons[i][1];
                if i == 1 then
                    button:SetPoint ( "TOP" , GRM_UI.GRM_AuditJDTool.GRM_JDToolScrollChildFrame , "TOP" , -1 , 0 );
                else 
                    button:SetPoint ( "TOPLEFT" , GRM_UI.GRM_AuditJDTool.GRM_JDToolScrollChildFrame.AllButtons[i-1][1] , "BOTTOMLEFT" , 0 , 0 );
                end

                GRM.BuildJDToolHybridButtons ( i );

                button:SetSize ( GRM_UI.GRM_AuditJDTool.GRM_JDToolScrollFrame:GetWidth() - 7 , buttonHeight );
                button:SetHighlightTexture ( "Interface\\Buttons\\UI-Panel-Button-Highlight" );
            end
        end

        if i >= ( GRM_UI.GRM_AuditJDTool.GRM_JDToolScrollChildFrame.Offset - hybridScrollFrameButtonCount + 1 ) and i <= GRM_UI.GRM_AuditJDTool.GRM_JDToolScrollChildFrame.Offset then
            GRM.SetJDAuditValues ( i - ( GRM_UI.GRM_AuditJDTool.GRM_JDToolScrollChildFrame.Offset - hybridScrollFrameButtonCount ) , i );
            GRM_UI.GRM_AuditJDTool.GRM_JDToolScrollChildFrame.AllButtons[i - ( GRM_UI.GRM_AuditJDTool.GRM_JDToolScrollChildFrame.Offset - hybridScrollFrameButtonCount )][1]:Show();
        end
        
        -- Slider Height is controlled by tallying how many of these are necessary
        scrollHeight = scrollHeight + buttonHeight;
    end
    -- Hide unused buttons...
    for i = #GRM_G.AuditToolGuildies + 1 , #GRM_UI.GRM_AuditJDTool.GRM_JDToolScrollChildFrame.AllButtons do
        GRM_UI.GRM_AuditJDTool.GRM_JDToolScrollChildFrame.AllButtons[i][1]:Hide();
    end

    GRM.SetHybridScrollFrameSliderParameters ( 
        GRM_UI.GRM_AuditJDTool.GRM_JDToolScrollChildFrame , GRM_UI.GRM_AuditJDTool.GRM_JDToolScrollFrame , GRM_UI.GRM_AuditJDTool.GRM_JDToolScrollFrameSlider , 
        buttonWidth , buttonHeight , scrollHeight , #GRM_G.AuditToolGuildies , GRM_UI.GRM_AuditJDTool.GRM_JDToolScrollChildFrame.AllButtons , 
        GRM.JDAuditToolHybridShiftDown , GRM.JDAuditToolHybridShiftUp , hybridScrollFrameButtonCount
    );
end

-- Method:          GRM.BuildJDToolHybridButtons ( int )
-- What it Does:    Initiates the buttons and logic for the JD Audit tool buttons
-- Purpose:         Compartmentalize the code for easier call back to.
GRM.BuildJDToolHybridButtons = function ( ind , isResizeAction )

    local button1 = GRM_UI.GRM_AuditJDTool.GRM_JDToolScrollChildFrame.AllButtons[ind][1];
    local buttonText1 = GRM_UI.GRM_AuditJDTool.GRM_JDToolScrollChildFrame.AllButtons[ind][2];
    local buttonText2 = GRM_UI.GRM_AuditJDTool.GRM_JDToolScrollChildFrame.AllButtons[ind][3];
    local buttonText3 = GRM_UI.GRM_AuditJDTool.GRM_JDToolScrollChildFrame.AllButtons[ind][4];
    local buttonText4 = GRM_UI.GRM_AuditJDTool.GRM_JDToolScrollChildFrame.AllButtons[ind][5];
    local buttonText5 = GRM_UI.GRM_AuditJDTool.GRM_JDToolScrollChildFrame.AllButtons[ind][6];

    
    buttonText1:SetFont ( GRM_G.FontChoice , GRM_G.FontModifier + 11 );
    buttonText1:SetJustifyH ( "LEFT" );
    buttonText1:SetWidth ( 115 )
    buttonText1:SetPoint ( "LEFT" , button1 , 10 , 0 );

    buttonText2:SetPoint ( "LEFT" , buttonText1 , "RIGHT" , 10 , 0 );
    buttonText2:SetFont ( GRM_G.FontChoice , GRM_G.FontModifier + 11 );
    buttonText2:SetWidth ( 100 );
    buttonText2:SetJustifyH ( "CENTER" );

    buttonText3:SetPoint ( "LEFT" , buttonText2 , "RIGHT" , 10 , 0 );
    buttonText3:SetFont ( GRM_G.FontChoice , GRM_G.FontModifier + 11 );
    buttonText3:SetWidth ( 100 );
    buttonText3:SetJustifyH ( "CENTER" );

    buttonText4:SetPoint ( "LEFT" , buttonText3 , "RIGHT" , 0 , 0 );
    buttonText4:SetFont ( GRM_G.FontChoice , GRM_G.FontModifier + 11 );
    buttonText4:SetWidth ( 100 );
    buttonText4:SetJustifyH ( "CENTER" );

    buttonText5:SetPoint ( "LEFT" , buttonText4 , "RIGHT" , 10 , 0 );
    buttonText5:SetFont ( GRM_G.FontChoice , GRM_G.FontModifier + 11 );
    buttonText5:SetWidth ( 205 );
    buttonText5:SetJustifyH ( "LEFT" );

    if not isResizeAction then
        button1:EnableMouse ( true );
        button1:RegisterForDrag ( "LeftButton" );

        button1:SetScript ( "OnDragStart" , function()
            GRM_UI.GRM_AuditJDTool:StartMoving();
        end);
        button1:SetScript ( "OnDragStop" , function()
            GRM_UI.GRM_AuditJDTool:StopMovingOrSizing()
        end);

        -- Set button logic...
        button1:SetScript ( "OnClick" , function ( self , key )
            if key == "LeftButton" then
                for j = 1 , #GRM_UI.GRM_AuditJDTool.GRM_JDToolScrollChildFrame.AllButtons do
                    if self == GRM_UI.GRM_AuditJDTool.GRM_JDToolScrollChildFrame.AllButtons[j][1] then
                        if not IsShiftKeyDown() or GRM_UI.GRM_AuditJDTool.GRM_JDToolScrollChildFrame.AllButtons[j][2]:GetText() == GRM_G.JDAuditToolLastSelection then
                            GRM_G.JDAuditToolLastSelection = GRM_UI.GRM_AuditJDTool.GRM_JDToolScrollChildFrame.AllButtons[j][2]:GetText();
                            -- Identify the player in the GRM_G.AuditToolGuildies
                            for k = 1 , #GRM_G.AuditToolGuildies do
                                if GRM_G.AuditToolGuildies[k][1] == GRM_UI.GRM_AuditJDTool.GRM_JDToolScrollChildFrame.AllButtons[j][2]:GetText() then

                                    if IsControlKeyDown() then
                                        if IsShiftKeyDown() then
                                            GRM.SearchPlayerInLog ( GRM_UI.GRM_AuditJDTool.GRM_JDToolScrollChildFrame.AllButtons[j][2]:GetText() );
                                        else
                                            GRM.OpenPlayerWindow ( GRM_G.AuditToolGuildies[k][1] );
                                        end
                                    else
                                        if GRM_G.AuditToolGuildies[k][6] then
                                            self:UnlockHighlight();
                                            GRM_G.AuditToolGuildies[k][6] = false;
                                        else
                                            self:LockHighlight();
                                            GRM_G.AuditToolGuildies[k][6] = true;
                                        end
                                        GRM.AuditRefresh ( false );
                                    end
                                    break;
                                end
                            end
                        -- For mass Shift-Click selection.
                        elseif GRM_G.JDAuditToolLastSelection ~= "" then
                            if IsShiftKeyDown() and IsControlKeyDown() then
                                GRM.SearchPlayerInLog ( GRM_UI.GRM_AuditJDTool.GRM_JDToolScrollChildFrame.AllButtons[j][2]:GetText() );
                            else
                                local count = 0;
                                local currentSelec = 0;
                                local prevSelec = 0;

                                for k = 1 , #GRM_G.AuditToolGuildies do
                                    if GRM_G.AuditToolGuildies[k][1] == GRM_UI.GRM_AuditJDTool.GRM_JDToolScrollChildFrame.AllButtons[j][2]:GetText() then
                                        count = count + 1;
                                        currentSelec = k;
                                    elseif GRM_G.AuditToolGuildies[k][1] == GRM_G.JDAuditToolLastSelection then
                                        count = count + 1;
                                        prevSelec = k
                                    end

                                    if count == 2 then
                                        break;
                                    end
                                end
                                local diff = 0;
                                if currentSelec > prevSelec then
                                    diff = currentSelec - prevSelec;
                                    for k = currentSelec , prevSelec , - 1 do
                                        GRM_G.AuditToolGuildies[k][6] = true;
                                    end

                                    if j > diff then
                                        diff = j-diff;
                                    else
                                        diff = 1;
                                    end

                                    -- Lock the buttons' Highlights
                                    for s = j , diff , -1 do
                                        GRM_UI.GRM_AuditJDTool.GRM_JDToolScrollChildFrame.AllButtons[s][1]:LockHighlight();
                                    end
                                    
                                else
                                    diff = prevSelec - currentSelec;
                                    for k = currentSelec , prevSelec do
                                        GRM_G.AuditToolGuildies[k][6] = true;
                                    end

                                    if j + diff > #GRM_UI.GRM_AuditJDTool.GRM_JDToolScrollChildFrame.AllButtons then
                                        diff = #GRM_UI.GRM_AuditJDTool.GRM_JDToolScrollChildFrame.AllButtons;
                                    else
                                        diff = diff + j;
                                    end

                                    -- Lock the buttons' Highlights
                                    for s = j , diff do
                                        GRM_UI.GRM_AuditJDTool.GRM_JDToolScrollChildFrame.AllButtons[s][1]:LockHighlight();
                                    end
                                end
                                GRM.AuditRefresh ( false );
                            end
                        end
                        break;
                    end
                end
            end
        end);

        -- Tooltips
        button1:SetScript ( "OnEnter" , function ()
            GRM_UI.SetTooltipScale();
            GRM.UpdateJDAuditTooltip( ind );
            GameTooltip:Show();
        end);
        button1:SetScript ( "OnLeave" , function ()
            GRM.RestoreTooltip();
        end);
    end

end

-- Method:          GRM.UpdateJDAuditTooltip ( int )
-- What it Does:    Refreshes the JD Audit Tool Tooltip
-- Purpose:         So, on scrolling, the tooltip easily updates on the fly as well.
GRM.UpdateJDAuditTooltip = function ( ind )
    GameTooltip:SetOwner ( GRM_UI.GRM_AuditJDTool.GRM_JDToolScrollChildFrame.AllButtons[ind][1] , "ANCHOR_CURSOR" );
    GameTooltip:AddLine ( GRM_UI.GRM_AuditJDTool.GRM_JDToolScrollChildFrame.AllButtons[ind][2]:GetText() , GRM_UI.GRM_AuditJDTool.GRM_JDToolScrollChildFrame.AllButtons[ind][2]:GetTextColor() );
    GameTooltip:AddLine ( GRM.L ( "|CFFE6CC7FClick|r to select player" ) );
    GameTooltip:AddLine ( GRM.L ( "|CFFE6CC7FShift-Click|r Second Button to Select All In-Between" ) );
    GameTooltip:AddLine ( GRM.L ( "{custom1} to open Player Window" , nil , nil , nil , "|CFFE6CC7F" .. GRM.L ( "Ctrl-Click" ) .. "|r" ) );
    GameTooltip:AddLine ( GRM.L ( "{custom1} to Search the Log for Player" , nil , nil , nil , "|CFFE6CC7F" .. GRM.L ( "Ctrl-Shift-Click" ) .. "|r" ) );
end

-- Method:          GRM.JDAuditToolHybridShiftDown()
-- What it Does:    Shifts the buttons up one spot for hybrid scrollframe purpose
-- Purpose:         To keep from having to refresh the entire frames over and over. Now, it just shifts everything over once. Fast and lightweight for scrollwheel control
GRM.JDAuditToolHybridShiftDown = function ()
    local buttons = GRM_UI.GRM_AuditJDTool.GRM_JDToolScrollChildFrame.AllButtons;
    local MouseOverButton = 0;
    -- Shift them down...
    for i = 1 , #buttons - 1 do
        buttons[i][2]:SetText( buttons[i+1][2]:GetText() );
        buttons[i][2]:SetTextColor ( buttons[i+1][2]:GetTextColor ( buttons[i+1][2]:GetText() ) );
        buttons[i][3]:SetText( buttons[i+1][3]:GetText() );
        buttons[i][3]:SetTextColor ( buttons[i+1][3]:GetTextColor ( buttons[i+1][3]:GetText() ) );
        buttons[i][4]:SetText( buttons[i+1][4]:GetText() );
        buttons[i][4]:SetTextColor ( buttons[i+1][4]:GetTextColor ( buttons[i+1][4]:GetText() ) );
        buttons[i][5]:SetText( buttons[i+1][5]:GetText() );
        buttons[i][5]:SetTextColor ( buttons[i+1][5]:GetTextColor ( buttons[i+1][5]:GetText() ) );
        buttons[i][6]:SetText( buttons[i+1][6]:GetText() );
        buttons[i][6]:SetTextColor ( buttons[i+1][6]:GetTextColor ( buttons[i+1][6]:GetText() ) );
        -- Identify the player in the guildies
        for k = 1 , #GRM_G.AuditToolGuildies do
            if GRM_G.AuditToolGuildies[k][1] == buttons[i+1][2]:GetText() then
                if GRM_G.AuditToolGuildies[k][6] then
                    buttons[i][1]:LockHighlight();
                else
                    buttons[i][1]:UnlockHighlight();
                end
                break;
            end
        end

        if MouseOverButton == 0 and buttons[i][1]:IsMouseOver() then
            MouseOverButton = i;
        end
    end
    GRM.JDAuditSetLastValue();
    if MouseOverButton > 0 then
        GRM.UpdateJDAuditTooltip( MouseOverButton );
    end
end

-- Method:          GRM.JDAuditToolHybridShiftUp()
-- What it Does:    Shifts the buttons up one spot for hybrid scrollframe purpose
-- Purpose:         To keep from having to refresh the entire frames over and over. Now, it just shifts everything over once. Fast and lightweight for scrollwheel control
GRM.JDAuditToolHybridShiftUp = function ()
    local buttons = GRM_UI.GRM_AuditJDTool.GRM_JDToolScrollChildFrame.AllButtons;
    local MouseOverButton = 0;
    
    -- Shift them down...
    for i = #buttons , 2 , -1 do
        buttons[i][2]:SetText( buttons[i-1][2]:GetText() );
        buttons[i][2]:SetTextColor ( buttons[i-1][2]:GetTextColor ( buttons[i-1][2]:GetText() ) );
        buttons[i][3]:SetText( buttons[i-1][3]:GetText() );
        buttons[i][3]:SetTextColor ( buttons[i-1][3]:GetTextColor ( buttons[i-1][3]:GetText() ) );
        buttons[i][4]:SetText( buttons[i-1][4]:GetText() );
        buttons[i][4]:SetTextColor ( buttons[i-1][4]:GetTextColor ( buttons[i-1][4]:GetText() ) );
        buttons[i][5]:SetText( buttons[i-1][5]:GetText() );
        buttons[i][5]:SetTextColor ( buttons[i-1][5]:GetTextColor ( buttons[i-1][5]:GetText() ) );
        buttons[i][6]:SetText( buttons[i-1][6]:GetText() );
        buttons[i][6]:SetTextColor ( buttons[i-1][6]:GetTextColor ( buttons[i-1][6]:GetText() ) );
        -- Identify the player in the guildies
        for k = 1 , #GRM_G.AuditToolGuildies do
            if GRM_G.AuditToolGuildies[k][1] == buttons[i-1][2]:GetText() then
                if GRM_G.AuditToolGuildies[k][6] then
                    buttons[i][1]:LockHighlight();
                else
                    buttons[i][1]:UnlockHighlight();
                end
                break;
            end
        end

        if MouseOverButton == 0 and buttons[i][1]:IsMouseOver() then
            MouseOverButton = i;
        end
    end
    GRM.JDAuditSetFirstValue();
    if MouseOverButton > 0 then
        GRM.UpdateJDAuditTooltip( MouseOverButton );
    end
end

-- Method           GRM.SetJDAuditValues ( int , int )
-- What it Does:    Sets the values of the fontstrings for each button
-- Purpose:         Build the JD Audit Tool UI
GRM.SetJDAuditValues = function ( ind , ind2 )
    local name = GRM_G.AuditToolGuildies[ind2][1];
    local player = GRM.GetPlayer ( name );
    local classColor = GRM.GetClassColorRGB ( player.class , false )
    local grmDate = "";
    local noteDate = "";
    local status = "";
    local loc = "";
    local noteLoc = { GRM.L ( "Officer Note" ) , GRM.L ( "Public Note" ) , GRM.L ( "Custom Note" ) , GRM.L ( "Multiple" ) };
    local reasons = { 
        GRM.L ( "Mismatched dates" ) , GRM.L ( "Matching date found in wrong note location" ) , GRM.L ( "Date not added to note" ) , 
        GRM.L ( "Mismatched dates, and found in wrong note location" ) , GRM.L ( "Mismatched date found in multiple locations, including correct" ) , GRM.L ( "Mismatched date found in multiple incorrect note locations" ) ,
        GRM.L ( "Matching date found in multiple incorrect note locations" ) , GRM.L ( "Matching date found in multiple locations, including correct" ) , GRM.L ( "Date found in incorrect note, but not yet imported" ) , 
        GRM.L ( "Date found in multiple incorrect notes, but not yet imported" ) , GRM.L ( "Date found in multiple locations, including correct, but not yet imported" ) , GRM.L ( "Date found in correct note location, but not yet imported" )
     };

    -- Text Coloring
    local complete = { 0 , 0.77 , 0.063 };
    local Incomplete = { 0.64 , 0.102 , 0.102 };
    local badNote = { 1.0 , 0.647 , 0 };
    local normN = { 1 , 1 , 1 };
    local noteLocC , statusC , noteF , dateSetF = {} , {} , {} , {};


    if player.joinDateHist[1][6] then
        grmDate = GRM.FormatTimeStamp ( { player.joinDateHist[1][1] , player.joinDateHist[1][2] , player.joinDateHist[1][3] } , false );
        dateSetF = normN;
    else
        grmDate = GRM.L ( "Not Set" );
        dateSetF = Incomplete;
    end

    if GRM_G.AuditToolGuildies[ind2][3] == 0 then
        noteDate = GRM.L ( "Not Found" );
        loc = noteDate;
        noteLocC = badNote;
        noteF = Incomplete;
    else
        noteDate = GRM.FormatTimeStamp ( { GRM_G.AuditToolGuildies[ind2][2][1] , GRM_G.AuditToolGuildies[ind2][2][2] , GRM_G.AuditToolGuildies[ind2][2][3] } , false , false );
        noteF = normN;
        loc = noteLoc[GRM_G.AuditToolGuildies[ind2][3]];
        if GRM.S().joinDateDestination == GRM_G.AuditToolGuildies[ind2][3] then
            noteLocC = complete;
        else
            noteLocC = badNote;
        end
    end
    
    if GRM_G.AuditToolGuildies[ind2][4] > 0 then
        status = reasons [ GRM_G.AuditToolGuildies[ind2][4] ]
        statusC = Incomplete;
    else
        status = GRM.L ( "Complete" );
        statusC = complete;
    end

    GRM_UI.GRM_AuditJDTool.GRM_JDToolScrollChildFrame.AllButtons[ind][2]:SetText ( name );
    GRM_UI.GRM_AuditJDTool.GRM_JDToolScrollChildFrame.AllButtons[ind][2]:SetTextColor ( classColor[1] , classColor[2] , classColor[3] );
    GRM_UI.GRM_AuditJDTool.GRM_JDToolScrollChildFrame.AllButtons[ind][3]:SetText ( grmDate );
    GRM_UI.GRM_AuditJDTool.GRM_JDToolScrollChildFrame.AllButtons[ind][3]:SetTextColor ( dateSetF[1] , dateSetF[2] , dateSetF[3] );
    GRM_UI.GRM_AuditJDTool.GRM_JDToolScrollChildFrame.AllButtons[ind][4]:SetText ( noteDate );
    GRM_UI.GRM_AuditJDTool.GRM_JDToolScrollChildFrame.AllButtons[ind][4]:SetTextColor ( noteF[1] , noteF[2] , noteF[3] );
    GRM_UI.GRM_AuditJDTool.GRM_JDToolScrollChildFrame.AllButtons[ind][5]:SetText ( loc );
    GRM_UI.GRM_AuditJDTool.GRM_JDToolScrollChildFrame.AllButtons[ind][5]:SetTextColor ( noteLocC[1] , noteLocC[2] , noteLocC[3] );
    GRM_UI.GRM_AuditJDTool.GRM_JDToolScrollChildFrame.AllButtons[ind][6]:SetText ( status );
    GRM_UI.GRM_AuditJDTool.GRM_JDToolScrollChildFrame.AllButtons[ind][6]:SetTextColor ( statusC[1] , statusC[2] , statusC[3] );

    if GRM_G.AuditToolGuildies[ind2][6] then
        GRM_UI.GRM_AuditJDTool.GRM_JDToolScrollChildFrame.AllButtons[ind][1]:LockHighlight();
    else
        GRM_UI.GRM_AuditJDTool.GRM_JDToolScrollChildFrame.AllButtons[ind][1]:UnlockHighlight();
    end

    -- Update the tooltip if underlying data changes
    if GameTooltip:IsVisible() and GRM_UI.GRM_AuditJDTool.GRM_JDToolScrollChildFrame.AllButtons[ind][1]:IsMouseOver() then 
        GRM.UpdateJDAuditTooltip ( ind )
    end
end

-- Method:          GRM.JDAuditSetLastValue()
-- What it Does:    Triggers the setting fo all values at index 13 of the JD Audit tool
-- Purpose:         On the single line shift, you end up with 1 on the edge that needs to be built
GRM.JDAuditSetLastValue = function()
    GRM.SetJDAuditValues ( #GRM_UI.GRM_AuditJDTool.GRM_JDToolScrollChildFrame.AllButtons , GRM_UI.GRM_AuditJDTool.GRM_JDToolScrollChildFrame.Offset );
end

-- Method:          GRM.JDAuditSetFirstValue()
-- What it Does:    Triggers the setting fo all values at index 1 of the JD Audit tool
-- Purpose:         On the single line shift, you end up with 1 on the edge that needs to be built
GRM.JDAuditSetFirstValue = function()
    GRM.SetJDAuditValues ( 1 , GRM_UI.GRM_AuditJDTool.GRM_JDToolScrollChildFrame.Offset - #GRM_UI.GRM_AuditJDTool.GRM_JDToolScrollChildFrame.AllButtons + 1 );
end

-- Method:          GRM.ConvertGRMDateFromNote ( array )
-- What it Does:    Initiates the flow of editing the GRM dates using the notes as reference, and refreshes the frames
-- Purpose:         For mass use in the JD Audit tool
GRM.ConvertGRMDateFromNote = function ( player )
    -- Set Join Date
    GRM.EditJoinDateManually ( player[1] , player[2][1] , player[2][2] , player[2][3] );
end

-- Method:          GRM.ConvertNoteFromGRM ( array )
-- What it Does:    Initiates the flow of editing the GRM dates using the notes as reference, and refreshes the frames
-- Purpose:         For mass use in the JD Audit tool
GRM.ConvertNoteFromGRM = function ( player )
    GRM.EditSavedNoteDateManually ( player );
end

-- Method:          GRM.EditJoinDateManually ( string , int , int , int )
-- What it Does:    changes the player's GRM join date to match the note join date.
-- Purpose:         Useful mini join date tool to cycle mass update join dates for guildies.
GRM.EditJoinDateManually = function ( name , day , month , year )

    local player = GRM.GetPlayer ( name );

    if player then

        player.joinDateHist[1][1] = day;
        player.joinDateHist[1][2] = month;
        player.joinDateHist[1][3] = year;
        player.joinDateHist[1][4] = GRM.ConvertToStandardFormatDate ( day , month , year );
        player.joinDateHist[1][5] = time();
        player.joinDateHist[1][6] = true;
        player.joinDateHist[1][7] = 1;

        -- If it was unKnown before
        player.joinDateUnknown = false;

        -- Gotta update the event tracker date too for anniversary!!!
        player.events[1][1][1] = day;
        player.events[1][1][2] = month;
        player.events[1][1][3] = year;
        player.events[1][2] = false;  -- Gotta Reset the "reported already" boolean!
        GRM.RemoveFromCalendarQue ( name , 1 , nil );

    end

    -- Refresh the dates on the frames!!!
    if GRM_UI.GRM_MemberDetailMetaData:IsVisible() and GRM_G.currentName == name then
        if GRM_UI.GRM_MemberDetailMetaData.GRM_SetUnknownButton:IsVisible() or GRM_UI.GRM_MemberDetailMetaData.GRM_SyncJoinDateSideFrame:IsVisible() or GRM_UI.GRM_MemberDetailMetaData.GRM_CoreAltFrame.GRM_AddAltEditFrame:IsVisible() then
            GRM.ClearAllFrames( false );
        end
        GRM.PopulateMemberDetails ( GRM_G.currentName );
    end
end

-- Method:          GRM.EditSavedNoteDateManually ( string , int )
-- What it Does:    changes the player's note date to match the GRM save date.
-- Purpose:         Useful mini join date tool to cycle mass update join dates for guildies.
GRM.EditSavedNoteDateManually = function ( member )
    local player = GRM.GetPlayer ( member[1] );
    local tempNote = "";
    local name = "";
    local index;
    local success = false;
    local noteHeader = "";

    if GRM.S().includeTag then
        noteHeader = GRM_G.customHeaderJoin;
    end

    local finalNote = "";
    
    if player then
        index = nil;
        name = "";
        tempNote = "";

        -- Find them in the guild indexes to modify offier/public notes
        for h = 1 , GRM.GetNumGuildies() do
            name = GetGuildRosterInfo( h );
            if name == member[1] then
                index = h;
                break;
            end
        end

        -- Set the repeated note formatting to be added to note.
        finalNote = noteHeader .. " " .. GRM.FormatTimeStamp ( { player.joinDateHist[1][1] , player.joinDateHist[1][2] , player.joinDateHist[1][3] } , false , false , GRM.S().globalDateFormat ) .. " ";

        -- Modify the notes
        if member[3] == 4 then       -- if true, multiple locations
            if GRM.CanViewOfficerNote() then
                tempNote , success = GRM.RemoveDateFromNote ( player.officerNote );
                if success then
                    -- yes, it was modified
                    finalNote = ( GRM.Trim ( finalNote .. tempNote ) );
                    if GRM.GetNumLetters ( finalNote ) <= GRM_G.MaxOfficerNoteSize then                    -- To avoid errors need to add protections against trying to add > 31 chars.
                        player.officerNote = finalNote;
                        GuildRosterSetOfficerNote ( index , player.officerNote );
                    else
                        finalNote = ( GRM.Trim ( GRM.FormatTimeStamp ( { player.joinDateHist[1][1] , player.joinDateHist[1][2] , player.joinDateHist[1][3] } , false , false, GRM.S().globalDateFormat ) ) .. " " .. tempNote );    -- Remove header, try adding again.
                        if GRM.GetNumLetters ( finalNote ) <= GRM_G.MaxOfficerNoteSize then
                            player.officerNote = finalNote;
                            GuildRosterSetOfficerNote ( index , player.officerNote );
                        end
                    end
                    success = false;
                end
            end
            if ( GRM.CanViewOfficerNote() or player.name == GRM_G.addonUser ) then
                tempNote , success = GRM.RemoveDateFromNote ( player.note );
                if success then
                    -- yes, it was modified
                    finalNote = ( GRM.Trim ( finalNote .. tempNote ) );
                    if GRM.GetNumLetters ( finalNote ) <= GRM_G.MaxPublicNoteSize then                    -- To avoid errors need to add protections against trying to add > 31 chars.
                        player.note = finalNote;
                        GuildRosterSetPublicNote ( index , player.note );
                    else
                        finalNote = ( GRM.Trim ( GRM.FormatTimeStamp ( { player.joinDateHist[1][1] , player.joinDateHist[1][2] , player.joinDateHist[1][3] } , false , false , GRM.S().globalDateFormat ) ) .. " " .. tempNote );    -- Remove header, try adding again.
                        if GRM.GetNumLetters ( finalNote ) <= GRM_G.MaxPublicNoteSize then
                            player.note = finalNote;
                            GuildRosterSetPublicNote ( index , player.note );
                        end
                    end
                    success = false;
                end
            end
            tempNote , success = GRM.RemoveDateFromNote ( player.customNote[6] );
            if success then
                -- yes, it was modified
                player.customNote[2] = time();
                player.customNote[3] = GRM_G.addonUser;
                finalNote = ( GRM.Trim ( finalNote .. tempNote ) );
                if GRM.GetNumLetters ( finalNote ) > GRM_G.MaxCustomNoteSize then
                    finalNote = string.sub ( finalNote , 1 , GRM_G.MaxCustomNoteSize );  -- Cheating a little here by just cutting off the end. Likely no one will ever notice with 150 chars to spare
                end
                player.customNote[6] = ( finalNote );
                success = false;
            end
        else
            if member[3] == 1 and GRM.CanViewOfficerNote()  then
                tempNote , success = GRM.RemoveDateFromNote ( player.officerNote );
                if success then
                    -- yes, it was modified
                    finalNote = ( GRM.Trim ( finalNote .. tempNote ) );
                    if GRM.GetNumLetters ( finalNote ) <= GRM_G.MaxOfficerNoteSize  then                    -- To avoid errors need to add protections against trying to add > 31 chars.
                        player.officerNote = finalNote;
                        GuildRosterSetOfficerNote ( index , player.officerNote );
                    else
                        finalNote = ( GRM.Trim ( GRM.FormatTimeStamp ( { player.joinDateHist[1][1] , player.joinDateHist[1][2] , player.joinDateHist[1][3] } , false , false , GRM.S().globalDateFormat ) ) .. " " .. tempNote );    -- Remove header, try adding again.
                        if GRM.GetNumLetters ( finalNote ) <= GRM_G.MaxOfficerNoteSize  then
                            player.officerNote = finalNote;
                            GuildRosterSetOfficerNote ( index , player.officerNote );
                        end
                    end
                    success = false;
                end
            elseif member[3] == 2 and ( GRM.CanViewOfficerNote() or player.name == GRM_G.addonUser ) then
                tempNote , success = GRM.RemoveDateFromNote ( player.note );
                if success then
                    -- yes, it was modified
                    finalNote = ( GRM.Trim ( finalNote .. tempNote ) );
                    if GRM.GetNumLetters ( finalNote ) <= GRM_G.MaxPublicNoteSize then                    -- To avoid errors need to add protections against trying to add > 31 chars.
                        player.note = finalNote;
                        GuildRosterSetPublicNote ( index , player.note );
                    else
                        finalNote = ( GRM.Trim ( GRM.FormatTimeStamp ( { player.joinDateHist[1][1] , player.joinDateHist[1][2] , player.joinDateHist[1][3] } , false , false , GRM.S().globalDateFormat ) ) .. " " .. tempNote );    -- Remove header, try adding again.
                        if GRM.GetNumLetters ( finalNote ) <= GRM_G.MaxPublicNoteSize then
                            player.note = finalNote;
                            GuildRosterSetPublicNote ( index , player.note );
                        end
                    end
                    success = false;
                end
            elseif member[3] == 3 then
                tempNote , success = GRM.RemoveDateFromNote ( player.customNote[6] );
                if success then
                    -- yes, it was modified
                    player.customNote[2] = time();
                    player.customNote[3] = GRM_G.addonUser;
                    finalNote = ( GRM.Trim ( finalNote .. tempNote ) );
                    if GRM.GetNumLetters ( finalNote ) > GRM_G.MaxCustomNoteSize then
                        finalNote = string.sub ( finalNote , 1 , GRM_G.MaxCustomNoteSize );  -- Cheating a little here by just cutting off the end. Likely no one will ever notice with 150 chars to spare
                    end
                    player.customNote[6] = ( finalNote );
                    success = false;
                end
            end
        end
    end

    -- Refresh the dates on the frames!!!
    if GRM_UI.GRM_MemberDetailMetaData:IsVisible() and GRM_G.currentName == member[1] then
        if GRM_UI.GRM_MemberDetailMetaData.GRM_SetUnknownButton:IsVisible() or GRM_UI.GRM_MemberDetailMetaData.GRM_SyncJoinDateSideFrame:IsVisible() or GRM_UI.GRM_MemberDetailMetaData.GRM_CoreAltFrame.GRM_AddAltEditFrame:IsVisible() then
            GRM.ClearAllFrames( false );
        end
        GRM_G.pause = false;
        GRM.PopulateMemberDetails ( GRM_G.currentName );
        GRM_G.pause = true;
    end
end
 
-- Method:          GRM.AddDateTagToDefaultNote ( array )
-- What it Does:    Adds the join date properly to the default note
-- Purpose:         To control the Join Date being added to default note location, whilst not adding it if already found there, and not overwriting current note, and editing it slightly
--                  to be joined within the character count limit of the notes properly
GRM.AddDateTagToDefaultNote = function ( member , getCount )
    local player = GRM.GetPlayer ( member[1] );
    local name = "";
    local index;
    local noteHeader = "";
    local count = 0;
    if GRM.S().includeTag then
        noteHeader = GRM_G.customHeaderJoin;
    end
    local finalNote = "";
    local success = false;
    
    if player then

        index = nil;
        name = "";

        -- Find them in the guild indexes to modify offier/public notes
        if not getCount then
            for h = 1 , GRM.GetNumGuildies() do
                name = GetGuildRosterInfo( h );
                if name == member[1] then
                    index = h;
                    break;
                end
            end
        end

        -- Set the repeated note formatting to be added to note.
        finalNote = noteHeader .. " " .. GRM.FormatTimeStamp ( { player.joinDateHist[1][1] , player.joinDateHist[1][2] , player.joinDateHist[1][3] } , false , false, GRM.S().globalDateFormat );

        if GRM.CanViewOfficerNote() then
            -- Public and officer
            if GRM.S().joinDateDestination == 1 then
                -- Officer is default.
                success = select ( 2 , GRM.RemoveDateFromNote ( player.officerNote ) ); -- If it successfully removes something we know we can stop here and don't need to continue further as it is not necessary to continue
                if not success then
                    -- Nope, not modified, which means good to import
                    finalNote = GRM.Trim ( finalNote .. " " .. player.officerNote );
                    if GRM.GetNumLetters ( finalNote ) <= GRM_G.MaxOfficerNoteSize  then
                        if not getCount then
                            player.officerNote = finalNote;
                            GuildRosterSetOfficerNote ( index , player.officerNote );
                        else
                            count = count + 1;
                        end
                    else
                        finalNote = GRM.FormatTimeStamp ( { player.joinDateHist[1][1] , player.joinDateHist[1][2] , player.joinDateHist[1][3] } , false , false , GRM.S().globalDateFormat ) .. " " .. player.officerNote;        -- Remove the header and try again
                        if GRM.GetNumLetters ( finalNote ) <= GRM_G.MaxOfficerNoteSize  then
                            if not getCount then
                                player.officerNote = finalNote;
                                GuildRosterSetOfficerNote ( index , player.officerNote );
                            else
                                count = count + 1;
                            end
                        end
                    end
                    success = false;
                end
            elseif GRM.S().joinDateDestination == 2 then
                success = select ( 2 , GRM.RemoveDateFromNote ( player.note ) ); -- If it successfully removes something we know we can stop here and don't need to continue further as it is not necessary to continue
                if not success then
                    -- Nope, not modified, which means good to import
                    finalNote = GRM.Trim ( finalNote .. " " .. player.note );
                    if GRM.GetNumLetters ( finalNote ) <= GRM_G.MaxPublicNoteSize then
                        if not getCount then
                            player.note = finalNote;
                            GuildRosterSetPublicNote ( index , player.note );
                        else
                            count = count + 1;
                        end
                    else
                        finalNote = GRM.FormatTimeStamp ( { player.joinDateHist[1][1] , player.joinDateHist[1][2] , player.joinDateHist[1][3] } , false , false , GRM.S().globalDateFormat ) .. " " .. player.officerNote;        -- Remove the header and try again
                        if GRM.GetNumLetters ( finalNote ) <= GRM_G.MaxPublicNoteSize then
                            if not getCount then
                                player.note = finalNote;
                                GuildRosterSetPublicNote ( index , player.note );
                            else
                                count = count + 1;
                            end
                        end
                    end
                    success = false;
                end
            end
        end

        -- Custom Note
        if GRM.S().joinDateDestination == 3 then
            success = select ( 2 , GRM.RemoveDateFromNote ( player.customNote[6] ) );
            if not success then
                -- yes, it was modified
                if not getCount then
                    player.customNote[2] = time();
                    player.customNote[3] = GRM_G.addonUser;
                    finalNote = ( GRM.Trim ( finalNote .. "\n" .. player.customNote[6] ) );
                    if GRM.GetNumLetters ( finalNote ) > GRM_G.MaxCustomNoteSize then
                        finalNote = string.sub ( finalNote , 1 , GRM_G.MaxCustomNoteSize );  -- Cheating a little here by just cutting off the end. Likely no one will ever notice with 150 chars to spare
                    end
                    player.customNote[6] = ( finalNote );
                else
                    count = count + 1;
                end
                success = false;
            end
        end
    end

    -- Refresh the dates on the frames!!!
    if GRM_UI.GRM_MemberDetailMetaData:IsVisible() and GRM_G.currentName == member[1] then
        if GRM_UI.GRM_MemberDetailMetaData.GRM_SetUnknownButton:IsVisible() or GRM_UI.GRM_MemberDetailMetaData.GRM_SyncJoinDateSideFrame:IsVisible() or GRM_UI.GRM_MemberDetailMetaData.GRM_CoreAltFrame.GRM_AddAltEditFrame:IsVisible() then
            GRM.ClearAllFrames( false );
        end
        GRM_G.pause = false;
        GRM.PopulateMemberDetails ( GRM_G.currentName );
        GRM_G.pause = true;
    end

    return count;
end

-- Method:          GRM.AddTimeStampToNote ( string , string )
-- What it Does:    Adds the new timestamp of when a player joins to the destination note
-- Purpose:         To track timestamps in the notes.
GRM.AddTimeStampToNote = function ( name , date )
    if GRM.S().addTimestampToNote then
        for h = 1 , GRM.GetNumGuildies() do
            local guildieName ,_,_,_,_,_, note , oNote = GetGuildRosterInfo( h );
            if not note then
                note = "";
            end
            if not oNote then
                oNote = "";
            end
            if name == guildieName then

                local player = GRM.GetPlayer ( name );

                local noteDate = "";
                local tempNote = "";
                if GRM.S().includeTag then
                    noteDate = GRM_G.customHeaderJoin .. " " .. date;
                else
                    noteDate = date;
                end
                
                if GRM.S().joinDateDestination == 1 then
                    if GRM.CanEditOfficerNote() then
                        tempNote = noteDate .. " " .. GRM.RemoveDateFromNote ( oNote );
                        if oNote == "" or GRM.GetNumLetters ( tempNote ) <= GRM_G.MaxOfficerNoteSize then
                            GuildRosterSetOfficerNote( h , tempNote );

                            if GRM_G.currentName == name then
                                GRM_UI.GRM_MemberDetailMetaData.GRM_noteFontString2:SetText ( tempNote );
                                GRM_UI.GRM_MemberDetailMetaData.GRM_PlayerOfficerNoteEditBox:SetText ( tempNote );
                            end

                            if player then
                                player.officerNote = tempNote;
                            end
                        end
                    end
                elseif GRM.S().joinDateDestination == 2 then
                    if GRM.CanEditPublicNote() then
                        tempNote = noteDate .. " " .. GRM.RemoveDateFromNote ( note );
                        if note == "" or GRM.GetNumLetters ( tempNote ) <= GRM_G.MaxPublicNoteSize then
                            GuildRosterSetPublicNote( h , tempNote );

                            if GRM_G.currentName == name then
                                GRM_UI.GRM_MemberDetailMetaData.GRM_noteFontString1:SetText ( tempNote );
                                GRM_UI.GRM_MemberDetailMetaData.GRM_PlayerNoteEditBox:SetText ( tempNote );
                            end

                            if player then
                                player.note = tempNote;
                            end
                        end
                    end
                elseif GRM.S().joinDateDestination == 3 then
                    GRM.SetJoinDateToCustomNote ( name , noteDate );
                end

                break;
            end
        end
    end
end

-- Method:          GRM.RemoveDatesFromNonDefaultNotes ( array )
-- What it Does:    Removes the join dates from the notes that are not set as default
-- Purpose:         Easy Cleanup of the notes.
-- This should be bottom option... to prevent from erroring and removing all notes prematurely.
GRM.RemoveDatesFromNonDefaultNotes = function( member )
    local player = GRM.GetPlayer ( member[1] );
    local tempNote = "";
    local name = "";
    local index;
    local success = false;

    if player then
        index = nil;
        name = "";
        tempNote = "";

        -- Find them in the guild indexes to modify offier/public notes
        for h = 1 , GRM.GetNumGuildies() do
            name = GetGuildRosterInfo( h );
            if name == member[1] then
                index = h;
                break;
            end
        end

        if GRM.CanViewOfficerNote() and GRM.S().joinDateDestination ~= 1 then
            tempNote , success = GRM.RemoveDateFromNote ( player.officerNote );
            if success then
                -- yes, it was modified
                if tempNote == nil then
                    tempNote = "";
                end
                player.officerNote = GRM.Trim ( tempNote );
                GuildRosterSetOfficerNote ( index , tempNote );
                success = false;
            end
        end
        if ( GRM.CanViewOfficerNote() or player.name == GRM_G.addonUser ) and GRM.S().joinDateDestination ~= 2 then
            tempNote , success = GRM.RemoveDateFromNote ( player.note );
            if success then
                -- yes, it was modified
                if tempNote == nil then
                    tempNote = "";
                end
                player.note = GRM.Trim ( tempNote );
                GuildRosterSetPublicNote ( index , player.note );
                success = false;
            end
        end
        if GRM.S().joinDateDestination ~= 3 then
            tempNote , success = GRM.RemoveDateFromNote ( player.customNote[6] );
            if success then
                -- yes, it was modified
                player.customNote[2] = time();
                player.customNote[3] = GRM_G.addonUser;
                if tempNote == nil then
                    tempNote = "";
                end
                player.customNote[6] = GRM.Trim ( tempNote );
                success = false;
            end
        end
    end

    -- Refresh the dates on the frames!!!
    if GRM_UI.GRM_MemberDetailMetaData:IsVisible() and GRM_G.currentName == member[1] then
        if GRM_UI.GRM_MemberDetailMetaData.GRM_SetUnknownButton:IsVisible() or GRM_UI.GRM_MemberDetailMetaData.GRM_SyncJoinDateSideFrame:IsVisible() or GRM_UI.GRM_MemberDetailMetaData.GRM_CoreAltFrame.GRM_AddAltEditFrame:IsVisible() then
            GRM.ClearAllFrames( false );
        end
        GRM_G.pause = false;
        GRM.PopulateMemberDetails ( GRM_G.currentName );
        GRM_G.pause = true;
    end
end

-- Method:          GRM.FixMismatchedGRMdatesUsingNote ( bool )
-- What it Does:    Scans through all of the given names of the guild and their note status, determines which ones need to be fixed
-- Purpose:         UX tool for managing join date conformity easier.
GRM.FixMismatchedGRMdatesUsingNote = function ( selectedOnly )
    for i = 1 , #GRM_G.AuditToolGuildies do
        if not selectedOnly or ( selectedOnly and GRM_G.AuditToolGuildies[i][6] ) then      -- if All or notAll, but IS selected.
            if GRM_G.AuditToolGuildies[i][4] == 1 or ( GRM_G.AuditToolGuildies[i][4] > 3 and GRM_G.AuditToolGuildies[i][4] < 7 ) then       -- 1,4,5,6 are the mismatched values
                GRM.ConvertGRMDateFromNote ( GRM_G.AuditToolGuildies[i] );
            end
        end
    end

    -- Refresh the frames AFTER it finishes with all...
    if GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame:IsVisible() then
        GRM.RefreshAuditFrames ( true , true );
    end
    GRM.AuditRefresh( true );
end


-- Method:          GRM.FixMismatchedNotesUsingGRM ( bool )
-- What it Does:    Scans through all of the given names of the guild and their note status, determines which ones need to be fixed using the GRM save to overwrite the ntoes
-- Purpose:         UX tool for managing join date conformity easier.
GRM.FixMismatchedNotesUsingGRM = function ( selectedOnly )
    for i = 1 , #GRM_G.AuditToolGuildies do
        if not selectedOnly or ( selectedOnly and GRM_G.AuditToolGuildies[i][6] ) then      -- if All or notAll, but IS selected.
            if GRM_G.AuditToolGuildies[i][4] == 1 or ( GRM_G.AuditToolGuildies[i][4] > 3 and GRM_G.AuditToolGuildies[i][4] < 7 ) then       -- 1,4,5,6 are the mismatched values
                GRM.ConvertNoteFromGRM ( GRM_G.AuditToolGuildies[i] );
            end
        end
    end

    GRM.AuditRefresh( true );
end

-- Method:          GRM.ImportDatesFromNoteToGRM ( bool )
-- What it Does:    Scans through all the notes and imports the date to GRM as needed.
-- Purpose:         UX tool for ease of importing dates from the player notes.
GRM.ImportDatesFromNoteToGRM = function ( selectedOnly )
    for i = 1 , #GRM_G.AuditToolGuildies do
        if not selectedOnly or ( selectedOnly and GRM_G.AuditToolGuildies[i][6] ) then      -- if All or notAll, but IS selected.
            if GRM_G.AuditToolGuildies[i][4] > 8 and GRM_G.AuditToolGuildies[i][4] < 13 then       -- 9-13
                GRM.ConvertGRMDateFromNote ( GRM_G.AuditToolGuildies[i] );
            end
        end
    end

    GRM.AuditRefresh( true );
    if GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame:IsVisible() then
        GRM.RefreshAuditFrames ( true , true );
    end
end

-- Method:          GRM.GetNumAuditToolSelected()
-- What it Does:    Returns the int count of the number of selected players
-- Purpose:         Tooltip messaging - quality of life clarification to player on mouseover
GRM.GetNumAuditToolSelected = function()
    local count = 0;
    if GRM_UI.GRM_AuditJDTool.GRM_AuditJDToolButton2Text:GetText() ~= GRM.L ( "Import all missing join dates from the note date" ) then
        for i = 1 , #GRM_G.AuditToolGuildies do
            if GRM_G.AuditToolGuildies[i][6] then
                count = count + 1;
            end
        end
    end

    return count;
end

-- Method:          GRM.AddJoinDatesToDefaultNotes ( bool )
-- What it Does:    Scans through all the notes and imports the date to GRM as needed.
-- Purpose:         UX tool for ease of importing dates from the player notes.
GRM.AddJoinDatesToDefaultNotes = function ( selectedOnly )
    for i = 1 , #GRM_G.AuditToolGuildies do
        if not selectedOnly or ( selectedOnly and GRM_G.AuditToolGuildies[i][6] ) then      -- if All or notAll, but IS selected.
            if GRM_UI.GRM_AuditJDTool.GRM_AuditJDToolButton1Text:GetText() == GRM.L ( "Add all missing saved dates to the {name}" , GRM.GetNoteName() ) or GRM_G.AuditToolGuildies[i][6] then      -- if All or notAll, but IS selected.
                if ( GRM_G.AuditToolGuildies[i][4] > 1 and GRM_G.AuditToolGuildies[i][4] < 5 ) or GRM_G.AuditToolGuildies[i][4] == 6 or GRM_G.AuditToolGuildies[i][4] == 7 then       -- 2,3,4,6,7  -- 3 = not just not found
                    -- parse the default note positions now...
                    GRM.AddDateTagToDefaultNote ( GRM_G.AuditToolGuildies[i] , false );
                end
            end
        end
    end

    GRM.AuditRefresh( true );
end

-- Method:          GRM.CleanUpNonDefaultNotes ( bool )
-- What it Does:    Scans through all the notes to remove join dates from the incorrect notes.
-- Purpose:         UX tool for ease of cleaning up notes
GRM.CleanUpNonDefaultNotes = function ( selectedOnly )
    for i = 1 , #GRM_G.AuditToolGuildies do
        if not selectedOnly or ( selectedOnly and GRM_G.AuditToolGuildies[i][6] ) then
            if GRM_UI.GRM_AuditJDTool.GRM_AuditJDToolButton7Text:GetText() == GRM.L ( "Clear all join dates from incorrect note locations" ) or GRM_G.AuditToolGuildies[i][6] then      -- if All or notAll, but IS selected.
                if GRM_G.AuditToolGuildies[i][3] == 4 then       -- 4 = multiple locations (1=officer, 2 = public, 3=custom, thus if in more than 1 it equals 4)
                    GRM.RemoveDatesFromNonDefaultNotes ( GRM_G.AuditToolGuildies[i] );
                end
            end
        end
    end
    GRM.AuditRefresh( true );
end

-- Method:          GRM.MismatchConfirmConfig()
-- What it Does:    Builds function template to be inserted into the confirmation window and determines if we are fixing all mismatched or only those highlighted (from note to GRM save)
-- Purpose:         Clean UX experience that prevents players from accidentally making an error
GRM.MismatchConfirmConfig = function()
    if GRM_UI.GRM_AuditJDTool.GRM_AuditJDToolButton4Text:GetText() == GRM.L ( "Fix all mismatched GRM dates with the note date" ) then
        GRM.FixMismatchedGRMdatesUsingNote ( false );
    else
        GRM.FixMismatchedGRMdatesUsingNote ( true );
    end
end

-- Method:          GRM.MismatchConfirmConfig2()
-- What it Does:    Builds function template to be inserted into the confirmation window and determines if we are fixing all mismatched or only those highlighted (from GRM save to note)
-- Purpose:         Clean UX experience that prevents players from accidentally making an error
GRM.MismatchConfirmConfig2 = function()
    if GRM_UI.GRM_AuditJDTool.GRM_AuditJDToolButton3Text:GetText() == GRM.L ( "Fix all mismatched note dates with GRM saved date" ) then
        GRM.FixMismatchedNotesUsingGRM ( false );
    else
        GRM.FixMismatchedNotesUsingGRM ( true );
    end
end

-- Method:          GRM.MismatchConfirmConfig3()
-- What it Does:    Builds function template to be inserted into the confirmation window and determines if we are fixing all mismatched or only those highlighted (from GRM save to note)
-- Purpose:         Clean UX experience that prevents players from accidentally making an error
GRM.MismatchConfirmConfig3 = function()
    if GRM_UI.GRM_AuditJDTool.GRM_AuditJDToolButton2Text:GetText() == GRM.L ( "Import all missing join dates from the note date" ) then
        GRM.ImportDatesFromNoteToGRM ( false );
    else
        GRM.ImportDatesFromNoteToGRM ( true );
    end
end

-- Method:          GRM.MismatchConfirmConfig4()
-- What it Does:    Builds function template to be inserted into the confirmation window and determines if we are fixing all or only those highlighted (from GRM save to note)
-- Purpose:         Clean UX experience that prevents players from accidentally making an error
GRM.MismatchConfirmConfig4 = function()
    if GRM_UI.GRM_AuditJDTool.GRM_AuditJDToolButton1Text:GetText() == GRM.L ( "Add all missing saved dates to the {name}" , GRM.GetNoteName() ) then
        GRM.AddJoinDatesToDefaultNotes ( false );
    else
        GRM.AddJoinDatesToDefaultNotes ( true );
    end
end

-- Method:          GRM.MismatchConfirmConfig5()
-- What it Does:    Builds function template to be inserted into the confirmation window and determines if we are fixing all or only those highlighted (cleanup of non-default notes)
-- Purpose:         Clean UX experience that prevents players from accidentally making an error
GRM.MismatchConfirmConfig5 = function()
    if GRM_UI.GRM_AuditJDTool.GRM_AuditJDToolButton7Text:GetText() == GRM.L ( "Clear all join dates from incorrect note locations" , GRM.GetNoteName() ) then
        GRM.CleanUpNonDefaultNotes ( false );
    else
        GRM.CleanUpNonDefaultNotes ( true );
    end
end

-- Method:          GRM.GetNumMismatchedButton4()
-- What it Does:    Returns the count of the number of mismatched, either all, or of that selected.
-- Purpose:         UX
GRM.GetNumMismatchedButton4 = function()
    local count = 0;

    for i = 1 , #GRM_G.AuditToolGuildies do
        if GRM_UI.GRM_AuditJDTool.GRM_AuditJDToolButton4Text:GetText() == GRM.L ( "Fix all mismatched GRM dates with the note date" ) or GRM_G.AuditToolGuildies[i][6] then      -- if All or notAll, but IS selected.
            if GRM_G.AuditToolGuildies[i][4] == 1 or ( GRM_G.AuditToolGuildies[i][4] > 3 and GRM_G.AuditToolGuildies[i][4] < 7 ) then       -- 1,4,5,6 are the mismatched values
                count = count + 1;
            end
        end
    end

    return count;
end

-- Method:          GRM.GetNumMismatchedButton3()
-- What it Does:    Returns the count of the number of mismatched, either all, or of that selected.
-- Purpose:         UX
GRM.GetNumMismatchedButton3 = function()
    local count = 0;
    
    for i = 1 , #GRM_G.AuditToolGuildies do
        if GRM_UI.GRM_AuditJDTool.GRM_AuditJDToolButton3Text:GetText() == GRM.L ( "Fix all mismatched note dates with GRM saved date" ) or GRM_G.AuditToolGuildies[i][6] then      -- if All or notAll, but IS selected.
            if GRM_G.AuditToolGuildies[i][4] == 1 or ( GRM_G.AuditToolGuildies[i][4] > 3 and GRM_G.AuditToolGuildies[i][4] < 7 ) then       -- 1,4,5,6 are the mismatched values
                count = count + 1;
            end
        end
    end

    return count;
end

-- Method:          GRM.GetNumMismatchedButton2()
-- What it Does:    Returns the count of the number of dates that need to be imported, either all, or of that selected.
-- Purpose:         UX
GRM.GetNumMismatchedButton2 = function()
    local count = 0;
    
    for i = 1 , #GRM_G.AuditToolGuildies do
        if GRM_UI.GRM_AuditJDTool.GRM_AuditJDToolButton2Text:GetText() == GRM.L ( "Import all missing join dates from the note date" ) or GRM_G.AuditToolGuildies[i][6] then      -- if All or notAll, but IS selected.
            if GRM_G.AuditToolGuildies[i][4] > 8 and GRM_G.AuditToolGuildies[i][4] < 13 then       -- 1,4,5,6 are the mismatched values
                count = count + 1;
            end
        end
    end

    return count;
end

-- Method:          GRM.GetNumMismatchedButton1()
-- What it Does:    Returns the count of the number of notes that need to be added to the officer note
-- Purpose:         UX
GRM.GetNumMismatchedButton1 = function()
    local count = 0;
    for i = 1 , #GRM_G.AuditToolGuildies do
        if GRM_UI.GRM_AuditJDTool.GRM_AuditJDToolButton1Text:GetText() == GRM.L ( "Add all missing saved dates to the {name}" , GRM.GetNoteName() ) or GRM_G.AuditToolGuildies[i][6] then      -- if All or notAll, but IS selected.
            if ( GRM_G.AuditToolGuildies[i][4] > 1 and GRM_G.AuditToolGuildies[i][4] < 5 ) or GRM_G.AuditToolGuildies[i][4] == 6 or GRM_G.AuditToolGuildies[i][4] == 7 then       -- 2,3,4,6,7  -- 3 = not just not found
                -- parse the default note positions now...
                count = count + GRM.AddDateTagToDefaultNote ( GRM_G.AuditToolGuildies[i] , true );
            end
        end
    end
    return count;
end

-- Method:          GRM.GetNumMismatchedButton7()
-- What it Does:    Returns the count of the number of players that have join dates in incorrect notes.
-- Purpose:         UX
GRM.GetNumMismatchedButton7 = function()
    local count = 0;
    for i = 1 , #GRM_G.AuditToolGuildies do
        if GRM_UI.GRM_AuditJDTool.GRM_AuditJDToolButton7Text:GetText() == GRM.L ( "Clear all join dates from incorrect note locations" ) or GRM_G.AuditToolGuildies[i][6] then      -- if All or notAll, but IS selected.
            if GRM_G.AuditToolGuildies[i][3] == 4 or GRM_G.AuditToolGuildies[i][3] == 2 then       -- 4 = multiple locations (1=officer, 2 = public, 3=custom, thus if in more than 1 it equals 4)
                -- parse the default note positions now...
                count = count + 1;
            end
        end
    end
    return count;
end



-- GRM.FindLikelyDateStart = function ( note )

-- end
--------------------------------------------
-------- HYBRID SCROLLFRAME TEMPLATES ------
--------------------------------------------

-- Method:          GRM.SetHybridScrollFrameSliderParameters ( frame , frame , frame , int , int , int , int , arrayOfButtons , function , function , int , function )
-- What it Does:    Acts as a template for all future hybrid scrollframe configuration of the slider logic on mousewheel scrolling and so on
-- Purpose:         Clean, repeatable code that can be used in conjunction with all other large scrollframes
GRM.SetHybridScrollFrameSliderParameters = function( childFrame , HscrollFrame , HscrollFrameSlider , buttonW , buttonH , scrollH , totalEntries , buttons , logicFunction1 , logicFunction2 , totalPotentialButtons , optionalLogic )
    
    local maxButtons = #buttons;
    if totalPotentialButtons < maxButtons then
        maxButtons = totalPotentialButtons;
    end

    childFrame:SetSize ( buttonW , HscrollFrame:GetHeight() );

    local scrollMax = ( scrollH - HscrollFrame:GetHeight() );
    if scrollMax < 0 or totalEntries <= totalPotentialButtons then
        scrollMax = 0;
    else
        scrollMax = scrollMax + buttonH;
    end

    HscrollFrameSlider:SetMinMaxValues ( 0 , scrollMax );

    if scrollMax > 0 then
        HscrollFrame:EnableMouseWheel( true );
    else
        HscrollFrame:EnableMouseWheel ( false );
    end

    if scrollMax > 0 then
        HscrollFrame:SetScript( "OnMouseWheel" , function( _ , delta )

            if optionalLogic ~= nil then
                if not optionalLogic() then
                    return;
                end
            end
            
            if totalEntries > 0 then
                GRM.HybridControl( HscrollFrameSlider );
                local current = HscrollFrameSlider:GetValue();

                -- Scroll Down
                if delta < 0 and current < scrollMax then
                    if IsControlKeyDown() then
                        HscrollFrameSlider.HybridControlBool = false;
                        if IsShiftKeyDown() then
                            HscrollFrameSlider:SetValue ( current + ( buttonH * 12 ) );
                        else
                            HscrollFrameSlider:SetValue ( current + ( buttonH * 3 ) );
                        end
                    elseif IsShiftKeyDown() then
                        HscrollFrameSlider.HybridControlBool = false;
                        HscrollFrameSlider:SetValue ( select ( 2 , HscrollFrameSlider:GetMinMaxValues() ) );
                    else
                        HscrollFrameSlider:SetValue ( current + buttonH );
                    end

                -- Scroll Up
                elseif delta > 0 and current > 1 then
                    if IsControlKeyDown() then
                        HscrollFrameSlider.HybridControlBool = false;
                        if IsShiftKeyDown() then
                            HscrollFrameSlider:SetValue ( current - ( buttonH * 12 ) );
                        else
                            HscrollFrameSlider:SetValue ( current - ( buttonH * 3 ) );
                        end
                    elseif IsShiftKeyDown() then
                        HscrollFrameSlider.HybridControlBool = false;
                        HscrollFrameSlider:SetValue ( 0 );
                    else
                        HscrollFrameSlider:SetValue ( current - buttonH );
                    end
                end
                
                if HscrollFrameSlider.HybridControlBool then
                    -- Scroll Down
                    if delta < 0 and childFrame.Offset < totalEntries then
                        childFrame.Offset = childFrame.Offset + 1;
                        logicFunction1();

                    -- Scroll Up
                    elseif delta > 0 and childFrame.Offset > maxButtons then
                        childFrame.Offset = childFrame.Offset - 1;
                        logicFunction2();
                    end
                end
            end
        end);
    end
end

-- Method:          GRM.HybridScrollOnValueChangedConfig ( slider , float , scrollchildframe , scrollframe , int , int , function , array )
-- What it Does:    In conjunction with the GRM.SetHybridScrollFrameSliderParameters() tool, manage the hybridscrollframe functionality of the given frames
-- Purpose:         Reusable framework for hybrid scrollframes in this addon's style.
GRM.HybridScrollOnValueChangedConfig = function ( HscrollFrameSlider , value , scrollChildFrame, scrollFrame , numButtons , stepSize , refreshFunction , dataArray )
    local maxSize = 0
    local arraySize = #dataArray;

    if value > HscrollFrameSlider.currentV then
        if HscrollFrameSlider.HybridControlBool and scrollFrame:GetVerticalScroll() < maxSize then
            scrollFrame:SetVerticalScroll ( value );
        else
            if not HscrollFrameSlider.HybridControlBool then
                if value >= maxSize and scrollFrame:GetVerticalScroll() < maxSize then
                    scrollFrame:SetVerticalScroll ( maxSize );
                end
                scrollChildFrame.Offset = math.floor ( ( value / stepSize ) ) + numButtons;
                -- Prevent overlap errors
                if scrollChildFrame.Offset > arraySize then
                    scrollChildFrame.Offset = arraySize;
                end
                refreshFunction ( true , false );
            end
        end
    else
        if HscrollFrameSlider.HybridControlBool and scrollFrame:GetVerticalScroll() > 0 and value <= maxSize then
            scrollFrame:SetVerticalScroll ( value );
        else
            if not HscrollFrameSlider.HybridControlBool then

                if value == 0 and scrollFrame:GetVerticalScroll() <= maxSize then
                    scrollFrame:SetVerticalScroll ( 0 );
                end
                
                scrollChildFrame.Offset = math.floor ( ( value / stepSize ) ) + numButtons;
                -- Prevent overlap errors
                if scrollChildFrame.Offset > arraySize then
                    scrollChildFrame.Offset = arraySize;
                end
                refreshFunction ( true , false );
            end
        end
    end
    HscrollFrameSlider.currentV = value;
end

-- Method:          GRM.HybridControl()
-- What it Does:    Sets a gate check that lasts for 0.1 seconds
-- Purpose:         So that when the slider value changes, it ignores double work when an "OnMouseWheel" handler is also activated.
GRM.HybridControl = function( slider )
    slider.HybridControlBool = true;
    C_Timer.After ( 0.1 , function()
        slider.HybridControlBool = false;
    end);
end


-------------------------------------
----- END HYBRID SCROLLFRAMES -------
-------------------------------------

-------------------------------------
-- VARIOUS TOOLTIP CLICK PARAMETERS -
-------------------------------------

-- Method:          GRM.SearchPlayerInLog ( string )
-- What it Does:    Opens the Log and searches the given string
-- Purpose:         For repeat use actions from other frames
GRM.SearchPlayerInLog = function ( playerName ) 
    GRM.RestoreTooltip()
    GRM_UI.GRM_RosterChangeLogFrame:Show();
    GRM_UI.GRM_RosterChangeLogFrame.GRM_LogTab:Click();
    GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame.GRM_LogEditBox:SetText( GRM.SlimName ( playerName ) );
end

-- Method:          GRM.DisplayRosterMember ( string , index )
-- What it Does:    It finds the player's roster index, and then it set it to that
-- Purpose:         To get around the issues with the new kick system
GRM.DisplayRosterMember = function ( playerName , index )

    local getRosterIndex = function()
        for i = 1 , GRM.GetNumGuildies() do
            if GetGuildRosterInfo ( i ) == playerName then
                return i;
            end
        end
        return nil;
    end
    local i = index or getRosterIndex();
    SetGuildRosterSelection ( i );
    if not GRM_UI.MemberDetailFrameClassic:IsVisible() then
        GRM_UI.MemberDetailFrameClassic:Show();
    end
    if GRM_G.BuildVersion < 40000 then
        GuildStatus_Update();
    else
        GuildRoster_Update();
    end
end

-- Method:          GRM.OpenPlayerWindow ( string )
-- What it Does:    Opens the community frame and brings up the player window for editing
-- Purpose:         Easy access to find the player from various frames
GRM.OpenPlayerWindow = function ( playerName )
    if GRM_G.BuildVersion < 40000 then

        if GuildFrame and not GuildFrame:IsVisible() then
            
            if not GRM_G.ClassicTaintProtection then
                if FriendsFrame and not FriendsFrame:IsVisible() then
                    FriendsFrame:Show();
                end

                C_Timer.After ( 0.1 , function()
                    if not GuildFrame:IsVisible() then

                        if not GRM_G.ClassicTaintWarning then
                            GRM_G.ClassicTaintWarning = true;
                            GRM.Report ( GRM.L ( "GRM:" ) .. " " .. GRM.L ( "To avoid addon taint/blocking errors in Classic, the player must manually open the Guild Roster tab the first time." ) );
                        end

                    end
                end);
            else
                if FriendsFrame and not FriendsFrame:IsVisible() then
                    FriendsFrame:Show();
                end
            end

        end

        local timer = 0.2;
        if not GRM_G.BlizzFramePinsInitialized then
            timer = 0.5;
        end
        C_Timer.After ( timer , function()

            if FriendsFrame and FriendsFrame:IsVisible() then
                GRM_G.pause = false;
                GRM.ClearAllFrames( true );
                GRM_G.currentName = playerName;
                GRM_G.RosterSelection = GRM.GetRosterSelectionID ( playerName );
                GRM.PopulateMemberDetails ( GRM_G.currentName );
                GRM_UI.GRM_MemberDetailMetaData:Show();
                GRM_G.pause = true;
            end
    
        end);

    elseif GRM_G.BuildVersion >= 40000 and GRM_G.BuildVersion < 80000 then

        if GuildFrame and not GuildFrame:IsVisible() then
            -- Force community Frame open
            if GuildFrame_Toggle ~= nil then
                GuildFrame_Toggle();
                GuildFrame_TabClicked ( GuildFrameTab2 );
            end
        end

        if GRM_UI.MemberDetailFrame and GRM_UI.MemberDetailFrame:IsVisible() then
            GRM_UI.MemberDetailFrame:Hide();
        end

        local timer = 0.2;

        if not GRM_G.BlizzFramePinsInitialized then
            timer = 0.5;
        end

        -- need to set the proper index of selection

        C_Timer.After ( timer , function()
        
            GRM_G.pause = false;
            GRM.ClearAllFrames( true );
            GRM_G.currentName = playerName;
            GRM_G.RosterSelection = GRM.GetRosterSelectionID ( playerName );
            GRM.PopulateMemberDetails ( GRM_G.currentName );
            GRM_UI.GRM_MemberDetailMetaData:Show();        
            GRM.DisplayRosterMember ( playerName , GRM_G.RosterSelection );
            GRM.UpdateMemberDetailNameClassColor();
            GRM_G.pause = true;

        end);


    elseif GRM_G.BuildVersion >= 80000 then

        if CommunitiesFrame then
            
            if not CommunitiesFrame:IsVisible() then
                -- Force community Frame open
                CommunitiesFrame:Show()
            end

        end

        if GRM_UI.MemberDetailFrame and GRM_UI.MemberDetailFrame:IsVisible() then
            GRM_UI.MemberDetailFrame:Hide();
        end

        local timer = 0.2;

        if not GRM_G.BlizzFramePinsInitialized then
            timer = 0.5;
        end

        -- need to set the proper index of selection

        C_Timer.After ( timer , function()
            GRM_G.pause = false;
            
            GRM.ClearAllFrames( true );
            GRM_G.currentName = playerName;
            GRM.PopulateMemberDetails ( GRM_G.currentName );
            GRM_UI.GRM_MemberDetailMetaData:Show();
            GRM.UpdateMemberDetailNameClassColor();
            GRM_G.pause = true;

        end);
    end

    
end

-- Method:          GRM.GetRosterSelectionID ( string )
-- What it Does:    Updates the selected index of the manually opened player window
-- Purpose:         To ensure regular update intervals are accurately looking at the correct player.
GRM.GetRosterSelectionID = function ( name )
    local index = 1;            -- Defaults to 1 to prevent errors

    for i = 1 , GRM.GetNumGuildies() do
        if GetGuildRosterInfo ( i ) == name then
            index = i;
            break;
        end
    end

    return index
end

--------------------------------
---- END TOOLTIP CLICK PARAS ---
--------------------------------

------------------------------
----- CHAT MSG LISTENING -----
------------------------------

-- Need to work with the built-in sync system to ensure only 1 leader reports to chat...
C_ChatInfo.RegisterAddonMessagePrefix( "GRM_GCHAT" );
GRM.GRM_FrameChatTest = CreateFrame ( "Frame" , "GRM_FrameChatTest");
GRM.GRM_FrameChatTest:RegisterEvent ( "CHAT_MSG_ADDON" );
GRM.GRM_FrameChatTest.IsInLoop = false;

GRM.GRM_FrameChatTest:SetScript ( "OnEvent" , function ( _ , event , prefix , msg , _ , sender )
    -- Only acknowledge if you are sending it to yourself, as this is just a check to see if you have access
    if event == "CHAT_MSG_ADDON" and prefix == "GRM_GCHAT" and sender ~= GRM_G.addonUser then
        local prefix2 = string.sub ( msg , 1 , string.find ( msg , "?" ) - 1 );

        -- Force global controls update check
        if prefix2 == "GINFOUPDATE" and not GRM.GRM_FrameChatTest.IsInLoop then
            GRM.GRM_FrameChatTest.IsInLoop = true;
            local needsLoopCheck = false;

            if GRM_G.BuildVersion >= 80000 then
                needsLoopCheck = true;
                if GuildRoster then
                    GuildInfoFrame_UpdateText();
                end
                CommunitiesGuildInfoFrame_UpdateText ( CommunitiesFrameGuildDetailsFrameInfo );
            else
                if GRM_UI.MemberDetailFrame ~= nil and not GRM_UI.MemberDetailFrame:IsVisible() and ( GetCurrentKeyBoardFocus() == nil or ( GetCurrentKeyBoardFocus():GetObjectType() == nil ) or ( GetCurrentKeyBoardFocus():GetObjectType() ~= "EditBox" ) ) then
                    needsLoopCheck = true;
                    local isVisible = GuildInfoFrame:IsVisible();
                    ToggleGuildInfoFrame();
                    if not isVisible and GuildInfoFrame:IsVisible() then
                        GuildInfoFrame:Hide();
                    elseif isVisible then
                        ToggleGuildInfoFrame();
                    end
                end
            end
            if needsLoopCheck then
                GRM.GlobalSettingsLoopCheck( nil , true );
            else
                GRM.GRM_FrameChatTest.IsInLoop = false;
            end
        end
    end
end);

-- Method:          GRM.GlobalSettingsLoopCheck ( int )
-- What it Does:    Controls the recheck on the guildInfo as when the window is closed it doesn't refresh immediately.
-- Purpose:         Quality control to keep the settings check as fast as possible on global control changesw
GRM.GlobalSettingsLoopCheck = function( epochTime , first )
    local timer = epochTime or time();
    local reCheck = function()
        local canExit = false;
        if GRM_G.GuildInfo ~= GetGuildInfoText() and not first then
            canExit = true;
        end

        return canExit;
    end

    if ( time() - timer ) <= 10 then
        if reCheck() then
            GRM.UpdateGuildLeaderPermissions ( false , true );
            GRM.GRM_FrameChatTest.IsInLoop = false;
        else
            GRM.GuildRoster();
            C_Timer.After ( 1 , function()
                GRM.GlobalSettingsLoopCheck ( timer , false );
                return;
            end);
        end
    else
        GRM.GRM_FrameChatTest.IsInLoop = false;
    end
end

-- Method:          GRM.TriggerPlayerNote ( string , string )
-- What it Does:    Parses every comment in the guild frame and looks for the !note tag - and adds anything after it, up to 31 characters, to player note
-- Purpose:         Mainly for use in Classic
GRM.TriggerPlayerNote = function ( player , msg )
    local caseFreeTxt = string.lower ( msg );
    local startIndex = string.find ( GRM.Trim ( caseFreeTxt ) , GRM.L ( "!note" ) );
    local isEnglish = false;

    if startIndex == nil then
        string.find ( GRM.Trim ( caseFreeTxt ) , "!note" );     -- Always working in case of other language
        isEnglish = true;
    end
    
    -- No need to continue on if it is not found at start... No need to do extra attempt processing
    if startIndex ~= nil then
        msg , startIndex = GRM.SpecialAddonAltTagCleanup ( GRM.RemoveStringColoring ( msg ) , startIndex ); -- Cleaning it up!!!
        if startIndex == 1 then

            -- Success!
            -- Let's check what we have... No point in carrying on if there is no note to set...
            local note = "";
            
            if not isEnglish then
                note = GRM.Trim ( string.sub ( msg , select ( 2 , string.find ( string.lower ( msg ) , GRM.L ( "!note" ) ) ) + 1 ) );
            else
                note = GRM.Trim ( string.sub ( msg , select ( 2 , string.find ( string.lower ( msg ) , "!note" ) ) + 1 ) );
            end

            if #note > 0 then
                -- Note is good, let's trigger the boolean...
                if ( GRM_G.BuildVersion >= 80000 and GRM.CanEditPublicNote() and ( GRM.CanEditOfficerNote() or GRM_G.addonUser == player ) ) or ( GRM_G.BuildVersion < 80000 and GRM.CanEditPublicNote() ) then             -- Don't need to write your own public note.
                    GRM.UpdateNoteFromChat ( player , note );
                else
 
                    if GRM.S()["toChat"].note then
                        -- Do an officer check of addon users online...
                        GRM.RegisterGuildAddonUsersRefresh();
                        C_Timer.After ( 2.1 , function()
                            local addonUsers = GRM_G.currentAddonUsers;
                            local officerFoundOnlineWithAddon = false;
                            for i = 1 , #addonUsers do
                                if GRM.IsGuildieAnOfficer ( addonUsers[i][1] ) then
                                    officerFoundOnlineWithAddon = true;
                                    break;
                                end
                            end

                            if not officerFoundOnlineWithAddon and not GRM_G.ReportedNoOfficerOnly then
                                GRM_G.ReportedNoOfficerOnly = true;
                                if player ~= GRM_G.addonUser then
                                    GRM.Report ( GRM.L ( "GRM:" ) .. " " .. GRM.L ( "No officer online to set {name}'s note" , GRM.SlimName ( player ) ) );
                                else
                                    GRM.Report ( GRM.L ( "GRM:" ) .. " " .. GRM.L ( "No officer is currently online to update your note" ) );
                                end
                            elseif officerFoundOnlineWithAddon then
                                C_Timer.After ( 1 , function()
                                    GRM_G.ReportedNoOfficerOnly = false;
                                    GRM.Report ( GRM.L ( "{name}'s note has been updated!" , GRM.SlimName ( player ) ) );
                                end);
                            end
                        end);
                    end
                end
            end
        end
    end
end

-- Method:          GRM.UpdateNoteFromChat ( string , string )
-- What it Does:    Updates the player note if you are an officer to do it, and the player typed !note in chat
-- Purpose:         Help with adding public notes for guildies who it is restricted due to officer changes.
GRM.UpdateNoteFromChat = function ( player , note )
    local maxNoteSize = 31;

    if GRM.GetNumLetters ( note ) > maxNoteSize then
        C_Timer.After ( 0.1 , function()
            GRM.Report ( GRM.L ( "The note is too long. Only the first {num} characters will be set." , nil , nil , maxNoteSize ) );
        end);
    end
    -- Let's find the player
    for i = 1 , GRM.GetNumGuildies() do
        if GetGuildRosterInfo ( i ) == player then
            GuildRosterSetPublicNote ( i , note );
            if GRM.S()["toChat"].note then
                C_Timer.After ( 1 , function()
                    GRM_G.ReportedNoOfficerOnly = false;
                    GRM.Report ( GRM.L ( "{name}'s note has been updated!" , GRM.SlimName ( player ) ) );
                end);
            end
            break;
        end
    end
end

-- Method:          GRM.IsPlayerAnAddonUser ( string )
-- What it Does:    It returns true if the player is currently online and is an addon user
-- Purpose:         For reporting updates...
GRM.IsPlayerAnAddonUser = function ( name )
    local result = false;
    local users = GRM_G.currentAddonUsers;
    for i = 1 , #users do
        if users[i][1] == name then
            result = true;
            break;
        end
    end
    return result;
end

-- Method:          GRM.SpecialAddonAltTagCleanup ( string , int )
-- What it Does:    If the player is using one of those alt name/main guild message addons this parses it out
-- Purpose:         So it is compatible with guild chat manipulated addons...
GRM.SpecialAddonAltTagCleanup = function ( note , startIndex )
    local tags = { ":" , "]" , ")" , "-" , ">" };
    local isSpecial = false;
    if startIndex > 1 then
        for i = startIndex - 1 , 1 , -1 do
            local tag = string.sub ( note , i , i )
            for j = 1 , #tags do
                if tag == tags[j] then
                    note = string.sub ( note , startIndex );
                    startIndex = 1;     -- Need to update it!
                    isSpecial = true;
                    break;
                end
            end
            if isSpecial or ( i == startIndex - 2 ) then
                break;
            end
        end
    end
    return note , startIndex;
end

----------------------
--- FRAME VALUES -----
--- AND PARAMETERS ---
--- AND REUSABLES ----
----------------------

-- Method:          GRM.SetConfirmationWindow ( function , string , function , table , string )
-- What it Does:    Creates the settings for a reusable popup confirmation window that can be used for any reason
-- Purpose:         Useful to prevent errors and prevents code clutter by being flexibly reusable.
GRM.SetConfirmationWindow = function( addedFunction , text , optionalButtonFunction , sizeMod , optionalButtonText )
    -- Configure the yes button

    GRM_UI.GRM_GeneralPopupWindow.GRM_GeneralPopupWindowText:SetText ( text );
    
    GRM_UI.GRM_GeneralPopupWindow.GRM_GeneralPopupWindowYesButton:SetScript ( "OnClick" , function( _ , button ) 
        if button == "LeftButton" then
            addedFunction();
            GRM_UI.GRM_GeneralPopupWindow:Hide();
        end
    end);

    if optionalButtonFunction ~= nil then
        GRM_UI.GRM_GeneralPopupWindow.GRM_GeneralPopupWindowIgnoreButton:SetScript ( "OnClick" , function ( _ , button )
            optionalButtonFunction();
            GRM_UI.GRM_GeneralPopupWindow:Hide();
        end);
        if optionalButtonText ~= nil then
            GRM_UI.GRM_GeneralPopupWindow.GRM_GeneralPopupWindowIgnoreButtonText:SetText ( optionalButtonText );
        end
        GRM_UI.GRM_GeneralPopupWindow.GRM_GeneralPopupWindowIgnoreButton:Show();
    else
        GRM_UI.GRM_GeneralPopupWindow.GRM_GeneralPopupWindowIgnoreButton:SetScript ( "OnClick" , nil );
        GRM_UI.GRM_GeneralPopupWindow.GRM_GeneralPopupWindowIgnoreButton:Hide();
    end

    if sizeMod then
        GRM_UI.GRM_GeneralPopupWindow:SetSize ( sizeMod[1] , sizeMod[2] );
    end

    
    if not GRM_UI.GRM_GeneralPopupWindow:IsVisible() then
        GRM_UI.GRM_GeneralPopupWindow:Show();
    end
end

-- Method:          GRM.GetTransitionFrameToFade()
-- What it Does:    Gets the frame that is currently visible. The tab the player is currently looking at.
-- Purpose:         To save on resources, rather than reuse this code over and over. I could potentially just make a global holder, but I want it to be flixible.
GRM.GetTransitionFrameToFade = function()
    local fadeFrame;
    if GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame:GetAlpha() == 1 then
        fadeFrame = GRM_UI.GRM_RosterChangeLogFrame.GRM_LogFrame;
    elseif GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame:GetAlpha() == 1 then
        fadeFrame = GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame;
    elseif GRM_UI.GRM_RosterChangeLogFrame.GRM_AddonUsersFrame:GetAlpha() == 1 then
        fadeFrame = GRM_UI.GRM_RosterChangeLogFrame.GRM_AddonUsersFrame;
    elseif GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame:GetAlpha() == 1 then
        fadeFrame = GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame;
    elseif GRM_UI.GRM_RosterChangeLogFrame.GRM_EventsFrame:GetAlpha() == 1 then
        fadeFrame = GRM_UI.GRM_RosterChangeLogFrame.GRM_EventsFrame;
    elseif GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame:GetAlpha() == 1 then
        fadeFrame = GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame;
    end
    return fadeFrame;
end

-- Method:          GRM.FrameTransition()
-- What it Does:    Fades frame to frame on tab check...
-- Purpose:         Really, just aesthetics for User Experience. This also is built to be flexible, to account for any given tab.
GRM.FrameTransition = function( fadeInName , fadeOutName , isOptionsTab , isOptionsSubTab )
    if GRM.S().useFade then 
        if fadeInName ~= nil then
            fadeInName:Show();

            if fadeInName:GetAlpha() + 0.04 >= 1 then
                fadeInName:SetAlpha(1);
            else
                fadeInName:SetAlpha( fadeInName:GetAlpha() + 0.04 );
            end
        end
        if fadeOutName ~= nil then

            if fadeOutName:GetAlpha() - 0.04 <= 0 then
                fadeOutName:SetAlpha(0);
            else
                fadeOutName:SetAlpha( fadeOutName:GetAlpha() - 0.04 );
            end
        end

        if ( fadeInName ~= nil and fadeInName:GetAlpha() < 1 ) or ( fadeInName == nil and fadeOutName:GetAlpha() > 0 )  then
            C_Timer.After ( 0.01 , function()
                GRM.FrameTransition ( fadeInName , fadeOutName , isOptionsTab , isOptionsSubTab );
            end);
        else
            if fadeOutName ~= nil then
                fadeOutName:SetAlpha ( 0 );
                fadeOutName:Hide();
            end
            if fadeInName ~= nil then
                fadeInName:SetAlpha ( 1 );
            end
            if isOptionsTab then
                GRM.DisableTabButtons ( false );
            elseif isOptionsSubTab then
                GRM.DisableSubTabButtons ( false );
            end
        end
    else
        if fadeInName ~= nil then
            fadeInName:SetAlpha ( 1 );
            fadeInName:Show();
        end
        if fadeOutName ~= nil then
            fadeOutName:SetAlpha ( 0 );
            fadeOutName:Hide();
        end
        if isOptionsTab then
            GRM.DisableTabButtons ( false );
        elseif isOptionsSubTab then
            GRM.DisableSubTabButtons ( false );
        end
    end
end

-- Method:          GRM.OptionTabFrameControl ( buttonWidget )
-- What it Does:    It Locks the highlight of the current tab and it unlocks the others, as well as showing the correct frame, whilst hiding the others
-- Purpose:         Options are plentiful. Need sub-tabs to keep it clean. This helps control UI display logic on the tabs.
GRM.OptionTabFrameControl = function ( tabNotToUnlock )
    GRM.DisableSubTabButtons ( true );
    local tabs = { GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralTab , GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_ScanTab , GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_SyncTab , GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_HelpTab , GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_UITab , GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_OfficerTab , GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_UXTab , GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_ModulesTab , GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_HardcoreTab };
    local frames = { GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralOptionsFrame , GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_ScanningOptionsFrame , GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_SyncOptionsFrame , GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_HelpOptionsFrame , GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_UIOptionsFrame , GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_OfficerOptionsFrame , GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_UXOptionsFrame , GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_ModulesFrame , GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_HardcoreFrame };
    local fadeFrame;
    local fadeInFrame; 
            
    for i = 1 , #tabs do
        if tabs[i] ~= tabNotToUnlock then
            -- Lock highlight
            tabs[i]:UnlockHighlight();
        else
            -- Corresponding tab frame should now be shown whilst hiding the rest. Index will match
            fadeInFrame = frames[i];                
        end
    end

    for j = 1 , #frames do
        if frames[j]:GetAlpha() == 1 then
            fadeFrame = frames[j];
            break;
        end
    end
    -- Ok, let's do the work!
    GRM.FrameTransition ( fadeInFrame , fadeFrame , false , true );
end

-- Method:          GRM.DisableTabButtons()
-- What it Does:    Temporarily disables the buttons. Don't want to allow player to trigger click spam the button on transition.
-- Purpose:         Clicking button too fast will be error prone.
local tempTabScript = {};
GRM.DisableTabButtons = function( toDisable )
    if toDisable then
        -- Storing the scripts
        tempTabScript = { GRM_UI.GRM_RosterChangeLogFrame.GRM_LogTab:GetScript ( "OnClick" ) , GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsTab:GetScript ( "OnClick" ) , GRM_UI.GRM_RosterChangeLogFrame.GRM_AddonUsersTab:GetScript ( "OnClick" ) , GRM_UI.GRM_RosterChangeLogFrame.GRM_AddEventTab:GetScript ( "OnClick" ) , GRM_UI.GRM_RosterChangeLogFrame.GRM_BanListTab:GetScript ( "OnClick" ) , GRM_UI.GRM_RosterChangeLogFrame.GRM_GuildAuditTab:GetScript ( "OnClick" ) };

        -- removing the script
        GRM_UI.GRM_RosterChangeLogFrame.GRM_LogTab:SetScript ( "OnClick" , nil );
        GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsTab:SetScript ( "OnClick" , nil );
        GRM_UI.GRM_RosterChangeLogFrame.GRM_AddonUsersTab:SetScript ( "OnClick" , nil );
        GRM_UI.GRM_RosterChangeLogFrame.GRM_AddEventTab:SetScript ( "OnClick" , nil );
        GRM_UI.GRM_RosterChangeLogFrame.GRM_BanListTab:SetScript ( "OnClick" , nil );
        GRM_UI.GRM_RosterChangeLogFrame.GRM_GuildAuditTab:SetScript ( "OnClick" , nil );
    else
        -- restoring the script
        GRM_UI.GRM_RosterChangeLogFrame.GRM_LogTab:SetScript ( "OnClick" , tempTabScript[1] );
        GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsTab:SetScript ( "OnClick" , tempTabScript[2] );
        GRM_UI.GRM_RosterChangeLogFrame.GRM_AddonUsersTab:SetScript ( "OnClick" , tempTabScript[3] );
        GRM_UI.GRM_RosterChangeLogFrame.GRM_AddEventTab:SetScript ( "OnClick" , tempTabScript[4] );
        GRM_UI.GRM_RosterChangeLogFrame.GRM_BanListTab:SetScript ( "OnClick" , tempTabScript[5] );
        GRM_UI.GRM_RosterChangeLogFrame.GRM_GuildAuditTab:SetScript ( "OnClick" , tempTabScript[6] );
    end
end

-- Method:          GRM.DisableSubTabButtons()
-- What it Does:    Temporarily disables the Options sub tab buttons. Don't want to allow player to trigger click spam the button on transition.
-- Purpose:         Clicking button too fast will be error prone. This prevents that.
local tempTabScript2 = {};
GRM.DisableSubTabButtons = function( toDisable )
    if toDisable then
        -- Storing the scripts
        tempTabScript2 = { GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralTab:GetScript ( "OnClick" ) , GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_ScanTab:GetScript ( "OnClick" ) , GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_SyncTab:GetScript ( "OnClick" ) , GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_HelpTab:GetScript ( "OnClick" ) , GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_UITab:GetScript ( "OnClick" ) , GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_OfficerTab:GetScript ( "OnClick" ) , GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_UXTab:GetScript ( "OnClick" ) , GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_ModulesTab:GetScript ( "OnClick" ) , GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_HardcoreTab:GetScript ( "OnClick" ) };

        -- removing the script
        GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralTab:SetScript ( "OnClick" , nil );
        GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_ScanTab:SetScript ( "OnClick" , nil );
        GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_SyncTab:SetScript ( "OnClick" , nil );
        GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_HelpTab:SetScript ( "OnClick" , nil );
        GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_UITab:SetScript ( "OnClick" , nil );
        GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_OfficerTab:SetScript ( "OnClick" , nil );
        GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_UXTab:SetScript ( "OnClick" , nil );
        GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_ModulesTab:SetScript ( "OnClick" , nil );
        GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_HardcoreTab:SetScript ( "OnClick" , nil );
    else
        -- restoring the script
        GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_GeneralTab:SetScript ( "OnClick" , tempTabScript2[1] );
        GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_ScanTab:SetScript ( "OnClick" , tempTabScript2[2] );
        GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_SyncTab:SetScript ( "OnClick" , tempTabScript2[3] );
        GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_HelpTab:SetScript ( "OnClick" , tempTabScript2[4] );
        GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_UITab:SetScript ( "OnClick" , tempTabScript2[5] );
        GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_OfficerTab:SetScript ( "OnClick" , tempTabScript2[6] );
        GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_UXTab:SetScript ( "OnClick" , tempTabScript2[7] );
        GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_ModulesTab:SetScript ( "OnClick" , tempTabScript2[8] );
        GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_HardcoreTab:SetScript ( "OnClick" , tempTabScript2[9] );
    end
end

-- Method:              GRM.GR_Roster_Click ( string )
-- What it Does:        For logic on mouseover, instead of mouseover, it simulates a click on the item by bringing it to show.
--                      The "pause" is just a call to pause the hiding of the frame in the GRM_RosterFrame() function until it finds a new window (to prevent wasteful clicking and resource hogging)
-- Purpose:             Smoother UI interface in the built-in Guild Roster in-game UI default window.
GRM.GR_Roster_Click = function ( name )
    local time = GetTime();
    if GRM_G.RosterClickTimer == 0 or time - GRM_G.RosterClickTimer > 0.5 then   -- 500ms
        -- We are going to be copying the name if the shift key is down!
        
        if IsShiftKeyDown() and not GRM_G.RecursiveStop then

            if GetCurrentKeyBoardFocus() ~= nil then
                if GetCurrentKeyBoardFocus():GetName() ~= nil then
                    if "GRM_AddAltEditBox" == GetCurrentKeyBoardFocus():GetName() then
                        GetCurrentKeyBoardFocus():SetText ( name );
                    else
                        GetCurrentKeyBoardFocus():Insert ( GRM.SlimName ( name ) ); -- Adds it at the cursor position...
                    end
                end

                GRM_G.RecursiveStop = true;

                if GetCurrentKeyBoardFocus() ~= nil then
                    if GetCurrentKeyBoardFocus():GetName() ~= nil and GetCurrentKeyBoardFocus():GetName() == "GRM_AddAltEditBox" then
                        GRM.AddAltAutoComplete();
                        GRM_G.pause = true;
                    end
                end
            else
                -- Since player doesn't have keyboard focus, let's just default it to main chat window
                ChatFrame1EditBox:SetFocus()
                ChatFrame1EditBox:Insert ( GRM.SlimName ( name ) );
                
            end
        end
        GRM_G.RosterClickTimer = time;
    end
    GRM_G.RecursiveStop = false;
end

-- Method:          GRM.TriggerTrackingCheck()
-- What it Does:    Helps regulate some resource and timed efficient server queries, 
-- Purpose:         to keep from spamming or double+ looping functions.
GRM.TriggerTrackingCheck = function()

    if GRM_G.BuildVersion >= 30000 and GRM.IsCalendarEventEditOpen() then

        if not GRM_G.ScanningDelay then
            GRM_G.ScanningDelay = true;
            C_Timer.After ( 5 , function()
                GRM_G.ScanningDelay = false;
                GRM.TriggerTrackingCheck()
            end);                           -- Check again in 5 seconds.
        end

    else
        if not GRM_G.IntegrityTackingEnabled then
            GRM.TrackingIntegrityCheck();
        end

    end
end

-- Method:          GRM.TrackingIntegrityCheck ( bool )
-- What it Does:    Loops and rechecks in an interval for integrity tha the scan went off appropriately.
-- Purpose:         Useful for Classic Guild Roster loop integrity check
GRM.TrackingIntegrityCheck = function( isLoop )
    if GRM.S() and GRM.S().scanEnabled then          -- if Scanning is enabled

        if isLoop or not GRM_G.IntegrityTackingEnabled then

            GRM_G.IntegrityTackingEnabled = true;
            local delay = GRM.S().scanDelay;

            if ( time() - GRM_G.ScanControl ) >= ( GRM.S().scanDelay ) then
                GRM.GuildRoster();
                if GRM_G.BuildVersion >= 30000 then
                    QueryGuildEventLog();
                end

            else
                -- This ensures the timings on the delays line up with availability
                delay = ( GRM.S().scanDelay - ( time() - GRM_G.ScanControl ) ) + 0.2

            end

            C_Timer.After ( delay , function()
                GRM_G.IntegrityTackingEnabled = false;
                GRM.TrackingIntegrityCheck( true );
            end);

        end

    else
        GRM_G.IntegrityTackingEnabled = false;
    end
end

-- Method:          GRM.IsCalendarEventEditOpen()
-- What it Does:    Does a check if the calendar windows are open as the GuildRoster() check can cause things to lose cursor focus
-- Purpose:         Prevent background scanning and updating from messing up some UI interactions, like losing cursor focus.
GRM.IsCalendarEventEditOpen = function()
    local result = false;
    if ( CalendarCreateEventFrame and CalendarCreateEventFrame:IsVisible() ) or ( CalendarViewEventFrame and CalendarViewEventFrame:IsVisible() ) then
        result = true;
    end
    return result;
end

---------------------------------------------
-------- BACKGROUND SCANNING ----------------
---------------------------------------------

-- Method:          GRM.UpdateMacroToolSafeListExpirations()
-- What it Does:    It rechecks the roster to see if any of the players are on the ignore lists from the macro tool and removes them if the time has expired.
-- Purpose:         To be able to auto remove players from the ignore lists as time expires. Quality of life tool
GRM.UpdateMacroToolSafeListExpirations = function()
    if IsInGuild() then
        if not GRM_G.SafeListExpirationChecking then
            GRM_G.SafeListExpirationChecking = true;

            if GRM.GetGuild() then
                for _ , player in pairs ( GRM.GetGuild() ) do
                    if type ( player ) == "table" then
                        GRM.ValidateIgnoreExpireDates ( player );
                    end
                end
                    
                C_Timer.After ( GRM.S().scanDelay + 5 , function()     -- +5 is to ensure they don't end up ont he same parallel track dual scanning every time.
                    GRM_G.SafeListExpirationChecking = false;
                    GRM.UpdateMacroToolSafeListExpirations();
                end);
            end
        end
    else
        GRM_G.SafeListExpirationChecking = false;
    end
end

-- Method:          GRM.ValidateIgnoreExpireDates ( table )
-- What it Does:    It checks to see if their safeListSetting has expired, and if their time HAS expired, they are removed from the list.
-- Purpose:         This is the check that will be done to ensure rules are being monitored.
GRM.ValidateIgnoreExpireDates = function( player )

    if player then
        local time = time();

        for safeType , safeListSetting in pairs ( player.safeList ) do
            if safeListSetting[4] ~= 0 and safeListSetting[4] <= time then
                -- we know this is no longer valid and time has expired...
                
                if safeListSetting[2] then
                    if safeType == "kick" and CanGuildRemove() then
                        GRM.Report ( GRM.L ( "GRM:" ) .. " " .. GRM.L ( "{name} is now being monitored by the kick macro rules after being on the ignore list for {num} days." , GRM.GetClassifiedName ( player.name , false ) , nil , safeListSetting[3] ) );
                    elseif safeType == "promote" and CanGuildPromote() then
                        GRM.Report ( GRM.L ( "GRM:" ) .. " " .. GRM.L ( "{name} is now being monitored by the promote macro rules after being on the ignore list for {num} days." , GRM.GetClassifiedName ( player.name , false ) , nil , safeListSetting[3] ) );
                    elseif safeType == "demote" and CanGuildDemote() then
                        GRM.Report ( GRM.L ( "GRM:" ) .. " " .. GRM.L ( "{name} is now being monitored by the demote macro rules after being on the ignore list for {num} days." , GRM.GetClassifiedName ( player.name , false ) , nil , safeListSetting[3] ) );
                    end
                end

                player.safeList[safeType] = { false , false , 0 , 0 };

                if player.name == GRM_G.currentName and GRM_UI.GRM_MemberDetailMetaData.GRM_MacroToolIgnoreListSettingsFrame:IsVisible() then
                    GRM_UI.MacroIgnoreCheckBoxesFrame_OnShow();
                end
            end
        end
    end
end

---------------------------------------------
-------- SLASH COMMAND FUNCTIONS ------------
---------------------------------------------

-- Method:          GRM.SlashCommandScan()
-- What it Does:    Triggers a one-time scan of the guild for changes.
-- Purpose:         Mainly useful for people that wish to disable active scanning and just do a 1-time check on occasion.
GRM.SlashCommandScan = function()
    GRM.Report ( GRM.L ( "GRM:" ) .. " " .. GRM.L ( "Scanning for Guild Changes Now. One Moment..." ) );
    GRM_G.ManualScanEnabled = true;
    GRM.GuildRoster();
    if GRM_G.BuildVersion >= 30000 then
        QueryGuildEventLog();
    end
end

-- Method:          GRM.SyncCommandScan()
-- What it Does:    Activates a one-time data sync with guildies
-- Purpose:         For people that want to sync data, but don't want it to be on all the time, just on occasion as they choose.
--                  Flexibility to the user!
GRM.SyncCommandScan = function( count )

    count = count or 0;

    -- Let's recheck permissions as they can change mid-session if guild permissions are adjusted by guild leader.
    if not GRM_G.HasAccessToGuildChat and count == 0 then
        GRM.RegisterGuildChatPermission();

        C_Timer.After ( 1 , function()
            GRM.SyncCommandScan ( 1 ); -- Delay to ensure server has a second to send the response. - Count is to retry once.
        end);
        return;
    end

    if not GRMsyncGlobals.UILoaded then
        GRMsync.LoadSyncUI();
    end

    -- if not GRM_UI.GRM_SyncTrackerWindow:IsVisible() then
    --     GRM_UI.GRM_SyncTrackerWindow:Show();
    -- else
        if GRM.S().syncEnabled and GRM_G.HasAccessToGuildChat and not GRM_G.InGroup then

            if ( time() - GRMsyncGlobals.timeAtLogin ) >= GRM.S().syncDelay then

                if GRMsyncGlobals.currentlySyncing or ( not GRMsyncGlobals.currentlySyncing and ( time() - GRM_G.slashCommandSyncTimer > 10 ) ) then
        
                    if not GRMsyncGlobals.currentlySyncing then

                        GRMsyncGlobals.reloadControl = false;       -- Remove the hold on the first sync if it applies.

                        if not GRMsyncGlobals.SyncTracker.TriggeringSync then
                            GRMsyncGlobals.SyncTracker.TriggeringSync = true;
                            GRM_UI.GRM_SyncTrackerWindow.SyncTrackerText:SetText ( GRM.L ( "Initializing Sync. One Moment..." ) );
                            GRM_API.ResetProgressBar ( GRM_UI.GRM_SyncTrackerWindow.GRM_SyncProgressBar , { 1 , 0 , 0 } , false );
                        end

                        GRM_G.slashCommandSyncTimer = time();
                                
                        GRM.Report ( GRM.L ( "Initializing Sync Action. One Moment..." ) );
                        
                        if not GRM_UI.GRM_RosterChangeLogFrame.GRM_AddonUsersFrame:IsVisible() then
                            GRM.RegisterGuildAddonUsersRefresh();
                        end

                        GRM_UI.GRM_SyncTrackerWindow.GRM_SyncTrackerWindowButton:Hide();
        
                        C_Timer.After( 3 , GRMsync.Initialize );
        
                        -- Now, let's add a brief delay, 3 seconds, to trigger sync again
                        C_Timer.After ( 10 , function()
        
                            if GRM.GetNumAddonUsersAvailableToSync() == 0 and GRM.S().syncEnabled then

                                if #GRM_G.currentAddonUsers == 0 then
                                    GRM.Report ( GRM.L ( "GRM:" ) .. " " .. GRM.L ( "No Players Currently Online to Sync With..." ) );
                                    GRM_UI.GRM_SyncTrackerWindow.GRM_SyncTrackerWindowButton:Show();
                                    GRMsync.ResetSyncTracker();
                                else
                                    if #GRM_G.currentAddonUsers == 1 then
                                        GRM.Report ( GRM.L ( "GRM:" ) .. " " .. GRM.L ( "No Member is Available to Sync" ) );
                                        GRM_UI.GRM_SyncTrackerWindow.GRM_SyncTrackerWindowButton:Show();
                                        GRMsync.ResetSyncTracker();
                                    else

                                    end
                                end
                                GRM_UI.GRM_SyncTrackerWindow.GRM_SyncTrackerWindowButton:Show();
        
                            else
                                C_Timer.After ( GRMsyncGlobals.ErrorCD + 1 , function ()
                                    if not GRMsyncGlobals.WaitingInQue then
                                        if not GRMsyncGlobals.currentlySyncing and ( time() - GRMsyncGlobals.timeOfLastSyncCompletion >= 10 ) then
                                            GRM.Report ( GRM.L ( "GRM:" ) .. " " .. GRM.L ( "Sync has failed to start. Please try again!" ) );
                                            GRM_UI.GRM_SyncTrackerWindow.GRM_SyncTrackerWindowButton:Show();
                                            GRMsync.ResetSyncTracker();
                                        end
                                    end
                                end);
                            end
                        end);
                    else
                        local name = "";
                        if GRMsyncGlobals.IsElectedLeader then
                            name = GRM.GetClassifiedName ( GRMsyncGlobals.CurrentSyncPlayer );
                        else
                            name = GRM.GetClassifiedName ( GRMsyncGlobals.DesignatedLeader )
                        end
                        GRM.Report ( GRM.L ( "GRM:" ) .. " " .. GRM.L ( "Currently syncing with {name}. Please wait until after sync completes to activate again." , name ) );
                    end
        
                else
                    GRM.Report ( GRM.L ( "Please wait {num} more seconds before manually initiating the sync process again." , nil , nil , 15 - ( time() - GRM_G.slashCommandSyncTimer ) ) );
                    GRM_UI.GRM_SyncTrackerWindow.GRM_SyncTrackerWindowButton:Show();
                    GRMsync.ResetSyncTracker();

                end
            else
                GRM.Report ( GRM.L ( "Sync is disabled for {num} seconds after logging in. Please wait {custom1} seconds longer." , nil , nil , GRM.S().syncDelay , ( GRM.S().syncDelay - ( time() - GRMsyncGlobals.timeAtLogin ) ) ) );
                GRM_UI.GRM_SyncTrackerWindow.GRM_SyncTrackerWindowButton:Show();
                GRMsync.ResetSyncTracker();

            end

        elseif not GRM.S().syncEnabled then
            local restartSync = function()
                GRM.S().syncEnabled = true;
                GRM_UI.EnableSyncUIChanges();
                GRM_G.RegisterMessage();
                GRM.SyncCommandScan();
            end

            GRM.SetConfirmationWindow ( restartSync , GRM.L ( "Sync is Currently Disabled. Do you wish to re-enable?" ) );

        elseif GRM_G.HasAccessToGuildChat and GRM_G.InGroup then
            GRM.Report ( GRM.L ( "SYNC is currently disabled while you are grouped. Due to server restricted addon to addon talk data caps, and in an effort to avoid clogging up the shared global comm space of all addons, sync will be temporarily restricted while grouped." ) );

        elseif not GRM_G.HasAccessToGuildChat then
            GRM.Report ( GRM.L ( "SYNC is currently not possible! Unable to Sync with guildies when guild chat is restricted." ) );
        end
    -- end
  
end

-- Method:          GRM.SlashCommandCenter()
-- What it Does:    It Centers all of the windows, in case the player dragged them off the screen
-- Purpose:         Help keep frames organized. Just a necessary feature as someone is eventually going to say they tossed the frame off screen.
GRM.SlashCommandCenter = function()
    GRM_UI.GRM_RosterChangeLogFrame:ClearAllPoints();
    GRM_UI.GRM_RosterChangeLogFrame:SetPoint ( "CENTER" , UIParent );
    GRM.S().CoreWindowPos = { "" , "" , 0 , 0 };

    GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_AddBanFrame:ClearAllPoints();
    GRM_UI.GRM_RosterChangeLogFrame.GRM_CoreBanListFrame.GRM_AddBanFrame:SetPoint ( "CENTER" , UIParent );

    GRM_UI.GRM_AuditJDTool:ClearAllPoints();
    GRM_UI.GRM_AuditJDTool:SetPoint ( "CENTER" , UIParent );

    GRM_UI.GRM_ToolCoreFrame:ClearAllPoints();
    GRM_UI.GRM_ToolCoreFrame:SetPoint ( "CENTER" , UIParent );

    GRM_UI.GRM_ToolCoreFrame.GRM_ToolCustomRulesFrame:ClearAllPoints();
    GRM_UI.GRM_ToolCoreFrame.GRM_ToolCustomRulesFrame:SetPoint ( "CENTER" , UIParent );

    GRM_UI.GRM_RosterFrame:ClearAllPoints();
    GRM_UI.GRM_RosterFrame:SetPoint ( "CENTER" , UIParent );
    GRM.S().RosterFramePOS = { "" , "" , 0 , 0 };


    if GRMsyncGlobals.UILoaded then
        GRM_UI.GRM_SyncTrackerWindow:ClearAllPoints();
        GRM_UI.GRM_SyncTrackerWindow:SetPoint ( "CENTER" , UIParent );
        GRM.S().SyncTrackerPOS = { "" , "" , 0 , 0 };
    end
        
    GRM.S().macroToolCoordinates = { "" , "" , 0 , 0 };

    GRM_UI.ResetScalingForAll();
    local rosterFrameDefault = 885;

    if GRM_G.BuildVersion >= 80000 then
        rosterFrameDefault = rosterFrameDefault + 90;
    end

    GRM.S().UIScaling = { { 600 , 535 , 1.0 } , { 400 , 439 , 1.0 } , { 1200 , 515 , 1.0 } , { 1075 , 540 , 1.0 } , { 875 , 400 , 1.0 } , { rosterFrameDefault , 525 , 1.0 } };
end

-- Method:          GRM.SlashCommandHelp()
-- What it Does:    Displays a list of all slash commands and what they do
-- Purpose:         To HELP the player with slash commands lol
GRM.SlashCommandHelp = function()

    local slash = "/grm";
    local slash2 = "/roster";
    if GRM_L["/XXXX"] ~= true then
        slash = GRM_L["/XXXX"];
    end
    if GRM_L["/YYYY"] ~= true then
        slash2 = GRM_L["/YYYY"];
    end
    
    GRM.Report ( "\n" .. GRM.L ( "Guild Roster Manager" ) .. " " .. GRM.L ( "(Ver:" ) .. " " .. GRM_G.Version .. ")\n\n" .. slash .. "                     - " .. 
        GRM.L ( "Opens Guild Log Window" ) .. "\n" .. slash2 .. "                   - " .. 
        GRM.L ( "Opens Custom Guild Roster Window" ) .. "\n" .. slash .. " " .. GRM.L ( "clearall" ) .. "         - " .. 
        GRM.L ( "Resets ALL saved data" ) .. "\n" .. slash .. " " .. GRM.L ( "clearguild" ) .. "     - " .. 
        GRM.L ( "Resets saved data only for current guild" ) .. "\n" .. slash .. " " .. GRM.L ( "center" ) .. "          - " .. 
        GRM.L ( "Re-centers the Log window" ) .. "\n" .. slash .. " " .. GRM.L ( "sync" ) .. "             - " ..
        GRM.L ( "Triggers manual re-sync if sync is enabled" ) .. "\n" .. slash .. " " .. string.lower ( GRM.L ( "Export" ) ) .. "          - " ..
        GRM.L ( "Opens the Data Export Tool" ) .. "\n" .. slash .. " " .. string.lower ( GRM.L ( "Macro" ) ) .. "           - " ..
        GRM.L ( "Opens the Advanced Macro Tool" ) .. "\n" .. slash .. " <" .. GRM.L ( "TabName" ) .. ">  - " ..
        GRM.L ( "Open any GRM window: {name}, {name2}, {custom1}, etc." , GRM.L ( "log" ) , GRM.L ( "event" ) , nil , GRM.L ( "ban" ) ) .. "\n" .. slash .. " " .. GRM.L ( "scan" ) .. "             - " .. 
        GRM.L ( "Does a one-time manual scan for changes" ) .. "\n" .. slash .. " " .. GRM.L ( "dead" ) .. "             - " .. 
        GRM.L ( "Does a one-time check for dead accounts" ) .. "\n" .. slash .. " " .. GRM.L ( "version" ) .. "         - " .. 
        GRM.L ( "Displays current Addon version" ) .. "\n" .. slash .. " " .. "GUID" .. "           - " .. 
        GRM.L ( "Add unique player GUID to chat window to copy" ) .. "\n" .. slash .. " " .. GRM.L ( "hardreset" ) .. "      - " .. 
        GRM.L ( "WARNING! Complete hard wipe, including settings, as if addon was just installed." ) );
end

-- Method:          GRM.SlashCommandClearAll()
-- What it Does:    Resets all data account wide, as if the addon was just installed, on the click of the button.
-- Purpose:         Useful to purge data in case of corruption or trolling or other misc. reasons.
GRM.SlashCommandClearAll = function()
    GRM_UI.GRM_RosterChangeLogFrame:EnableMouse( false );
    GRM_UI.GRM_RosterChangeLogFrame:SetMovable( false );
    GRM_UI.GRM_RosterConfirmFrameText:SetText( GRM.L ( "Really Clear All Account-Wide Saved Data?" ) );
    GRM_UI.GRM_RosterConfirmYesButtonText:SetText ( GRM.L ( "Yes!" ) );
    GRM_UI.GRM_RosterConfirmYesButton:SetScript ( "OnClick" , function( _ , button )
        if button == "LeftButton" then
            GRM.ResetAllSavedData();      --Resetting!
            GRM_UI.GRM_RosterConfirmFrame:Hide();
        end
    end);
    GRM_UI.GRM_RosterConfirmFrame:Show();
end

-- Method:          GRM.SlashCommandClearGuild()
-- What it Does:    Resets all data guild wide, as if the guild is brand new or newly joined.
-- Purpose:         Useful to purge the data if someone trolled the guild and made a mess of the data, 
-- or if there is a major error corrupting the data, but you don't want to wipe all account wide
GRM.SlashCommandClearGuild = function()
    GRM_UI.GRM_RosterChangeLogFrame:EnableMouse( false );
    GRM_UI.GRM_RosterChangeLogFrame:SetMovable( false );
    GRM_UI.GRM_RosterConfirmFrameText:SetText( GRM.L ( "Really Clear All Guild Saved Data?" ) );
    GRM_UI.GRM_RosterConfirmYesButtonText:SetText ( GRM.L ( "Yes!" ) );
    GRM_UI.GRM_RosterConfirmYesButton:SetScript ( "OnClick" , function( _ , button )
        if button == "LeftButton" then
            GRM.ResetGuildSavedData( GRM_G.guildName );      --Resetting!
            GRM_UI.GRM_RosterConfirmFrame:Hide();
        end
    end);
    GRM_UI.GRM_RosterConfirmFrame:Show();
end

-- Method:          GRM.HardReset()
-- What it Does:    It deletes player addon settings, thus the addon detects that and assumes 
--                  this is the first time any toon has logged in with addon installed and 
--                  triggers full reset and initialization.
-- Purpose:         To bypass all UI features and do a full hard reset, if the player needs
--                  This has no warning, so it is mainly for emergency resets, just in case
GRM.HardReset = function()

    local hardReset = function()
        GRM_AddonSettings_Save = nil;
        GRM_AddonSettings_Save = {};
        ReloadUI();
    end

    GRM.SetConfirmationWindow ( hardReset , GRM.L ( "Do you really want to wipe all GRM data and settings account-wide?" ) );
end

-- Method:          GRM.SlashCommandVersion()
-- What it Does:    Displays the version of the addon (all viewable with /roster help)
-- Purpose:         General info if wanted.
GRM.SlashCommandVersion = function()
    GRM.Report ( "\n" .. GRM.L ( "Guild Roster Manager" ) .. "\nVer: " .. GRM_G.Version .. "\n" );
end

-- Method:          GRM.SlashCommandMinimapReset()
-- What it Does:    Resets the minimap to default position
-- Purpose:         In case player drags the minimap off screen...
GRM.SlashCommandMinimapReset = function()
    GRM_UI.ResetMinimapPositionToDefault()
end

-- Method:          GRM.SlashCommandKick()
-- What it Does:    Opens or closes the mass kick window
-- Purpose:         Allow slash command use of the mass kick window for ease
GRM.SlashCommandKick = function()
    if ( time() - GRMsyncGlobals.timeAtLogin ) > 5 or GRM_G.MinimapOk then
        if GRM_UI.GRM_ToolCoreFrame:IsVisible() then
            GRM_UI.GRM_ToolCoreFrame:Hide();
        else
            GRM_UI.GRM_ToolCoreFrame:Show();
        end
    else
        GRM.Report ( GRM.L ( "GRM:" ) .. " " .. GRM.L ( "One moment, GRM is still being configured." ) );
    end
end

-- Method:          GRM.SlashCommandBan()
-- What it Does:    Opens the Ban window by slash command
-- Purpose:         Expanded slash command controls.
GRM.SlashCommandBan = function()
    if not GRM_UI.GRM_RosterChangeLogFrame:IsVisible() then
        GRM_UI.GRM_RosterChangeLogFrame:Show();
    end
    GRM_UI.GRM_RosterChangeLogFrame.GRM_BanListTab:Click();
end

-- Method:          GRM.SlashCommandAudit()
-- What it Does:    Opens the Audit window by slash command
-- Purpose:         Expanded slash command controls.
GRM.SlashCommandAudit = function()
    if not GRM_UI.GRM_RosterChangeLogFrame:IsVisible() then
        GRM_UI.GRM_RosterChangeLogFrame:Show();
    end
    GRM_UI.GRM_RosterChangeLogFrame.GRM_GuildAuditTab:Click();
end

-- Method:          GRM.SlashCommandLog()
-- What it Does:    Opens the Log window by slash command
-- Purpose:         Expanded slash command controls.
GRM.SlashCommandLog = function()
    if not GRM_UI.GRM_RosterChangeLogFrame:IsVisible() then
        GRM_UI.GRM_RosterChangeLogFrame:Show();
    end
    GRM_UI.GRM_RosterChangeLogFrame.GRM_LogTab:Click();
end

-- Method:          GRM.SlashCommandUsers()
-- What it Does:    Opens the Sync Users window by slash command
-- Purpose:         Expanded slash command controls.
GRM.SlashCommandUsers = function()
    if not GRM_UI.GRM_RosterChangeLogFrame:IsVisible() then
        GRM_UI.GRM_RosterChangeLogFrame:Show();
    end
    GRM_UI.GRM_RosterChangeLogFrame.GRM_AddonUsersTab:Click();
end

-- Method:          GRM.SlashCommandEvents()
-- What it Does:    Opens the Events window by slash command
-- Purpose:         Expanded slash command controls.
GRM.SlashCommandEvents = function()
    if not GRM_UI.GRM_RosterChangeLogFrame:IsVisible() then
        GRM_UI.GRM_RosterChangeLogFrame:Show();
    end
    GRM_UI.GRM_RosterChangeLogFrame.GRM_AddEventTab:Click();
end

-- Method:          GRM.SlashCommandOptions()
-- What it Does:    Opens the Options window by slash command
-- Purpose:         Expanded slash command controls.
GRM.SlashCommandOptions = function()
    if not GRM_UI.GRM_RosterChangeLogFrame:IsVisible() then
        GRM_UI.GRM_RosterChangeLogFrame:Show();
    end
    GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsTab:Click();
end

-- Method:          GRM.SlashCommandExport()
-- What it Does:    Opens the export window
-- Purpose:         Give player access to feature
GRM.SlashCommandExport = function()
    GRM_UI.GRM_RosterChangeLogFrame.GRM_LogTab:Click();
    if not GRM_UI.GRM_ExportLogBorderFrame:IsVisible() then
        GRM_UI.GRM_ExportLogBorderFrame.TabPosition = 1;
        GRM_UI.GRM_ExportLogBorderFrame:Show();
    else
        GRM_UI.GRM_ExportLogBorderFrame:Hide();
    end
end

-- Method:          GRM.SlashCommandModulesOptions()
-- What it Does:    Opens the Module tab under Options
-- Purpose:         Easy slash command control to get here.
GRM.SlashCommandModulesOptions = function()
    GRM.SlashCommandOptions();
    GRM_UI.GRM_RosterChangeLogFrame.GRM_OptionsFrame.GRM_ModulesTab:Click();
end

-- Method:          GRM.SlashCommandGUID()
-- What it Does:    Pastes the player's GUID to the chat box to easily be copied
-- Purpose:         Special use case to obtain GUIDs
GRM.SlashCommandGUID = function()

    if GRM.GetPlayer ( GRM_G.addonUser ) then
        C_Timer.After ( 1 , function()
            ChatFrame1EditBox:ClearFocus();
            ChatFrame1EditBox:SetFocus();
            ChatFrame1EditBox:Insert ( GRM.GetPlayer ( GRM_G.addonUser ).GUID );
            ChatFrame1EditBox:HighlightText ( 0 , #ChatFrame1EditBox:GetText() );
        end);
    else
        GRM.Report ( GRM.L ( "One moment, GRM is still being configured." ) );
    end
end

GRM.SlashCommandSearch = function ( text )
    local searchName;

    if GRM.GetPlayer ( GRM_G.addonUser ) then
        GRM.SlashCommandAudit(); 

        -- if text == string.lower ( GRM.L ( "Search" ) ) or text == "Search" then
            -- Open search window, but nothing to search

        if string.match ( text , "(" ..string.lower ( GRM.L ( "Search" ) ) .. ").+" ) ~= nil then
            searchName = string.match ( text , string.lower ( GRM.L ( "Search" ) ) .. "(.+)" );

        elseif string.match ( text , "(Search).+" ) ~= nil then
            searchName = string.match ( text , "(Search).+" );

        end

        if searchName then

            if GRM_UI.GRM_RosterFrame and GRM_UI.GRM_RosterFrame:IsVisible() then

            elseif GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame:IsVisible() then
                GRM_UI.GRM_RosterChangeLogFrame.GRM_AuditFrame.GRM_PlayerSearchAuditEditBox:SetText ( GRM.Trim ( searchName ) );
                GRM.RefreshAuditFrames ( false , false , GRM.Trim ( searchName ) );
            else
                GRM_R.LoadRosterFrame();
                GRM_UI.GRM_RosterFrame.GRM_PlayerSearchRosterEditBox:SetText ( GRM.Trim ( searchName ) );
            end
        end
    else
        GRM.Report ( GRM.L ( "One moment, GRM is still being configured." ) );
    end
end

-- Method:          GRM.InitiateConfirmFrame ( string , function , string , string , function , bool , int , int )
-- What it Does:    Configures the generic popup window for confirmation of an action
-- Purpose:         Repeat use of the popup window without needing to keep copying and pasting the configuration window.
GRM.InitiateConfirmFrame = function ( InfoText , buttonFunction , button1Text , button2Text , cancelButtonFunction , disableCloseFunctionOnHide , width , height )
    
    local w = width or 275;
    local h = height or 120;

    GRM_UI.GRM_RosterConfirmFrame:SetSize ( w , h );
    GRM_UI.GRM_RosterConfirmFrameText:SetWidth ( GRM_UI.GRM_RosterConfirmFrame:GetWidth() - 10 );

    GRM_UI.GRM_RosterChangeLogFrame:EnableMouse( false );
    GRM_UI.GRM_RosterChangeLogFrame:SetMovable( false );
    -- Configure info text
    if InfoText ~= nil and InfoText ~= "" then
        GRM_UI.GRM_RosterConfirmFrameText:SetText( InfoText );
    else
        GRM_UI.GRM_RosterConfirmFrameText:SetText ( "" );
    end
    -- Yes Button
    if button1Text ~= nil and button1Text ~= "" then
        GRM_UI.GRM_RosterConfirmYesButtonText:SetText ( button1Text );
    else
        GRM_UI.GRM_RosterConfirmYesButtonText:SetText ( GRM.L ( "Yes!" ) );
    end
    -- Cancel Button
    if button2Text ~= nil and button2Text ~= "" then
        GRM_UI.GRM_RosterConfirmCancelButtonText:SetText ( button2Text );
    else
        GRM_UI.GRM_RosterConfirmCancelButtonText:SetText ( GRM.L ( "Cancel" ) );
    end
    GRM_UI.GRM_RosterConfirmYesButton:SetScript ( "OnClick" , function( _ , button )
        if button == "LeftButton" then
            if buttonFunction ~= nil then
                buttonFunction();
                GRM_UI.GRM_RosterConfirmFrame:Hide();
            else
                GRM.Report ( GRM.L ( "No Action Configured" ) );
            end
        end
    end);

    -- If custom logic on cancel as well
    if cancelButtonFunction then
        GRM_UI.GRM_RosterConfirmCancelButton:SetScript ( "OnClick" , function ( _ , button )
            if button == "LeftButton" then
                GRM_UI.GRM_RosterConfirmFrame:Hide();
                cancelButtonFunction();
            end
        end);
        GRM_UI.GRM_RosterConfirmFrame:SetScript ( "OnHide" , function ()
            if not disableCloseFunctionOnHide then
                cancelButtonFunction();
            end
            GRM_UI.GRM_RosterChangeLogFrame:EnableMouse ( true );
            GRM_UI.GRM_RosterChangeLogFrame:SetMovable ( true );
        end);

    -- or just the default actions
    else
        GRM_UI.GRM_RosterConfirmCancelButton:SetScript ( "OnClick" , function ( _ , button )
            if button == "LeftButton" then
                GRM_UI.GRM_RosterConfirmFrame:Hide();
            end
        end);
        GRM_UI.GRM_RosterConfirmFrame:SetScript ( "OnHide" , function ()
            GRM_UI.GRM_RosterChangeLogFrame:EnableMouse ( true );
            GRM_UI.GRM_RosterChangeLogFrame:SetMovable ( true );
        end);
    end

    GRM_UI.GRM_RosterConfirmFrame:Show();
end

-- Method:          GRM.DebugConfig( string )
-- What it Does:    Enables debugging logging
-- Purpose:         To help debug issues of course, by logging them.
GRM.DebugConfig = function( command )
    if GRM_G.DebugEnabled and not string.find ( command , " " ) then
        GRM_G.DebugEnabled = false;
        GRM.Report ( GRM.L ( "GRM Debugging Disabled." ) );
    else
        if GRM_G.DebugEnabled then
            local number = GRM.Trim ( string.sub ( command , string.find ( command , " " ) + 1 ) );
            if string.find ( command, " " ) ~= nil and tonumber ( number ) ~= nil then
                GRM.DebugLog ( tonumber ( number ) );
            else
                GRM.Report ( GRM.L ( "Error: Debug Command not recognized." ) .. "\n" .. GRM.L ( "Format: \"/grm debug 10\"" ) );
            end
        else
            GRM_G.DebugEnabled = true;
            GRM.Report ( GRM.L ( "GRM Debugging Enabled." ) .. "\n" .. GRM.L ( "Please type \"/grm debug 10\" to report 10 events (or any number)" ) );
            if #GRM_G.currentAddonUsers> 0 and GRM.S().syncEnabled then
                GRM.Report ( GRM.L ( "You may want to temporarily disable SYNC in the options if you are debugging another feature." ) );
            end
        end
    end
end

-- Method:          GRM.OpenCoreWindow ( bool )
-- What it Does:    Opens the Core Window
-- Purpose:         Reusable window to open the roster.
GRM.OpenCoreWindow = function( isGeneric )
    local openExport = false;

    if IsInGuild() then

        if not isGeneric and GRM_RosterChangeLogFrame:IsVisible() then
            openExport = true; -- Window is visible, we are going to open the export window

        else
            GRM_UI.MainWindowOpenLogic();
        end

    else
        GRM.Report ( GRM.L ( "{name} is not currently in a guild. Unable to Proceed!" , GRM.SlimName( GRM_G.addonUser ) ) );
    end

    return openExport;
end


-- SLASH COMMAND LOGIC
SlashCmdList["ROSTER"] = function ( input )

    local isAlreadyReported = false;

    if input == nil or input:trim() == "" then
        GRM_R.LoadRosterFrame();
    else
        isAlreadyReported = true;
        GRM.Report ( GRM.L ( "Invalid Command: Please type '/grm help' for More Info!" ) );
    end
    
    if not IsInGuild() and not isAlreadyReported then
        GRM.Report ( GRM.L ( "{name} is not currently in a guild. Unable to Proceed!" , GRM.SlimName( GRM_G.addonUser ) ) );
    end

end

-- SLASH COMMAND LOGIC
SlashCmdList["GRM"] = function ( input )
    -- if input is invalid or is just a blank info... print details on addon.
    local command;
    local alreadyReported = false;
    local inGuild = IsInGuild();
    if input ~= nil and string.lower ( input ) ~= nil then -- and string.find ( input , "forcepurge" , 1 , true ) == nil then  -- purge data may have name after, don't want to lowercase that
        command = string.lower ( input );
    end


    if input == nil or input:trim() == "" then
        GRM.OpenCoreWindow( true );

    -- Clears all saved data and resets to as if the addon was just installed. The only thing not reset is the default settings.
    elseif command == "clearall" or command == "resetall" or command == GRM.L ( "clearall" ) then
        alreadyReported = true;
        GRM.SlashCommandClearAll();
    
    -- Clears all saved data specific to the guild...
    elseif command == "clearguild" or command == "resetguild" or command == GRM.L ( "clearguild" ) then
        if inGuild then
            GRM.SlashCommandClearGuild();
        end

    -- Does a hard reset of the entire database...
    elseif command == "hardreset" or command == GRM.L ( "hardreset" ) then
        GRM.HardReset();
    -- List of all the slash commands at player's disposal.
    elseif command == "help" or command == GRM.L ( "help" ) then
        alreadyReported = true;
        GRM.SlashCommandHelp();

    -- Version
    elseif command == "version" or command == "ver" or command == GRM.L ( "version" ) then
        alreadyReported = true;
        GRM.SlashCommandVersion();

    -- Resets the poisition of the window back to the center.
    elseif command == "reset" or command == "center" or command == GRM.L ( "center" ) then
        alreadyReported = true;
        GRM.SlashCommandCenter();
    
    -- Re-triggering SYNC
    elseif command == "sync" or command == GRM.L ( "sync" ) then
        if inGuild then
            GRM.SyncCommandScan()
        end

    -- For manual scan trigger!
    elseif command == "scan" or command == GRM.L ( "scan" ) then
        if inGuild then
            GRM.SlashCommandScan();
        end

    -- for resetting the minimap
    elseif command == "minimap" or command == GRM.L ( "minimap" ) then
        alreadyReported = true
        GRM.SlashCommandMinimapReset();

    elseif command == "ban" or command == GRM.L ( "ban" ) then
        GRM.SlashCommandBan();

    elseif command == "audit" or command == GRM.L ( "audit" ) then
        GRM.SlashCommandAudit();

    elseif command == "log" or command == GRM.L ( "log" ) then
        GRM.SlashCommandLog();

    elseif command == "kick" or command == GRM.L ( "kick" ) or command == "tool" or command == string.lower ( GRM.L ( "Tool" ) ) or command == "promote" or command == string.lower ( GRM.L ( "Promote" ) ) or command == "demote" or command == string.lower ( GRM.L ( "Demote" ) ) or command == "macro" or command == string.lower ( GRM.L ( "Macro" ) ) then
        GRM.SlashCommandKick();

    elseif command == "users" or command == "syncusers" or command == GRM.L ( "users" ) or command == GRM.L ( "syncusers" ) then
        GRM.SlashCommandUsers();
        
    elseif command == "event" or command == "events" or command == GRM.L ( "event" ) or command == GRM.L ( "events" ) then
        GRM.SlashCommandEvents();

    elseif command == "opt" or command == "option" or command == "options" or command == GRM.L ( "opt" ) or command == GRM.L ( "option" ) or command == GRM.L ( "options" )then
        GRM.SlashCommandOptions();

    elseif command == "export" or command == string.lower ( GRM.L ( "Export" ) ) then
        if GRM.OpenCoreWindow ( false ) then
            GRM.SlashCommandExport();
        end

    elseif command == "module" or command == string.lower ( GRM.L ( "Module" ) ) or command == "plugin" or command == string.lower ( GRM.L ( "Plugin" ) ) then
        GRM.SlashCommandModulesOptions();

    elseif command == "dead" or command == string.lower ( GRM.L ( "dead" ) ) or command == "deadnames" or command == string.lower ( GRM.L ( "deadnames" ) ) then
        GRM.CheckForDeadAccounts( true );
        GRM.Report ( GRM.L ( "Dead player accounts found: {num}" , nil , nil , #GRM_G.customKickList ) );

    -- FOR FUN!!!
    elseif command == "hello" or command == "sexy" then
        alreadyReported = true;
        GRM.Report ( "Arkaan is SEXY! Mmmm Arkaan! Super, ridiculously hot addon dev!" );

    elseif command == "guid" then
        GRM.SlashCommandGUID();

    -- /grm search
    elseif string.match ( command , "(" ..string.lower ( GRM.L ( "Search" ) ) .. ").+" ) ~= nil or string.match ( command , "(Search).+" ) ~= nil or command == string.lower ( GRM.L ( "Search" ) ) or command == "Search" then
        GRM.SlashCommandSearch ( command )

    elseif string.find ( command , "debug" ) ~= nil then
        GRM.DebugConfig( command );
    else
        alreadyReported = true;
        GRM.Report ( GRM.L ( "Invalid Command: Please type '/grm help' for More Info!" ) );
    end
    
    if not inGuild and not alreadyReported then
        GRM.Report ( GRM.L ( "{name} is not currently in a guild. Unable to Proceed!" , GRM.SlimName( GRM_G.addonUser ) ) );
    end
end

------------------------------------------------
------------------------------------------------
----- INITIALIZATION AND LIVE TRACKING ---------
------------------------------------------------
------------------------------------------------

-- Method:              GRM.InitiateMemberDetailFrame()
-- What it Does:        Event Listener, it activates when the Guild Roster window is opened and interface is queried/triggered
--                      "GuildRoster()" needs to fire for this to activate as it creates the following 4 listeners this is looking for: GUILD_ROSTER_UPDATE
-- Purpose:             Create an Event Listener for the Guild Roster Frame in the guild window ('J' key)
GRM.InitiateMemberDetailFrame = function ()
    if not GRM_G.FramesInitialized then
        GRM_G.FramesInitialized = true;

        -- Member Detail Frame Info
        GRM_UI.EstablishClassicFrames()                 -- For compatibility reasons
        GRM_UI.GR_MetaDataInitializeUIFirst( false ); -- Initializing Frames
        GRM_UI.GR_MetaDataInitializeUISecond( false ); -- To avoid 60 upvalue Lua cap, place them in second list.
        GRM_UI.GR_MetaDataInitializeUIThird( false ); -- Also, to avoid another 60 upvalues!
        
        GRM_G.UIIsLoaded = true;

        GRM_UI.DefaultFramesRecursiveInit ( false , false );
    end
end

-- Method:          GRM.AllRemainingNonDelayFrameInitialization()
-- What it Does:    Initializes general important frames that are not in relations to the guild roster window.
-- Purpose:         By walling this off, it allows far greater resource control rather than needing to initialize entire UI.
GRM.AllRemainingNonDelayFrameInitialization = function()
    
    UI_Events:RegisterEvent ( "PLAYER_LOGOUT" );
    
    -- UI_Events:RegisterEvent ( "UPDATE_INSTANCE_INFO" );
    UI_Events:SetScript ( "OnEvent" , function( _ , event )
        if event == "PLAYER_LOGOUT" then
            -- Save debugging log, up to 250 instances
            GRM_DebugLog_Save = GRM_G.DebugLog;

            -- Clear the macro in case it hasn't been cleared yet (GRM tool is open on a reload or logout.)
            GRM.CreateMacro ( "/run GRM.Report(\"" .. GRM.L ( "Reserved for GRM Macro Tool Usage. Please do not delete." ) .."\")" , "GRM_Tool" , "INV_MISC_QUESTIONMARK" , GRM_G.MacroHotKey , true );
        end
    end);

end

-- ClubID create my own algorithm
GRM.CreateCustomGUIDValue = function( guildName )
    local result = 0;
    local nameByteArray = { string.byte ( guildName , 1 , -1 ) };
    for i = 1 , #nameByteArray do
        result = result + nameByteArray[i];
    end
    return result;
end

-- Method:          GRM.ConfigureGuild()
-- What it Does:    It establishes the properly formated guildName as well as the clubID
-- Purpose:         Why cycle through the guilds over and over again to find the position, when you can store the index of the database in the array with a simple global variable? Massive resource save!
GRM.ConfigureGuild = function()
    -- Configure the guild
    if GRM_G.guildName == "" or not GRM.GetGuild() then
        local guildName , _ , _ , server = GetGuildInfo ( "PLAYER" );

        if server ~= nil then
            GRM_G.guildName = guildName .. "-" .. string.gsub ( string.gsub ( server , "-" , "" ) , "%s+" , "" );
        else
            GRM_G.guildName = guildName .. "-" .. GRM_G.realmName;
        end
    end

    if GRM_G.BuildVersion >= 80000 then
        if C_Club.GetGuildClubId() ~= nil then
            GRM_G.gClubID = C_Club.GetGuildClubId();
        end
    else
        GRM_G.gClubID = GRM.CreateCustomGUIDValue ( GRM_G.guildName );
    end

    local guildData = GRM.GetGuild();

    -- Fixes for old guilds... this can only be done when on that actual guild, however.
    if guildData ~= nil then
        -- Guild info
        if guildData.grmNumRanks == 0 then
            if GuildControlGetNumRanks() ~= nil then
                guildData.grmNumRanks = GuildControlGetNumRanks();
            end
        end
        if GRM_G.gClubID ~= nil and ( guildData.grmClubID == nil or guildData.grmClubID == 0 ) then
            guildData.grmClubID = GRM_G.gClubID;
        end
        if guildData.grmCreationDate == "" then
            guildData.grmCreationDate = GRM_G.guildCreationDate;
        end

        -- Backup
        if GRM_GuildDataBackup_Save[ GRM_G.guildName ] ~= nil then
            if GRM_GuildDataBackup_Save[ GRM_G.guildName ].guildCreationDate == nil or GRM_GuildDataBackup_Save[ GRM_G.guildName ].guildCreationDate == "" then
                GRM_GuildDataBackup_Save[ GRM_G.guildName ].guildCreationDate = GRM_G.guildCreationDate;
            end
        else
            GRM.FixBackups();
        end

        if GRM_G.FirstTimeViewed and GRM_G.IndexOfLastLogEntry == 0  then
            GRM_G.IndexOfLastLogEntry = #GRM.GetLog();
        end
    end

end

-- Method:          GRM.FixBackups()
-- What it Does:    Fixes an old issue of guild backups not properly converting on a name change by rebuilding the backup.
-- Purpose:         To Fix guild backups.
GRM.FixBackups = function()
      -- Creates a backup index for this guild
      
    GRM_GuildDataBackup_Save[ GRM_G.guildName ] = {};
    GRM_GuildDataBackup_Save[ GRM_G.guildName ].guildCreationDate = GRM_G.guildCreationDate;
    GRM_GuildDataBackup_Save[ GRM_G.guildName ]["date"] = "";
    GRM_GuildDataBackup_Save[ GRM_G.guildName ]["epochDate"] = 0;
    GRM_GuildDataBackup_Save[ GRM_G.guildName ]["numGuildies"] = 0;
    GRM_GuildDataBackup_Save[ GRM_G.guildName ]["members"] = {};
    GRM_GuildDataBackup_Save[ GRM_G.guildName ]["formerMembers"] = {};
    GRM_GuildDataBackup_Save[ GRM_G.guildName ]["log"] = {};
    GRM_GuildDataBackup_Save[ GRM_G.guildName ]["alts"] = {};

end

-- Method:          GRM.ConfigureAnnounceOnLogin( bool )
-- What it Does:    Configured the announcement saved variable to be refreshed each day
-- Purpose:         Prevent repeat spamming.
GRM.ConfigureAnnounceOnLogin = function( forceReset )
    local month , day , year = select ( 2 , GRM.GetTodaysDate() );
    local dateStamp = "";

    if day < 10 then
        day = "0" .. day;
    end
    if month < 10 then
        month = "0" .. month;
    end

    dateStamp = year .. month .. day;

    if forceReset or GRM_DailyAnnounce.date ~= dateStamp then
        GRM_DailyAnnounce = {};
        GRM_DailyAnnounce.date = dateStamp;
    end
end

-- Method:          GRM.InitializePreCheck()
-- What it Does:    Checks if the intial changes and updates are all recorded, including the status of all players who have left or joined the guild
-- Purpose:         You do not want to trigger and initialize the addon to sync with others until this initial process is completed after login. It could take just a few seconds to complete
--                  particularly due to players who have removed many many from the guild and have limited friends slot places to determine their server status with the add frienc, check, remove trick
GRM.InitializePreCheck = function( recursive )
    if not GRM_G.InitializePreCheck or recursive then
        GRM_G.InitializePreCheck = true;
        if not GRM_G.OnFirstLoad then
            GRM_G.InitializePreCheck = false;
            C_Timer.After ( GRM.S().syncDelay , function()
                if GRM.S().autoTriggerSync then
                    GRMsync.Initialize();
                end
            end);
        else
            C_Timer.After ( 1 , function()
                GRM.InitializePreCheck( true )
            end);
        end
    end
end

-- Method:          GRM.TrackingConfiguration( bool )
-- What it Does:    Initializes the first check on login after configuring all the initial details for guild 
-- Purpose:         Control flow of data inquiries 
GRM.TrackingConfiguration = function( forced )
    if IsInGuild() and ( not GRM_G.trackingTriggered or forced ) then
        GRM_G.trackingTriggered = true;
        GRM_G.currentlyTracking = true;
            
        -- Add an escape if necessary due to unloaded data points. It will try again in 10 seconds or less, whenever the server calls back.
        if GRM_G.guildCreationDate == "" or not GRM_G.NumberOfHoursTilRecommend["kick"] or not GRM_G.NumberOfHoursTilRecommend["kickActive"] or ( GRM_G.BuildVersion >= 80000 and GRM_G.gClubID == 0 ) then
            GRM.DelayForGuildInfoCallback();
            return
        end
        -- Establish proper database tags before building and scanning roster data
        -- For massive resourcing saving, let's establish core data points.
        GRM.ConfigureGuild();

        if GRM_G.OnFirstLoad and GRM.GetGuild() then

            if not GRM_PlayerListOfAlts_Save[GRM_G.guildName] then
                GRM_PlayerListOfAlts_Save[GRM_G.guildName] = {};
            end

            if not GRM_PlayerListOfAlts_Save[GRM_G.guildName][GRM_G.addonUser] then
                GRM_PlayerListOfAlts_Save[GRM_G.guildName][GRM_G.addonUser] = {};
            end

        end

        if not GRM_G.GuildNamechangeProcessing and not GRMsyncGlobals.currentlySyncing then
            GRM.BuildNewRoster();
        end

        if GRM_G.GuildNamechangeProcessing then
            C_Timer.After ( 1 , function()
                GRM.TrackingConfiguration ( true );
            end);
            return
        end
        
        if not GRM_G.secureHookKicks then
            GRM_G.secureHookKicks = true
            -- From Kick Macro
            hooksecurefunc ( "GuildUninvite" , function( nameOrGUID )
                GRM.GetPlayerKickedFromButton( nameOrGUID , true )
            end);

            -- From Kick Button
            hooksecurefunc ( C_GuildInfo , "RemoveFromGuild" , function( nameOrGUID )
                GRM.GetPlayerKickedFromButton( nameOrGUID , false )
            end);
        end

        GRM.UpdateMacroToolSafeListExpirations();

        GRM.ScanRecommendationsList();

        -- Determine if player has access to guild chat or is in restricted chat rank
        GRM.RegisterGuildChatPermission();

        -- Determine if player is already listed as alt...
        if GRM.CheckIfNeedToAddAlt() then
            GRM.AddPlayerToOwnAltList();
        end

        -- Auto import if it is player's own toon.
        if GRM_G.BuildVersion > 80000 and ( #GRM.GetAddOnUserGuildAlts()[GRM_G.addonUser] == 0 or not GRM.GetAddOnUserGuildAlts()[GRM_G.addonUser][1] ) then
            local addonUser = GRM.GetAddOnUserGuildAlts()[GRM_G.addonUser];
            if #addonUser == 0 then
                addonUser[1] = false;
            end
            GRM.ImportJoinDate ( GRM_G.guildName );
        end

        C_Timer.After ( 5 , function()
            GRM.UpdateGuildLeaderPermissions( false , false );
        end);

        -- Open the core addon frame...
        if GRM.S().viewOnLoad and not GRM.S().onlyViewIfChanges then
            GRM_UI.GRM_RosterChangeLogFrame:Show();
        end

        -- Establish Message Sharing as well!
        GRMsyncGlobals.SyncOK = true;
            
        -- Only trigger a sync on relog.
        GRM.InitializePreCheck();

        -- MISC frames to be loaded immediately, not on delay
        GRM.AllRemainingNonDelayFrameInitialization();
        GRM.GuildRoster();
        if GRM_G.BuildVersion >= 30000 then
            QueryGuildEventLog();
        end  -- Let's trigger this and get it loading at the start.

        C_Timer.After ( 2 , function()
            UI_Events:RegisterEvent ( "GUILD_ROSTER_UPDATE" );
            if GRM_G.BuildVersion >= 30000 then
                UI_Events:RegisterEvent ( "GUILD_EVENT_LOG_UPDATE" );
            end

            UI_Events.Timer = 0;
        
            UI_Events:SetScript ( "OnEvent" , function ( _ , event )
                if time() - UI_Events.Timer > 1 then
                    UI_Events.Timer = time();
                    if ( event == "GUILD_EVENT_LOG_UPDATE" and GRM_G.BuildVersion >= 30000 ) then
                        GRM.LogPrecheck();
                    elseif event == "GUILD_ROSTER_UPDATE" then
                        GRM.RosterPreCheck();
                    end
                end
            end);
            
            if GRM.S().scanEnabled then
                -- GRM.TriggerTrackingCheck();
                C_Timer.After( GRM.S().scanDelay , GRM.TriggerTrackingCheck ); -- Recursive check every X seconds. + 0.1 
            end
        end);
        
    elseif not IsInGuild() then
        GRM_G.currentlyTracking = false;
    end
end

-- Method:          GRM.DelayForGuildInfoCallback()
-- What it Does:    It basically recursively waits til the conditions are met and the server properly retrieved the guildCreationDate
-- Purpose:         If a guild is on more than one server with the same name, that can complicate things. This helps idenitfy the server by the creation date as well...
GRM.DelayForGuildInfoCallback = function()
    if GRM_G.guildCreationDate == "" then
        GRM_G.DelayCount = GRM_G.DelayCount + 1;
        if GRM_G.DelayCount == 5 then               -- At the 5th try, let's check if system messages are disabled. If they are, tell player to enable.
            GRM.SystemMessageEnabledCheck();
        end
        GRM.SetGuildInfoDetails();
        GRM.GuildRoster();
        C_Timer.After ( 1 , GRM.DelayForGuildInfoCallback );
    elseif GRM_G.NumberOfHoursTilRecommend["kick"] == nil or GRM_G.NumberOfHoursTilRecommend["kickActive"] == nil then
        GRM.RefreshNumberOfHoursTilRecommend();

        C_Timer.After ( 1 , GRM.DelayForGuildInfoCallback );

    elseif GRM_G.BuildVersion >= 80000 and GRM_G.gClubID == 0 then
        if C_Club.GetGuildClubId() ~= nil then
            GRM_G.gClubID = C_Club.GetGuildClubId();
        end
        C_Timer.After ( 1 , GRM.DelayForGuildInfoCallback );

    else
        GRM_G.trackingTriggered = false;
        GRM.TrackingConfiguration( false );
    end
end

-- Method:          GRM.MessageHookControl()
-- What it Does:    checks to ensure script modification is post all other addons to ensure compatibility
-- Purpose:         Simple solution than writing a whole new Raw Hook control and updating the AddMessage text which can be spammy.
GRM.MessageHookControl = function()
    local chatEvents = { "CHAT_MSG_GUILD" , "CHAT_MSG_WHISPER" , "CHAT_MSG_GUILD_ACHIEVEMENT" , "CHAT_MSG_PARTY" , "CHAT_MSG_PARTY_LEADER" , "CHAT_MSG_RAID", "CHAT_MSG_RAID_LEADER" , "CHAT_MSG_INSTANCE_CHAT" , "CHAT_MSG_INSTANCE_CHAT_LEADER" , "CHAT_MSG_OFFICER" }

    if GRM_G.MainHookConfigured and IsInGuild() and GRM.S() then
        for i = 1 , #chatEvents do
            local events = ChatFrame_GetMessageEventFilters( chatEvents[i] );

            if #events > 1 then
                if events[#events] ~= GRM.AddMainToChat then
                    -- Let's unregister, then re-register!
                    ChatFrame_RemoveMessageEventFilter ( chatEvents[i] , GRM.AddMainToChat );
                    -- Now Re-Add it!
                    ChatFrame_AddMessageEventFilter ( chatEvents[i] , GRM.AddMainToChat );
                end
            end
        end
    else
        GRM_G.MainHookConfigured = true;
        for i = 1 , #chatEvents do
            ChatFrame_AddMessageEventFilter ( chatEvents[i] , GRM.AddMainToChat );
        end
    end
end

-- Method:          GRM.SystemMessageHookControl()
-- What it Does:    Checks to ensure script modification happens at the end of the sequential table to ensure all addon compatibility
-- Purpose:         Quality of life - prevent frustration for other addon devs
GRM.SystemMessageHookControl = function()

    local events = ChatFrame_GetMessageEventFilters( "CHAT_MSG_SYSTEM" );

    if #events > 1 then
        if events[#events] ~= GRM.SetSystemMessageFilter then
            -- Let's unregister, then re-register!
            ChatFrame_RemoveMessageEventFilter ( "CHAT_MSG_SYSTEM" , GRM.SetSystemMessageFilter );
            -- Now Re-Add it! We want GRM to be FINAL one added to ensure no overlapping compatibility or prioritization of other devs. By unregistering and registering, it adds it to tail end last position.
            ChatFrame_AddMessageEventFilter ( "CHAT_MSG_SYSTEM" , GRM.SetSystemMessageFilter );
        end
    end
end

-- Method:          GRM.LoadAddon()
-- What it Does:    Enables tracking of when a player joins the guild or leaves the guild. Also fires upon login.
-- Purpose:         Manage tracking guild info. No need if player is not in guild, or to reactivate when player joins guild.
GRM.LoadAddon = function()
    
    GeneralEventTracking:RegisterEvent ( "PLAYER_GUILD_UPDATE" ); -- If player leaves or joins a guild, this should fire.
    GeneralEventTracking:SetScript ( "OnEvent" , GRM.ManageGuildStatus );

    SystemMessageChecking:RegisterEvent ( "CHAT_MSG_SYSTEM" );
    SystemMessageChecking:SetScript ( "OnEvent" , GRM.JoinPlayerLiveEvent );

	if GRM_G.BuildVersion < 80000 and GRM_G.BuildVersion >= 30000 then
		-- Achievements are broken in WotLK classic - so don't announce for modern versions or it'll duplicate
	    C_ChatInfo.RegisterAddonMessagePrefix("GRMACHIEV");
	    AchievementsChecking:RegisterEvent("CHAT_MSG_ADDON");
	    AchievementsChecking:RegisterEvent("ACHIEVEMENT_EARNED");
	    AchievementsChecking:SetScript("OnEvent", function( _ , event, prefix, msg, channel, sender )
            if IsInGuild() then
                if event == "CHAT_MSG_ADDON" and prefix == "GRMACHIEV" and channel == "GUILD" and sender ~= GRM_G.addonUser then
                    if GRM.S() and GRM.S().achievements then
                        GRM.AnnounceAchievement(sender, msg);
                    end
                elseif event == "ACHIEVEMENT_EARNED" and GRM.S() and GRM.S().achievements then
                    GRM.OnAchievementEarned(prefix)
                end
            end
	    end);

	end
    
    -- Initialize chat tagging
    if IsInGuild() then
        GRM.MessageHookControl();
    end

    -- Quick Version Check
    if not GRM_G.VersionCheckRegistered then
        GRM.RegisterVersionCheck();
        C_ChatInfo.SendAddonMessage ( "GRMVER" , GRM_G.Version.. "?" .. tostring ( GRM_G.PatchDay ) , "GUILD" );
        GRM_G.VersionCheckRegistered = true;
    end

    if not GuildFrame then
        LoadAddOn ( "Blizzard_GuildUI" );
    end

    -- Modular load control
    GRM_G.GRMfunctionDisabled = false;

    -- Delay needs to be here to try to help prevent any initialization errors that might occur for some people.
    if GRM_G.BuildVersion >= 80000 and not CommunitiesFrame then
        C_Timer.After ( 3 , function()
            GRM.LoadRecursiveErrorCheck();
            LoadAddOn ( "Blizzard_Communities" );
        end);
    else
        GRM.LoadRecursiveErrorCheck();
    end
    
end

-- Method:          GRM.LoadRecursiveErrorCheck()
-- What it Does:    Rechecks if a certain frame function is loaded. 
-- Purpose:         For some reason some edge cases out there some clients load these very slow, and an addon can trigger before this is done.
GRM.LoadRecursiveErrorCheck = function()
    
    if ( GRM_G.BuildVersion < 80000 and UIDropDownMenu_CreateInfo() == nil ) or ( GRM_G.BuildVersion >= 80000 and not CommunitiesFrame ) then
        C_Timer.After ( 3 , function()
            GRM.LoadRecursiveErrorCheck();
        end);
    else
        GRM.finalLoadSteps();
    end
end

-- Method:          GRM.finalLoadSteps()
-- What it Does:    Throttles loading information
-- Purpose:         Compartmentalizes and throttles loading details until the frames are loaded by the system so as to prevent attempts to hook into frames that do not yet exist
GRM.finalLoadSteps = function()
        -- Determine who is using the addon...
    -- 3 second dely to account for initialization of various variables. Safety cushion.
    C_Timer.After ( 3 , GRM.RegisterGuildAddonUsers );

    -- Important to set this in case player logs in whilst in a group
    if IsInGroup() then
        GRM_G.InGroup = true;
    end

    -- Activate the GRM frames!
    GRM.InitiateMemberDetailFrame();
    GRM.GuildRoster();

    if GRM_G.BuildVersion >= 30000 then
        QueryGuildEventLog();
    end

    C_Timer.After ( 1 , function()
        GRM.TrackingConfiguration ( false );
    end);
    
end

-- Method:          GRM.ReactivateAddon ()
-- What it Does:    If addon no longer needs to be enabled due to player not being in a guild, or leaving a guild, this slimmer reactivation protocol
--                  is necessary because it doesn't need to re-register frames like it would on the first activation upon logging in.
-- Purpose:         Resource efficiency.
GRM.ReactivateAddon = function()

    C_Timer.After ( 5 , GRM.RegisterGuildChatPermission );

    GRM.SetGuildInfoDetails();
    GRM.GuildRoster();
    if GRM_G.BuildVersion >= 30000 then
        QueryGuildEventLog();
    end

    if not GRM.S() then
        GRM_AddonSettings_Save[GRM_G.guildName] = {};
        -- Load the Default Settings
        for i = 0 , GRM_G.SettingsPages do
            GRM.SetDefaultAddonSettings ( GRM_AddonSettings_Save[GRM_G.guildName] , i );
        end
    end

    if not GRM_UI.GRM_RosterChangeLogFrame.GRM_RosterChangeLogFrameReScale then
        -- Let's set window scales now...
        GRM_UI.SetAllWindowScales( true );
    end
    
    C_Timer.After ( 2 , GRM.LoadAddon );
end

-- Method           GRM.ManageGuildStatus()
-- What it Does:    If player leaves or joins the guild, it deactivates/reactivates tracking - as well as re-checks guild to see if rejoining or new guild.    
-- Purpose:         Efficiency in resource use to prevent unnecessary tracking of info if out of the guild.
GRM.ManageGuildStatus = function ()
    GeneralEventTracking:UnregisterEvent ( "PLAYER_GUILD_UPDATE" );
    if GRM_G.guildStatusChecked ~= true then
       GRM_G.timeDelayValue = time(); -- Prevents it from doing "IsInGuild()" too soon by resetting timer as server reaction is slow.
    end
    if GRM_G.timeDelayValue == 0 or ( time() - GRM_G.timeDelayValue ) >= 2 then -- Let's do a recheck on guild status to prevent unnecessary scanning.
        if IsInGuild() then
            if GRM_G.DelayedAtLeastOnce then
                if not GRM_G.currentlyTracking then
                    GRM.ReactivateAddon();
                    -- return
                end
            else
                GRM_G.DelayedAtLeastOnce = true;
                C_Timer.After ( 5 , GRM.ManageGuildStatus );
                -- return
            end
        else
            -- Reset some values;
            if not GRM_G.GRMfunctionDisabled then
                GRM_G.GRMfunctionDisabled = true;
                GRMsyncGlobals.SyncOK = false;
                GRM_G.IndexOfLastLogEntry = 0;
                GRM_G.OnFirstLoad = true;
                GRM_G.guildName = "";
                GRM_G.guildCreationDate = "";
                GRM_G.trackingTriggered = false;
                GRM_G.currentlyTracking = false;
                GRM_G.DelayedAtLeastOnce = true;                     -- Keeping it true as there does not need to be a delay at this point.
                GRM_G.guildRankNames = nil;                         -- reset guild rank names.
                GRMsyncGlobals.DatabaseLoaded = false;

                if GRM_G.BuildVersion >= 30000 then
                    UI_Events:UnregisterEvent ( "GUILD_EVENT_LOG_UPDATE" );         -- This prevents it from doing an unnecessary tracking call if not in guild.
                end
                if GRMsync.MessageTracking ~= nil then
                    GRMsync.MessageTracking:UnregisterAllEvents();
                end
                GRMsync.ResetDefaultValuesOnSyncReEnable();                     -- Need to reset sync algorithm too!
                GRM_UI.GRM_RosterChangeLogFrame:Hide();

                -- Modules enabling and Disabling
                GRM.DisableModulesIfLeavingGuild();
            end
        end

        GeneralEventTracking:RegisterEvent ( "PLAYER_GUILD_UPDATE" );
        GeneralEventTracking:SetScript ( "OnEvent" , GRM.ManageGuildStatus );
        GRM_G.guildStatusChecked = false;
    else
        GRM_G.guildStatusChecked = true;
        C_Timer.After ( 2 , GRM.ManageGuildStatus ); -- Recursively re-check on guild status trigger.
    end
end

-- Method:          ActivateAddon( self , string , string )
-- What it Does:    First, doesn't trigger to load until all variables of addon fully loaded.
--                  Then, it triggers to delay until player is fully in the world, in that order.
--                  Finally, it delays 5 seconds upon querying server as often initial Roster and Guild Event Log query takes a moment to return info.
-- Purpose:         To ensure the smooth handling and loading of the addon so all information is accurate before attempting to parse guild info.
GRM.ActivateAddon = function ( _ , event , addon , isReload )
    if event == "ADDON_LOADED" and addon == GRM_G.addonName then
        Initialization:UnregisterEvent ("ADDON_LOADED");
        Initialization:RegisterEvent ( "PLAYER_ENTERING_WORLD" ); -- Ensures this check does not occur until after Addon is fully loaded.
    elseif event == "PLAYER_ENTERING_WORLD" then
        Initialization:UnregisterEvent ("PLAYER_ENTERING_WORLD");

        if isReload then
            GRMsyncGlobals.reloadControl = true;
        end

        if GRM_G.faction == nil then
            GRM_G.faction = UnitFactionGroup ( "PLAYER" );
        end

        GRM.ConfigureAnnounceOnLogin();                         -- So no repeat announcements

        GRM_G.OStimeOffset = GRM.GetTimeOffesets();             -- One time configuration of gameTime Offsets;

        GRM.DataLoadDelayProtection();
    end
end

-- Method:          GRM.DataLoadDelayProtection()
-- What it Does:    It checks if the calendar and date info is available from the server yet and if not, it recursively reloads
-- Purpose:         To prevent certain errors due to the server returning this information slowly as of patch 8.1.5 for some reason.
GRM.DataLoadDelayProtection = function()
    if GRM.GetCurrentCalendarTime().month ~= 0 and GRM.GetCurrentCalendarTime().month ~= nil and ( not IsInGuild() or ( IsInGuild() and GetGuildInfo ( "PLAYER" ) ~= nil ) )then       -- Critical to be receiving data properly from the server...

        if IsInGuild() then
            -- Need to pull guildName
            local guildName , _ , _ , server = GetGuildInfo ( "PLAYER" );

            if not guildName then
                -- Sometimes you have to call the server API twice to get it back.
                guildName , _ , _ , server = GetGuildInfo ( "PLAYER" );
            end

            if server ~= nil then
                GRM_G.guildName = guildName .. "-" .. string.gsub ( string.gsub ( server , "-" , "" ) , "%s+" , "" );
            else
                GRM_G.guildName = guildName .. "-" .. GRM_G.realmName;
            end
        end

        GRM.LoadSettings();
    else
        C_Timer.After ( 0.2 , GRM.DataLoadDelayProtection );
    end
end;

-- Method:          GRM.SettingsLoadedFinishDataLoad()
-- What it Does:    Compartmentalizes the OnLoad process of the addon so some things can be verified and pre-checked before continuing, like loading addon settings.
-- Purpose:         Prevent errors of course!
GRM.SettingsLoadedFinishDataLoad = function()
    -- Rerun this for the language changes...
    -- this will also build initial frames...
    local langIndex = GRM_G.LocalizedIndex;
    if GRM.S() then
        langIndex = GRM.S().selectedLang;
        GRM_G.MacroHotKey = GRM.S().macroHotKey;
    else
        GRM_G.MacroHotKey = "CTRL-SHIFT-K";
    end

    GRML.SetNewLanguage ( langIndex , true , false );

    -- Restore debugLog since addonloaded
    GRM_G.DebugLog = GRM_DebugLog_Save;


    if IsInGuild() then
        
        -- Let's set window scales now...
        GRM_UI.SetAllWindowScales( true );

        GRM.GuildRoster();                                       -- Initial queries...
        if GRM_G.BuildVersion >= 30000 then
            QueryGuildEventLog();
        end

        -- MISC Quality of Life Settings...
        -- Addon Compatibility Detection
        -- EPGP uses officer notes and is an incredibly popular addon. This now ensures auto-adding not will default to PUBLIC note rather than officer.
        if IsAddOnLoaded("epgp") and GRM.S().joinDateDestination ~= 3 then
            GRM.S().joinDateDestination = 2;
        end
        
        C_Timer.After ( 2 , GRM.LoadAddon );                 -- Queries do not return info immediately, gives server a 2 second delay.
    else
        GRM.ManageGuildStatus();
    end
end

-- Method:          GRM.DisableModulesIfLeavingGuild()
-- What it Does:    Disables all the GRM plugin modules if player is no longer in group
-- Purpose:         To house all of the module disable calls in one function
GRM.DisableModulesIfLeavingGuild = function()
    if GRM_G.Module.GroupInfo ~= nil and GRM_G.Module.GroupInfo then
        GRM.DisableGroupInfoModule();
    end
end

-- Method:          GRM.GetNumModules()
-- What it Does:    Returns the int num of plugin modules for GRM that are enabled
-- Purpose:         Useful information and to display the modules tab properly if necessary
GRM.GetNumModules = function()
    local num = 0;
    for _ in pairs ( GRM_G.Module ) do
        num = num + 1;
    end

    return num;    
end

-- Method:          GRM.OnAchievementEarned()
-- What it Does:    Announced earned achievements to the guild in classic
-- Purpose:         Fixes a bug in WoTLK Classic :D
GRM.OnAchievementEarned = function(id)

    local link = GetAchievementLink(id)
    if link then
        -- Just to ensure the global sync cap is not broken, add to the count
        GRMsyncGlobals.SyncCount = GRMsyncGlobals.SyncCount + #link + #"GRMACHIEV"    
        C_ChatInfo.SendAddonMessage ( "GRMACHIEV", link, "GUILD");
    end
end

-- Method:          GRM.AnnounceAchievement()
-- What it Does:    Announced earned achievements from the guild in classic
-- Purpose:         Fixes a bug in WoTLK Classic :D
GRM.AnnounceAchievement = function(source, link)
	local name, _ = GRM.GetNameWithMainTags(source, true, true, false, true)
	local message = string.gsub(string.gsub(BROADCAST_ACHIEVEMENT, "%%s", name), "$a", link);
	local color = ChatTypeInfo["GUILD"];
	GRM.Report("|cff00c8ff" .. GRM.L("GRM:" ) .. "|r " .. message, color.r, color.g, color.b);
end


-- Initialize the first frames as game is being loaded.
Initialization:RegisterEvent ( "ADDON_LOADED" );
Initialization:SetScript ( "OnEvent" , GRM.ActivateAddon );